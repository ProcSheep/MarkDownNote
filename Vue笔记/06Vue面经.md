## Vue高频面试题-Vue内功心法
- 1.**单向数据流和双向数据绑定**
  - 单向-父子通讯: 父组件传给子组件信息,父组件修改信息后会同步进入子组件,但是子组件修改信息不会自动传回给父组件,需要emit,defineEmits方法去辅助,这就是单项数据流,这是为了代码更好的维护,防止子组件失误更改父组件信息影响到其他的子组件
  - 双向数据流: v-model,适用于表单form的数据绑定
- 2.**Object defineProperty有什么缺点(Vue2的底层,Vue3升级proxy)** 
  - 无法监听ES6的set map
  - 无法监听class数据
  - 属性的添加与删除(对象)无法监听
  - 数组元素的增加与删除也无法监听
- 3.**对MVC MVP MVVM的理解**
  - ...没听懂,不过MVVM是最好的模式
- 4.**Vue2和3关于生命周期的变化(老问题)**
  - 如图:
        [![pA6hVh9.jpg](https://s21.ax1x.com/2024/11/10/pA6hVh9.jpg)](https://imgse.com/i/pA6hVh9)
- 5.**结合2,Vue响应式的原理? Proxy(Vue3)和Object.defineProperty(Vue2)的区别**
  - 如图:
    [![pA6hn6x.jpg](https://s21.ax1x.com/2024/11/10/pA6hn6x.jpg)](https://imgse.com/i/pA6hn6x)
- 6.**Composition API的新开发体验**
  - 在组合式中组织代码可以提高可维护性和可读性,类似于hook写法,简洁
  - 解决生命周期函数时,选项式写法会把同一个功能拆分到不同函数中,比如定时器在mounted创建,在destory中删除,许多的不相关逻辑代码都如此拆分到一个个的生命周期函数中会显得业务逻辑混乱,不好维护,而组合式hooks每一个引进的模块都可以有自己的一套生命周期函数,在模块中可以功能和代码一体化,内部不会有其他的功能代码掺杂,选项式是大锅饭,每个生命周期函数都集合了所有功能的不同阶段操作,而组合式是小碗饭,只会在自己模块中的生命周期函数执行自己相关功能的代码,最后一起引入App.vue即可
- 7.**对比jQuery,vue有什么不同**
  - jQuery注重图层,直接操作dom进行页面渲染(很多都是别人封装好的dom操作),vue专注于数据层,不经常操作dom,通过数据双向绑定响应式更改dom,vue还是用了组件化思想,提高了复用性
- 8.**vue中如何定义全局css**
  - style默认全局,加scoped默认局部
- 9.**\$root \$parent \$refs的区别**
  - \$root和\$parent都能访问父组件的属性和方法,区别在于存在多级子组件时,通过parent只能访问最近一层的父组件,而root可以直接访问到根父组件(一步到位快约中间所有的组件,直接到根组件); 
  - 通过在子组件标签上定义ref属性,父组件可以通过\$refs访问子组件实例(可以操控子组件内部的属性和方法(赋值,调用等),而不需要传统的父传子,耦合度高,不推荐)
- 10.**Vue中如何自定义指令**
  - 一种封装好的获取dom节点的方法,区别于js的documnet.getElementBy....,自定义指令也有常用的钩子函数,比如bind和update
  - 如图:
    [![pA6hepR.jpg](https://s21.ax1x.com/2024/11/10/pA6hepR.jpg)](https://imgse.com/i/pA6hepR)
- 11.**Vue过滤器(略)Vue3不支持**
  - Vue2用filter的一些语法过滤,而Vue3使用计算属性和函数方法解决,其中计算属性无法传参
  - 过滤器作用是对数据进行2次加工,比如把地址中的乱码去掉(乱码是防止地址被盗用而添加的安全措施)等
- 12.**Vue单页面的优缺点**
  - ==优点:==
    - 1.单页面内容的更改不需要跳转到新的页面,也就不用加载整个页面,内核就是单页面的div隐藏与显示,看似内容变了,其实页面没变化
    - 2.没有页面切换,不会出现'白屏'现象(网络延迟等),而且可以在网页切换的组件中添加加载组件,对于有延迟的切换显得不那么空,起码不是白屏,更可以做一个404页面(组件),相对比浏览器的原生未响应404页面,这个页面你可以自己定制化的制作
    - 3.对服务器压力小,服务器只需提供数据,不需要处理展示逻辑和页面合成
    - 4.良好的前后端分离,同一套后端代码应用于web,手机,平板等多个客户端(对后端的友好)
  - ==缺点:==
    - 1.首次加载耗时长(可以懒加载减轻加载组件的负担)
    - 2.SEO问题,不利于百度,360引擎的收录,爬虫爬不到
    - 3.容易css命名冲突
    - 4.前进,后退,地址栏,书签等,都需要程序管理,页面复杂度高,==**所以使用Vue一定要善于站在巨人的肩膀上,善于使用别人封装好的组件(移动端的vant和PC端的elementPlus)**==
- 13.**Vue-router使用params与query的区别**
  - 第一次学到这个是跳转电影详情页面时,我们需要知道这是哪个电影的详情页面,所以需要把电影的filmId传递负责渲染电影详情页面的Detail组件,所以有了这2个传递方式
  - 这2个传参形成的url不同,接受的方式也不同,但本质区别不大
    [![pA6hm11.jpg](https://s21.ax1x.com/2024/11/10/pA6hm11.jpg)](https://imgse.com/i/pA6hm11)
- 14.**keep-alive的作用**
  - 顾名思义'保持活着',每次切换组件路由会销毁组件,但是keep-alive可以保留组件状态,避免下次切回来重复渲染,但是内部的mounted和created等钩子函数只会在第一次进入组件时调用,后面不会调用了,如果需要再次调用它们需要active和deactive,这两个钩子函数时keep-alive独有的
- 15.**vue如何实现单页面应用**
  - hash(#): 通过监听浏览器 onhashchange()事件变化去查找对应的路由器规则
  - history(/): 利用H5新增API pushState()和replaceState()和一个事件onpopstate监听url的变化
- 16.**4种的vue指令和它的用法**
  - v-if: 判断隐藏,从创建角度进行,如果隐藏压根不创建这个节点
  - v-show: 判断隐藏,无论隐不隐藏,都会创建这个节点,类似css的block和hidden
  - v-for: 循环,常用于遍历数组,记得+key,提高复用(与diff算法有关)
  - v-bind: 绑定css属性
  - v-model: 双向数据绑定 form表单
- 17.**如何一个路径渲染多个组件?**
  - 通过对router-view命名name,然后引入路由时一一对应,如图:
    [![pA6IY9J.jpg](https://s21.ax1x.com/2024/11/10/pA6IY9J.jpg)](https://imgse.com/i/pA6IY9J)
- 18.**多个组件共享一个路由?**
  - 将多个路由的component字段值设置为同一个组件即可
    ```
        const routes = [
            {path:'/',component: Home}, // 默认页面为home
            {path:'/home',component: Home},
        ]
    ```
- 19.**如何检测动态路由的变化**
  - 典型案例: 电影界面'猜你喜欢'点击时不会触发mounted函数,从而导致无法发送新的数据请求axios,导致页面渲染不更新,解决就是通过watch+\$route监听(**笔记: 路由/同组件跳转问题**)或通过导航守卫钩子函数beforeRouteUptate来监听他的变化(**笔记: 路由/组件内的守卫(局部拦截)**)
- 20.**vue-router中的router-link上的v-slot属性怎么用?**
  - 具体内容: **笔记: 路由/声明式导航部分**
  - 简单解释: Vue3定制化标签比Vue2麻烦点,可以通过v-slot给标签添加样式,也可以通过router-link标签去代替a标签,它如同template标签一样,自己是不显示在页面中,在上面挂载css属性,自带a标签的跳转功能,==我们在笔记中使用li标签包住router-link标签实现了定制化的li标签+路由跳转功能==
  - kerwin代码如下: (这个是想把css样式加到li上,而非a标签,==这里新颖的点是没有用三目,对class动态绑定,内部不同的class和isActive(与 &&)链接在一起,isExactActive是未点击为true,从而实现点击到时class是router-link-active,没有点击到时,class为router-link-exact-active==)
  - 代码如图:
    [![pA6IGh4.jpg](https://s21.ax1x.com/2024/11/10/pA6IGh4.jpg)](https://imgse.com/i/pA6IGh4)
- 21.**Vue如何去除url的#**
  - 将路由模式有hash改为history
  - ==这里有个新问题(服务器会认定你这些路由path在后端服务器中真的有并会去访问,所以需要提前告知后端服务器人员)==,后端(服务器)开发人员需要添加一个简单回退路由,url不匹配任何静态路由,就需要提供与你应用程序中的index.html相同页面,把权限提供给前端,由vue接管这些路路径由即可
  - 操作如下(vite已经自动规避了这个报错)
  ```
     var history = require('connect-history-api-fallback')
     app.use(history({
        index: './index.html'
     })) // 注意放在所有接口后面
  ```
- 22.**\$router和\$route的区别**
  - /$route是获取路由信息的,他是一个路由信息的对象,基本信息例如name,meta,path,query,params,fullpath,matched和redirectedForm等
  - /$router是VueRouter的实例,包含一些跳转方法,push,go,replace等
- 23.**Vue路由守卫**
  - 经典的路由跳转时检查用户是否有登录授权,如果没有统一跳转到登录页面,有许多钩子函数,例如beforeEach,对所有跳转到此路由的页面进行检查
  - 对路由的跳转进行监控,控制它的跳转或取消,有to,from,next三个参数,如下图:
    [![pA6I8NF.jpg](https://s21.ax1x.com/2024/11/10/pA6I8NF.jpg)](https://imgse.com/i/pA6I8NF)
- 24.**Vue路由的底层实现原理(源码中的相关知识,没学,很难)**
  - 如图:
    [![pA6I3AU.jpg](https://s21.ax1x.com/2024/11/10/pA6I3AU.jpg)](https://imgse.com/i/pA6I3AU)
- 25.**路由的懒加载**
  - 动态导入组件,只有使用到那个组件时才会导入组件,不会从一开始就全部导入
  - 静态导入: `import XX from 'XX'`
  - 动态导入(由webpack封装好了): `const XX = () => import('XX')`
- 26.**插槽,具名插槽和匿名插槽,则么用的**
  - 如下图(解释的很清楚):
    [![pA6XwDJ.jpg](https://s21.ax1x.com/2024/11/10/pA6XwDJ.jpg)](https://imgse.com/i/pA6XwDJ)
- 27.**Vue-loader(???)**
  - 解释和转换 .vue文件,提取中script style HTML template,再把它们交给对应的Loader去处理
- 28.**Vue和React中diff算法区别**
  - React还没学...
- 29.**请你说一下Vue中create和mount的区别**
  - create为组件的初始化阶段,主要完成数据观测,属性和方法的运算,watch/event事件的回调,此时挂载还没开始,未生成真实的DOM,也就无法操作dom,而mounte已经完成了虚拟dom到真实dom的转换挂载,此时html已经渲染出来了,所以可以直接操作dom节点
  - 异步类型的操作比如ajax放在哪个函数中都无所谓,因为异步等待数据的事件很长,代码执行会很快执行完mount阶段,所以等数据回来时,早就挂载好dom了
- 30.**axios是什么?怎么使用?如何使用它实现登录功能的流程?**
  - 涉及新知识axios的拦截器: ???
  - 12:55
- 31.**computed和watch的区别(有时会穿插案例进行面试提问)**
  - ==computed:==
  - computed计算属性会把计算结果进行缓存,如果下次还是这个结果,会直接调取缓存,不像函数调用那样每次都会重新计算(不过计算属性无法传参),同时如果依赖的数据发生了变化,computed会同步重新计算一次并再次缓存
  - 但是计算属性无法处理异步的数据,即由异步导致的数据变化时,是无法监听的,具体案例就是 电影界面的'猜你喜欢'跳转,由异步发送的ajax,url会变化,但是计算属性无法监控这一变化,只能处理同步数据
  - 计算属性可以引入多个属性进行计算,例如: 引入属性a和b相加,返回出去,也可以对单个数据计算,例如: 引入c "result = " + c返回出去
  > 
  - ==watch:==
  - 不支持缓存,一旦发现变化立即执行回调函数,可以在这个回调函数中放入我们上面提到的发送ajax去请求新的数据
  - 2个参数,一个是最新的值,一个是老的值
  - immediate立即监听和deep深度监听属性(针对多层嵌套对象进行监听)  ==注意:数组无需这么做==
- 32.**Vue $forceUpdate强制更新**
  - 很少用,强迫当前实例本身和插槽内子组件重新渲染(注意:不是所有的子组件,只是在插槽内的,而且后代也不算入(子的子...))
- 33.**v-for的key(20:50)**
  - key是Vue中唯一标记的id,通过它我们diff算法可以更精确快捷
  - diff算法在新老虚拟dom做对比时,可以最大化的复用数据,发现id和数据都相同直接复用;id相同数据不同,那就更新;发现在新dom中这个id没了,就直接删除发现出现了新的id和数据,直接添加,并且会根据参考相邻已有的id进行插入位置的确定
- 34.**为什么key不能为index(索引)?(23:54)**
  - 新老对比: 对比key相同的值,由于删除了一个数据,所以新数据如果还是按照index去定义key值,那么从删除位置往后的所有数据的key都会-1,那么key相同的进行对比就会发生'错位',这样会导致vue对大量的数据进行更新(相同index下,老数据会更新为前一个索引的值),以此类推,很麻烦,如果是唯一id的化,那么就不会发生'错位',直接删除
  - 数组删除,特指从中间删除时,会增加更新dom的时间成本,唯一的id可以使vue精准地找到位置进行定点删除
- 35.**diff复杂度原理及具体过程画图**
  - ==kerwin录制了js的数据结构和算法课,还是不错的==
  - diff算法是一种通过同层树节点进行比较的高效算法,避免了对树进行逐层搜索,所以时间复杂度只有O(n)
  - Vue Diff: 
    - 组件对比(component Diff): 
      - 如果组件的名字不同,就认为不是同一个组件,直接创建一个新组件替换老组件
      - 如果组件名字相同,就会认为组件可以复用,进入下一阶段Element Diff
    - 元素对比(Element Diff): 
      - 文本标签对比: 
        - 如果标签一样(都是div),那么只更新文本
        - 如果标签不一样,直接创建新标签和替换老标签
      - 列表(数组)对比: 上面讲到的diff数组,分为'更新,添加,删除'操作
  - 具体的源代码原理太复杂,不写了
- 36.**Vue组件中的Data为什么是函数,根组件确实对象?** 
  - data是一个函数的话,每复用一次组件都会返回一个新的data,类似给每个组件实例创造一个私有数据空间,让各个组件维护各自的数据,而写成对象会导致所有组件公用一份data(复杂数据,地址都一样),所以会造成一个变全部变
- 37.**Vue组件通讯**
  - props和emits(基础父子通讯)
  - \$attrs和\$listeners
  - provide和inject(跨级通信)
  - v-model传递
  - \$parent和\$children(暴力修改,不推荐)
  - vuex/pinia,状态共享工具(跳出三界之外统筹规划)
- 38.**什么时候用Vuex?**
  - 只有大项目用,小项目一个store即可
- 39.**Vuex可以直接修改state吗?**
  - 可以,但是无法被监管,无法实现时间漫游/回退,很不安全
- 40.**Vuex的mutation为何不能做异步?**
  - 就这么设计的,如果mutation支持异步,就不知道状态何时更新,不好监控,而通过action处理好异步的数据直接给mutation再处理就更好监控了
- 41.**如何修改Vuex的状态,Vuex中有哪些方法**
  - 推荐: 按照流程套路 this.\$store.commit("mutation中的方法")
  - 不推荐: this.\$store.state.属性
- 42.**Vuex的缺点**
  - 流程麻烦,Vuex是繁琐冗余的,并且state的值会伴随着浏览器的刷新而初始化,无法缓存,只适合大型的单页面应用
  - 当然vuex持久化运行的库 vuex-persistedstate
- 43.**什么是Vue.nextTick()?**
  - nextTick是用于下次dom更新循环结束之后的执行延迟回调,即可以满足回调函数可以享受到dom更新后的数据
  - 我们修改一个状态后,立即在js中获取这个修改状态的dom,你会发现dom内的状态还没有修改,这是vue生命周期规则的特性,dom对象不会立即更新,我们可以写在updated生命周期函数里,但是任何一个状态的修改都会影响updated的执行,重复多次执行这个dom的获取并不是好方法,所以nextTick的作用是会立即获取更新后的dom对象,然后执行回调函数,把你要对此dom的操作放在回调函数内部即可(==nextTick是一次性的==)
  - 之前我们学习封装轮播图时,new Swiper的时机就是在渲染完dom之后的,我们给轮播数据datalist赋值(v-for)数据并不会立马创建dom对象,而在updated中重复new Swiper会出BUG,所以当时就是用的nextTick,在赋值数据后,立马获取更新后的dom对象,然后立即执行new操作,而且nextTick只是一次性的,所以不必担心多次new
- 44.**nextTick的原理,是宏任务还是微任务?**
  - ...
- 45.**虚拟dom为何会提高性能?**
  - 虚拟dom是一个js对象,使用这个js对象来模拟真实的dom(kerwin的课中还专门讲过这个对象的格式,不重要,就是把对象信息用一些格式存储起来了),而且当数据变化时,只会局部刷新变化位置的数据
  - 虚拟dom相当于在js和真实dom中加了一个缓存,利用dom diff算法避免以一些没有必要的dom操作(真实的dom操作是复杂的,例如盖房子,虚拟dom相当于在图纸上删删减减,看看哪一面墙不需要,而真实dom是真的抡大锤拆墙,显然比图纸修改麻烦多了),虚拟dom弄好后一步到位到真dom,提高了性能
  - 步骤如下:
    - 用js对象解构标识DOM树解构,然后根据树构建真正的一个dom树
    - 当状态变更时,重新构造一个对象树,新旧树进行对比,记录两颗树的差异
    - 把2记录的差异应用到步骤1所构建的真正的dom树上,视图就更新
- 46.**==你做过哪些Vue的性能优化?==**
  - 1.首屏加载优化---懒加载(单页面应用没必要一开始加载所有的组件,用到哪个加载那个)
  - 路由的懒加载:
    ```
        {
            path: '/',
            name: 'home',
            component: ()=>import('XXX')
        }
    ```
  - 2.开启服务器Gzip .....(没学过)
  - 有关webpack的插件 ....
  - 3.启动CDN加速,采用cdn方式引入一些第三方资源,用于缓解我们服务器的压力,将其分担给其他的服务器
  - 4.代码层面的优化:
    - computed和watch区分使用场景(==31系统地讲解了==)
    - v-if和v-show的使用,v-if使用的好,可以提高性能,因为条件为假时它可以直接不创建dom,例如: 对用户权限有要求的dom就可以v-if,因为大部分用户没有权限,所以压根不用渲染这个dom,节省浏览器的压力
    - v-for必须添加不重复的key
    - webpack对图片的压缩
    - 避免内存泄漏,少用闭包
    - 减少ES6转ES5的代码,很多浏览器都升级了(不再需要兼容低版本浏览器),我们应该转到更高级的ES8,ES9等
- 47.**vue常用的修饰符**
  - ==v-model修饰符==:
    - 1 .lazy: 光标离开时才会同步,v-model是一有变化就同步(太勤快了)
    - 2 .trim: 输入框过滤首尾空格,比如用户设置密码,账号,用户名等失误输入空格
    - 3 .number: 输入内容的数字部分自动转化为数字类型
      - 如果有非数字的部分内容,会被截取,如果没有一个是数字,那么就无能无力了,全原样转化为字符串
      - 不添加的话,即使输入数字也会默认把数字类型转化为字符串类型
  - ==事件修饰符==:
    - 4 .stop: 阻止事件向上冒泡
    - 5 .prevent 阻止默认行为,比如表单的提交,a标签的跳转
    - 6 .self 必须本事件触发才执行事件处理函数,别的事件冒泡上来的行为不会触发,拒绝接受冒泡
    - 7 .once: 事件只会执行一次
    - 8 .capture: 事件在捕获阶段触发,事件触发阶段'捕获->目标->冒泡',事件触发是目标往外冒泡
    - 9 .sync: 对prop双向绑定
    - 10 .keyCode: 监听按键指令,具体看vue的键码对应表
- 48.**Vue中的tempalte的编译过程**
  - ....难,很底层,又设涉及源代码了
- 49.**Vue3.0的了解**
  - 六大亮点:
    - 1.性能比vue2快1.2-2倍
    - 2.体积比vue2小
    - 3.支持组合式API
    - 4.更好的支持TS
    - 5.更先进的组件
  - 性能更快的原因:
    - 1.diff算法快
    - 2.静态提升
    - 3.事件监听缓存
  - 体积小了: vite大功劳
- 50.**Vue3.0组合式(VCA)API**
  - 如图,hooks方法构建,组合式API十分的简洁,整体性更强,不像选项是API东一块西一块的'割裂感'
    [![pA6XNgU.jpg](https://s21.ax1x.com/2024/11/10/pA6XNgU.jpg)](https://imgse.com/i/pA6XNgU)
    [![pABQDBt.jpg](https://s21.ax1x.com/2024/10/30/pABQDBt.jpg)](https://imgse.com/i/pABQDBt)
- 51.**对ref和reactive的简单理解**
  - ref和ractive都是vue3的监听方法,reactive只能监听复杂类型(arr,数组),ref复杂简单都可以(它是reactive的二次封装),但是我们一般用于监听简单数据类型,因为只能监听一个变量
- 52.**Vuex与redux的区别**
  - redux没学....
- 53.**==简单说下 微信小程序和Vue的区别==**
  - 1.生命周期:
    - 小程序的生命周期是页面方面,更简单
    - .... 待定,kerwin有微信小程序的课(21年的了很旧了,还是先看Plus的吧)