## 前后端交互笔记
### 须知
### 善于查阅语法文档进行自学补充

- nodejs安装地址: C:\Program Files\nodejs\
- 前端与后端:
  - 前端三大件 : `html` + `css` + `javascript` 

      - 页面的结构显示
      - 用户的操作交互 

  - 后端是由 : `服务器` , `服务端语言` , `数据库` 组成的
      - 服务器 : 接收浏览器的请求 , 根据浏览器配置返回响应内容; 
      - 服务端语言 : 负责处理请求逻辑的! 
      - 数据库 : 记录用户信息的! 

  - 前后端交互 : 
      - 页面想要现实的数据太多了 , 程序会把异步分的页面结构存储在服务端, 在服务端以数据的形式进行存储 , 前端就不写那么多的html结构页面了; 
      - 记录用户信息的操作 , 我们需要把用户的操作，用的信息反馈给服务端， 由服务端进行数据处理! 

  - 前后端交互核心 : 
      - 请求 : (浏览器)  =>  服务器 
      - 响应 : (服务器)  =>  浏览器 

## AJAX
### 基础知识
- 基础知识:
  ```
        前端请求发起技术 : AJAX (前端->服务器)
        A : 异步 
        J : javascript
        A : 和 
        X : XML 

        前端的无刷新的请求发起工具 : 
        - 有刷新的请求是 : form 表单 ; 
        - 无刷新的请求是 : ajax 

        有刷新请求发送 : 
        缺点 : 
        1. 会让页面进行整体重新渲染 
        2. 前后端无法完整分离 即前端内部会有服务端的地址路径 

        无刷新请求发送 : 
        优点 : 
        1. 页面性能更好，可以实现局部数据更新; (渲染字符串)
        2. 进行交互的时候可以让代码的语义化更好;

        缺点 : 
        1. SEO 优化不好 ; (SEO是搜索引擎)
        2. 没有回退按钮 ; 

        AJAX 技术 : 
        - 在前端都是工具(api) , 我们根据需求配置工具就可以完成 前后端交互; 
          - 配置正确的请求方式; 
          - 接收响应数据，编写响应的数据处理代码 
        
        - AJAX : 
          - xhr   ( 原生 )
          - fetch ( 原生 )
          - axios ( 插件 )
          ... 
  ```
### xhr(XMLHttpRequest)
- 通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。
- ==接下来所有的操作都需要提前打开服务器,包括以后章节的操作==
  - **创建xhr请求三步走(最基础的)**
    1.创建请求实例对象(一个请求有一个实例对象) 
    `let xhr = new XMLHttpRequest();`
    2.配置请求信息 **open()**
    请求信息分为==请求方法==和==请求目标==
    > 请求方式 : GET* | POST* | PUT | PETACH | DELETE
    > 请求目标 = ==服务器路径== + ==业务路径==
    > 1.1 服务器路径(3部分组成): 1. 协议 (http://)  2.域名(localhost)   3.端口 (8888)
    > 1.2 接口路径: 请求某个具体的功能,具体查看==接口文档==
    > 1.3 接口文档来自后端编写,是与服务器对话的说明书

    3.发送请求 **send()**

  - **验证程序**
  - 请求发送结束之后我们需要获取到服务器给的响应: 我们是通过事件获取的,因为ajax请求是异步的! 所以我们使用回调函数的形式来处理响应数据; 
    > xhr.onload = function(){ console.log(xhr.responseText) }
    ==xhr.responseText可以获取你这个xhr对象从服务器到底获取了什么内容,注意 : 响应数据的类型一定是字符串类型==

- ==**本节课重点: 基础的三步走创建一个xhr对象以及如何验证是否成功获取了服务器的数据**==

- 代码:
  ```
    <button id="btn1">发送请求</button>
    <div class="container"></div>

    <script>
        // 注意 : 在进行学习之前要开启服务端环境 ; 
        // xhr : 简写 , XMLHttpRequest() 

        let btn1 = document.querySelector("#btn1");
        let container = document.querySelector(".container");
        function sendRequset(){
            // xhr 请求发送三步走 : 
            // 1. 创建请求实例对象(一个请求有一个实例对象)
            let xhr = new XMLHttpRequest();
            // 2. 配置请求信息 : 
            // - 请求方式 : GET* | POST* | PUT | PETACH | DELETE 
            // - 请求目标 :  
            //      服务器路径 : 1. 协议 (http://)2.域名(localhost) 3.端口 (8888)
            //      业务路径 : 请求某个具体的功能 ( 查看接口文档 ) /test/first 
            xhr.open( "GET" , "http://localhost:8888/test/first" );
            // 3. 发送请求 : 
            xhr.send();
            // 注意 : 我们在请求发送之后一定要会查看请求的发送情况( 浏览器的调试工具`network` );
            // 在控制台上的请求名称是请求目标最后一部分的名称; 

            // 请求发送结束之后我们需要获取到服务器给的响应 : 
            // - 我们是通过事件获取的;
            // - 因为ajax请求是异步的! 所以我们使用回调函数的形式来处理响应数据; 

            // xhr.onload 是请求对象的事件 , 这个事件会在请求得到了响应之后执行; 
            xhr.onload = function(){
                // 我们通过 xhr.responseText 属性获取响应数据; 
                // 注意 : 响应数据的类型一定是字符串类型; 
                // console.log(xhr.responseText);
                container.innerHTML = xhr.responseText;
            }
        }   

        btn1.addEventListener("click" , sendRequset )

    </script>
  ```
### xhr响应JSON数据
- ==**本节课重点: 我们从服务器获取的数据都是字符串形式,有的是纯字符串,但是这种情况较少,大都数是JSON字符串,通常是后端传递对象给前端,然后在传递中把对象转化为JSON字符串,前端获取后再用parse解析出来,这样我们就可以对这个从服务器传过来的对象进行操作了**==
- 代码:
  ```
    <button id="btn">发送请求</button>
    <!-- 向 /test/second 接口发送的请求  -->

    <div class="container"></div>
    <script>
        // 注意 : 在进行学习之前要开启服务端环境 ; 
        // 我们服务端返回的响应数据, 格式大多都是 JSON 格式 ; 
        // JSON 格式 : 
        // - 字符串类型 ; 
        // - JSON 是符合数组对象规则的字符串类型 , 响应数据的JSON格式通常是对象类型开头的; 

        let btn = document.querySelector("#btn");
        let container = document.querySelector(".container");
        function sendRequest(){
            // 1.创建请求对象
            let xhr = new XMLHttpRequest();
            // 2. 配置请求信息 
            xhr.open("GET" , "http://localhost:8888/test/second");
            // 3. 发送请求; 
            xhr.send();
            // 接收并处理响应数据; 
            xhr.onload = function(){
                // console.log( xhr.responseText );
                // 注意 : 我们在进行JSON格式数据使用的时候, 我们都会把JSON格式转换成对象 | 数组之后再使用 ; 
                let data = JSON.parse(  xhr.responseText ) 
                // console.log( data );

                container.innerHTML = `这是服务端返回给我们的信息 <strong>${ data.message }</strong> , 这是服务端给数据打的标签<strong> ${ data.tips }</strong> `
            }
        }
        btn.addEventListener("click" , sendRequest )

    </script>
  ```
### get请求携带数据
- ==**本节重点: get获取数据是可以传递参数的,而且大多数是要传递参数的,这些参数来自于前端用户填写的数据,只要将这些数据作为参数传入即可,本节学习的是get传参的规则,注意不要写错单词**==
- 代码:
  ```
    <button id="btn">发送请求</button>
    <p>姓名 : <input type="text" id="name"></p>
    <p>年龄 : <input type="text" id="age"></p>

    <script>
        // 注意 : 在进行学习之前要开启服务端环境 ; 

        // get 请求方式携带数据的请求 : 
        // 格式 : 数据放在路径上 用 ? 分隔数据和路径; 
        // 数据是data 路径是url 那么我们拼接的规则就是  : url?data 

        // data : 携带数据的格式是什么 ; 
        //   - 数据名 : 数据值 
        //     - 数据名是服务端规定的 , 服务端会以接口文档的形式把数据名告诉你! 
        //     - 数据值就是前端获取的数据; 
        //   - 多条数据之间使用&进行链接 : item1&item2 

        let btn  = document.querySelector("#btn");
        let name = document.querySelector("#name");
        let age  = document.querySelector("#age");

        function sendRequest(){
            let xhr = new XMLHttpRequest();
            // 配置请求信息 : 
            // 注意 : get 请求的数据是在路径上进行拼接的, 所以我们在编写的路径一定要拼接完整之后在传入参数, 我们应当在传入参数前判断当前的路径字符串是否正常; 
            let url = `http://localhost:8888/test/third?name=${ name.value }&age=${ age.value }`;
            xhr.open("GET" , url );
            xhr.send();
            // 响应处理 : 
            xhr.onload = function(){
                let data = JSON.parse( xhr.responseText );
                // console.log( data );
                // 响应信息处理 : 
                switch( data.code ){ // code详见接口文档中的说明
                    case 1 :     
                        alert("响应数据获取成功, 请求结束");
                        break;
                    case 5 : 
                        alert("抱歉请求失败, 请求存在错误");
                        break;
                }
            }
        }
        btn.addEventListener("click" ,sendRequest  )

    </script>
  ```
### post请求携带参数
- ==**本节课重点学习,post的带参数请求语法,post的参数放在send里面,而get直接和路径连在一起,在open里面,另外介绍了get和post获取数据的优劣对比,不过用哪个取决于后端的要求,还是按照接口文档来**==
- 代码:
  ```
  <button id="btn">发送请求</button>
    <p>姓名 : <input type="text" id="name"></p>
    <p>年龄 : <input type="text" id="age"></p>
    <script>
        // 注意 : 在进行学习之前要开启服务端环境 ; 
        // GET , POST 区别 : 
        // 1. 语义上的区别 : GET 的请求语义主要是获取内容的, POST的语义是发送信息的;(本节还是拿post来获取服务器信息的)
        // 2. 携带数据大小上的区别 : GET 携带数据不建议超过 4KB (非常小,不适合传输图片和文件), POST携带数据体积不受限制! 
        // 3. 安全性上的区别 : 
        //    - 对服务端 :  POST 请求有一定的风险; GET 数据风险较小; 
        //    - 对前端(了解) : GET携带的信息会暴露在地址栏里面, 可以通过历史记录查看, 所以存在数据暴露的风险 , POST 不存在; 
        
        // 我们究竟是用GET发送请求还是POST发送请求那 ? 
        // - 前端别选, 人家让你用啥你就用啥; 
        // - 注意两种请求方式的使用差异就可以了; 

        // POST携带数据注意事项 : 
        // 1. POST的数据是放在send参数之中进行传递的; 
        // 2. POST携带数据的格式 : key=value&key2=value2(和get的数据格式一样)
        // 3. 我们在发送POST请求的时候需要设置请求头信息( 告诉后端我们发送的数据格式是啥 );
        
        let btn  = document.querySelector("#btn");
        let name = document.querySelector("#name");
        let age  = document.querySelector("#age");

        function sendRequest(){
            let xhr = new XMLHttpRequest();
            xhr.open("POST" , "http://localhost:8888/test/fourth");
            // 注意 : 我们发送post请求的时候一定要明确数据格式,并且设置请求头, 去告知服务端我们的数据格式; 
            xhr.setRequestHeader("Content-Type" , "application/x-www-form-urlencoded");
            // post携带的数据需要放入到send之中 ; 
            xhr.send(`name=${ name.value }&age=${ age.value }`);
            xhr.onload = function(){
                let data = JSON.parse(xhr.responseText);
                console.log( data );
            }
        }
        btn.addEventListener("click" , sendRequest)

    </script>

  ```
### 前端调试工具的使用(用于纠错)
- ==**重点内容: 我们学的这块内容思路简单,但是代码往往出错,多半是单词等错误,所以我们可以反向根据网页的工具,来排查问题,是get post请求方式错了,还是请求地址错了,还是参数没传进去,可以根据调试工具的信息去一个个排查**==
- 代码:
  ```
    <button id="btn1">发送get请求</button>
    <button id="btn2">发送post请求</button>
    <p>姓名 : <input type="text" id="name"></p>
    <p>年龄 : <input type="text" id="age"></p>
    <script>
        let btn1  = document.querySelector("#btn1");
        let btn2  = document.querySelector("#btn2");
        let name = document.querySelector("#name");
        let age  = document.querySelector("#age");
        // 这部分内容往往难在排错,而非思路以及编写代码

        // GET 请求排错思路 : 
        // 1. 在网络栏中查看请求是否发送出去了; 
        // 2. 在网络栏中,点击此次请求记录查看详细数据,其中在标头(Headers)的常规栏(General)->检查请求路径和请求参数 ,还有请求方式; 
        // 3. 在payload(负载)之中检查传递的参数是否正确; 

        // get请求 : 
        function sendRequest1(){
            let xhr = new XMLHttpRequest();
            // 配置请求信息 : 
            // 注意 : get 请求的数据是在路径上进行拼接的, 所以我们在编写的路径一定要拼接完整之后在传入参数, 我们应当在传入参数前判断当前的路径字符串是否正常; 
            let url = `http://localhost:8888/test/third?name=${ name.value }&age=${ age.value }`;
            xhr.open("GET" , url );
            xhr.send();
            // 响应处理 : 
            xhr.onload = function(){
                let data = JSON.parse( xhr.responseText );
                console.log( data );
            }
        }
        btn1.addEventListener("click" ,sendRequest1) 

        // POST 请求排错思路 : 
        // 1. 查看请求是否发送出去了; 
        // 2. 在Header之中 检查请求路径和请求参数 ,还有请求方式; 
        // 3. 在payload之中检查传递的参数是否正确; 
        // 4. 查看请求头是不是设置了; 
        // 在Header选项卡下方的 requestHeader(请求标头) 之中查看我们设置的请求头("Content-Type" , "application/x-www-form-urlencoded")是否存在于这里! 

        // post请求 : 
        function sendRequest2(){
            let xhr = new XMLHttpRequest();
            xhr.open("POST" , "http://localhost:8888/test/fourth");
            // 注意 : 我们发送post请求的时候一定要明确数据格式,并且设置请求头, 去告知服务端我们的数据格式; 
            xhr.setRequestHeader("Content-Type" , "application/x-www-form-urlencoded");
            // post携带的数据需要放入到send之中 ; 
            xhr.send(`name=${ name.value }&age=${ age.value }`);
            xhr.onload = function(){
                let data = JSON.parse(xhr.responseText);
                console.log( data );
            }
        }
        btn2.addEventListener("click" ,sendRequest2) 

    </script>
  ```
### xhr封装
- ==**利用前面学习的基础知识,把对get和post(携带数据/不携带数据)的4中请求方式封装在函数中,并进行初步优化,合并同类项,是最简单最基础的封装,完全按照语法,加上一些简单的if逻辑辨别一下两者的区别**==
- 代码:
  ```
  <body>
      <button id="btn1">发送get请求</button>
      <button id="btn2">发送get请求并携带参数</button>
      <button id="btn3">发送post请求</button>
      <button id="btn4">发送post请求并携带参数</button>
      <div class="container"></div>
      <script>
        // xhr封装省略了三步走创建和检验的繁琐步骤
        let btn1 = document.querySelector("#btn1")
        btn1.addEventListener("click", function () {
            // 发送get请求
            xhr("GET", "http://localhost:8888/test/first", function (data) {
                // 此次响应数据获取之后如何操作
                console.log(data)
            })
        })

       
        let btn2 = document.querySelector("#btn2")
        let container = document.querySelector(".container")
        btn2.addEventListener("click", function () {
            // - 只实现前两个功能
            // 发送get请求并携带参数 + 把响应数据放在页面的container容器中
            // 和初始的xhr封装的代码冲突: 请求地址不同(业务地址) , 相响应的处理方法不同(container容器) , 新增的需求传递参数
            // xhr("http://localhost:8888/test/second",function(data){
            //     // 初始是JSON数据
            //     // console.log(data);
            //     // 转化为对象再使用
            //     let dataObj = JSON.parse(data)
            //     console.log(dataObj);
            //     // 实现功能: 把数据放入到container中
            //     container.innerHTML = dataObj.message
            // })

            // - 第三个功能都实现  + 处理传递参数 --> 为了代码可读行更好,把传入参数的部分提取出来,以对象的形式传入
            xhr("GET", "http://localhost:8888/test/third", function (data) {
                let dataObj = JSON.parse(data)
                console.log(dataObj);
                container.innerHTML = `name:${dataObj.info.name} age:${dataObj.info.age}`
            }, { name: "donk666", age: 17 })
        })


        // post不携带参数的请求,这个一定是报错.接口文档中fourth就是要求要有携带数据,所以这个就是测试测试
        let btn3 = document.querySelector("#btn3")
        btn3.addEventListener("click", function () {
            xhr("POST", "http://localhost:8888/test/fourth", function (data) {
                console.log(data);
            })
        })

        // 发送post请求并携带参数
        // 冲突:
        // 1.get和post的携带参数位置不同,格式相同,get在url上,post在send里
        // 2.get不需要请求头,post需要请求头


        let btn4 = document.querySelector("#btn4")
        btn4.addEventListener("click", function () {
            xhr("POST", "http://localhost:8888/test/fourth", function (data) {
                console.log(data);
            },{ name: "m0nesy", age: 18 })
        })


         // 封装的原则: 公用一套代码,哪里数据修改,哪里提取为参数,调用时把参数传入进去
         function xhr(type, url, callback, data) {
            // -- type是请求方式
            // -- url是业务地址
            // -- callback是一个回调函数,请求数据获取之后执行这个函数(在onload里面),处理不同的数据处理需求
            // -- data是携带的参数,是以对象的形式传入的


            //  为了符合get语法,我们要把传入的对象参数进行格式化
            //  { name : "donk666" , age : 17} ==> ?name="donk666"&age=17
            //  如何格式化? (前提:不一定所有的请求都是携带参数的,首先判断data是否存在,就是是否传递了data参数)

            // 我们把url拼接的位置是需要知道请求的方式的,get和post携带数据时存储数据的位置不同 !!! 
            // 不过二者的格式相同,所以把正确的参数格式表达出来后,只需要判断get和post来进行位置的拼接即可
            let url_data = ""
            if (data) { // data存在再格式化.data为空则不是携带参数的get请求
                for (attr in data) { // attr = key ; data[attr] = 对应的value
                    // 拼接数据通过 "&" 分割
                    url_data += "&" + attr + "=" + data[attr]
                }
                // 这种拼接方法会让开头多出一个&,所以通过slice截取掉这个&
                url_data = url_data.slice(1) // 截取下标1到末尾的所有
                console.log(url_data); // 格式正确!
            }

            if (type === "GET" || type === "get") { // get的参数拼接
                url += "?" + url_data
            }

            // 1.请求发送
            let xhr = new XMLHttpRequest()
            // -- 业务请求地址不同 url
            xhr.open(type, url)
            if(type.toUpperCase() === "POST" && url_data){ // 请求类型是POST并且存在url_data
                xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded")
                xhr.send( url_data ); 
            }else{ // 不需要携带数据的POST(url_data为空)或者type === "GET"的情况下直接调用send()
                xhr.send()
            }

            // 2.响应处理
            xhr.onload = function () {
                // -- 响应处理不同
                // 冲突部分如果是代码,我们让代码部分传入一个函数,这个函数根据不同需求自己去编写不同的代码去实现这些功能,我们把获取的数据传入函数即可
                callback(xhr.responseText);
            }
        }


    </script>
  </body>

  ```

### xhr封装优化
- ==**xhr的高级优化: 运用了很多前面的知识: 1.多个参数传参太繁琐了 -> 对象传参, 并在其中添加了默认参数 + ES6的 ...展开运算符和解构赋值(之前就用过) 2.在传入参数的对象中添加新属性dataType,判断后端返回的是json还是纯字符串,对于json再特定地转成对象 3.promise的复习应用,在异步函数onload中要使用回调函数callback,这个callback还要从外面作为参数传递进来,很繁琐,直接将整个异步程序包装金pro对象返回出去,pro对象的状态根据onload的异步执行情况来改变,这样外部接受pro状态的变化来确定xhr是否成功,然后利用then或者async/await来执行callback函数,这样可以直接在后面衔接callback函数,而不用作为参数写进去了**==
- 代码: (**重点看btn2的最终简洁效果**)
  ```
    <body>
      <button id="btn1">发送请求</button>
      <button id="btn2">发送请求-promise语法</button>
      <button id="btn3">发送请求-promise + async/await语法</button>
    <script>
        let btn1 = document.querySelector("#btn1")
        btn1.addEventListener("click", function () {
            creatXhr({
                url: "http://localhost:8888/test/second",
                // second dataType默认是json,不用写了
                callback: function (res) {
                    console.log(res);
                }
            })
        })

        // 简洁明了的写法
        let btn2 = document.querySelector("#btn2")
        btn2.addEventListener("click", function () {
            // 1.请求配置内容放入对象
            let options = { url: "http://localhost:8888/test/second" }
            // 2.监听请求状态,如果xhr请求成功了,执行响应数据的函数callback
            creatXhr(options).then(handlerResponse) // handlerResponse是相应处理函数
        })

        function handlerResponse(data) { // 比起callback回调函数,还要传入函数,更简洁
            console.log(data);
        }

        let btn3 = document.querySelector("#btn3")
        // 使用await前定义async函数 !!!
        btn3.addEventListener("click",async function () {
            // 1.请求配置内容放入对象
            let options = { url: "http://localhost:8888/test/second" }
            // 2.监听请求状态,如果xhr请求成功了,执行响应数据的函数callback
            let data = await creatXhr(options) // 等待xhr返回的pro状态改变时在执行data赋值
            console.log(data); //  data就是 resolve(xhr.responseText)里的参数xhr.responseText
            // callback函数可以在这里调用,来处理data,实现复杂的需求
            handlerResponse2(data)
        })
        
        function handlerResponse2 (data){
            console.log("复杂的data处理函数");
            console.log(data.message);
        }

        // 封装的原则: 公用一套代码,哪里数据修改,哪里提取为参数,调用时把参数传入进去

        // 封装优化:
        // 1.参数优化: 把参数设置成对象,设置默认参数
        // 2.格式优化: 我们希望响应数据是json格式的数据传入到回调函数中的数据是对象类型 xhr.onload = ...
        //   - 是json类型的数据我们直接转换成对象; 
        //   - 不是json类型的数据我们直接返回字符串; 
        //   - 我们可以指定响应数据的类型 text/json
        // 3.使用的xhr的异步处理都是回调函数callback处理,比较繁琐,改为promise处理
        //   - 使用promise进行封装异步函数onload
        //   - 通过返回promise对象的状态进行监听来确定是否成功发送数据
        //   - 再根据其状态结合then或async,await去把数据提取出来,添加函数去处理

        // Promise封装
        // 1. 核心: 函数的返回值不是数据,而是pro对象
        //  - 返回pro对象,最简单的方式为 return new promise { 把封装中的函数放入参数之中 }
        //  - 精准封装,把异步程序放在Promise中,其他放在外面
        //  注意return后面不要有代码,否则执行不了
        // 2. 调用函数后,关注pro状态的改变,执行pro事件处理函数

        function creatXhr(options) {
            // -- type是请求方式
            // -- url是业务地址
            // -- callback是一个回调函数,请求数据获取之后执行这个函数(在onload里面),处理不同的数据处理需求
            // -- data是携带的参数,是以对象的形式传入的

            let { type, url, callback, data, dataType } = {
                // 默认参数
                type: "GET",
                callback: function () { },
                data: null,
                // 格式化数据参数,决定如何处理响应数据
                dataType: "json",
                // 合并传入的options
                ...options
            }
            let url_data = ""
            if (data) { // data存在再格式化.data为空则不是携带参数的get请求
                for (attr in data) { // attr = key ; data[attr] = 对应的value
                    // 拼接数据通过 "&" 分割
                    url_data += "&" + attr + "=" + data[attr]
                }
                // 这种拼接方法会让开头多出一个&,所以通过slice截取掉这个&
                url_data = url_data.slice(1) // 截取下标1到末尾的所有
                console.log(url_data); // 格式正确!
            }

            if (type === "GET" || type === "get") { // get的参数拼接
                url += "?" + url_data
            }

            // 1.请求发送
            let xhr = new XMLHttpRequest()
            // -- 业务请求地址不同 url
            xhr.open(type, url)
            if (type.toUpperCase() === "POST" && url_data) { // 请求类型是POST并且存在url_data
                xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded")
                xhr.send(url_data);
            } else { // 不需要携带数据的POST(url_data为空)或者type === "GET"的情况下直接调用send()
                xhr.send()
            }


            return new Promise((resolve, reject) => {
                // 2.响应处理
                xhr.onload = function () { // 单独对异步代码封装(事件处理函数)
                    // -- 响应处理不同
                    // 冲突部分如果是代码,我们让代码部分传入一个函数,这个函数根据不同需求自己去编写不同的代码去实现这些功能,我们把获取的数据传入函数即可
                    switch (dataType) {
                        case "text":
                            callback(xhr.responseText);
                            resolve(xhr.responseText);
                            break;
                        case "json":
                            // 如果对象的格式错误,用try-catch返回一个普通字符串
                            try { // 成功
                                callback(JSON.parse(xhr.responseText))
                                resolve(JSON.parse(xhr.responseText))
                            } catch (e) { // 失败,就不转换为对象了,怎么来的怎么传进去
                                callback(xhr.responseText)
                                resolve(xhr.responseText);
                            }
                            break;
                    }
                }
            })

        }


    </script>
    </body>
  ```
### fetch工具

- fetch工具: 新生代网络请求工具,对标xhr
- ==**fetch工具的特点:**==
  - 返回值是promise对象,返回值pro对象的状态对标响应数据的状态,也就是说网络请求成功,pro对象的状态就会成功
  -  返回的pro对象的响应数据需要转化,可以转化为json字符串格式(这种响应数据一般为对象格式,方便后续对响应数据内部存储的对象进行操作),也可以转化为纯字符串格式(这种响应数据一般为纯文本),语法格式为.json() / .text()
- ==fetch语法:==
  - 1.默认是get请求,所以先看默认状态下的语法
    - fetch(url,options) url就是网络请求地址,options配置参数
  > 由于网络上关于fetch请求携带参数的语法均是有关于post请求方式,所以默认的get请求方式目前并未找到正确携带参数的语法格式
  - POST请求的情况
    - 严格按照格式配置options对象,格式 key : value (记得逗号隔开)   
    - 目前学习的参数有 (所有参数均在options对象内部)
      - method(请求方式 POST GET ...)
      - headers: { "Content-Type": "application/x-www-form-urlencoded" // ==必写:请求头==
      //  'Content-Type': "application/json" (截取网站fetch API)    }
      - body: JSON.stringify(data) ==// body就是携带的参数,要求类型与Content-Type的类型一致==(stringify就是把对象转为字符串)
      - ==另外的写法还是和get一致"name=kerwin&age=100"这种"key1=value1&key2=value2&...格式"==
- ==最后fetch请求方式有两种写法 then方式和async/await方式 **(后者更简单,详细见下面代码btn1和2的区别)**==
- 代码:
  ```
    <button id="btn">发起fetch请求</button>
    <button id="btn2">发起fetch请求 + async/await</button>
    <button id="btn3">发起fetch发送post请求</button>
    <script>
        // fetch 网络请求发起工具(新生代工具)
        //  - fetch相较于xhr更方便;
        
        // fetch请求返回值是Promise对象
        //  - 想要得到数据需要经过两次处理
        //    - 1.返回值pro对象关注的是响应状态(响应状态成功了,pro对象状态也会成功)
        //        - 此时的pro数据是未解析的
        //    - 2.我们在未解析的数据上调用数据处理工具(text() , json())
        //        - 在数据处理结束后才能够获取响应数据 

        let btn = document.querySelector("#btn")
        btn.addEventListener("click",function(){
            // fetch(url , options)
            // url 发起请求的路径
            // options 对象形式的配置参数(默认get请求)
            fetch("http://localhost:8888/test/second")
            .then(response=>{
                // 解释: fetch返回的是pro对象,如果请求发送成功,那么pro状态随之会变为成功,那么用then去接受成功状态下的pro返回内容 (response接受它)
                // 此时返回的响应数据是未解析的
                // response.json()返回值也是一个pro对象,这个工具把当前响应数据类型转化为json类型
                // 同理response.text()就是转化为字符串类型
                return response.json()
            })
            .then(data => { // then 的连缀写法
                console.log(data); // data就是经过两次处理之后的数据
            })
        })

        // 主流写法,简单方便
        let btn2 = document.querySelector("#btn2")
        btn2.addEventListener("click",async function(){
            // 1.请求配置
            let response = await fetch("http://localhost:8888/test/second")
            // 2.调用响应配置
            let data = await response.json()
            console.log(data);
        })

        // 发送post请求比较麻烦
        // 1. fetch没有send,请求的数据放到配置参数的body属性之中
        // 2. 设置请求头,setRequestHeader()也没有,在fetch中我们使用header属性中进行设置

        // 查阅文档去理解操作语法
        let btn3 = document.querySelector("#btn3")
        btn3.addEventListener("click",async () => {
            let options = { // fetch配置项对象的设置
                // 请求方式是post
                method : "POST",
                headers : {
                    // key : 请求头名称
                    // value : 请求头值
                    "Content-Type" : "application/x-www-form-urlencoded"
                },
                // 携带数据
                body : "name=hello&age=18"
            }
            let response = await fetch("http://localhost:8888/test/fourth",options)
            let data = await response.json()
            console.log(data);
        })
  ```
### axios插件
- axios是十分先进的网络请求工具,前端和nodejs公用,适合大型项目==**记得事先获取axios工具**==.
- ==如何获取axios?== axios可以通过本地文件下载/网络地址直接请求/复制axios代码到本地,共三种方式,推荐第三种,现在使用的是淘宝2024最新地址下载
- ==axios语法==
  - 参数 (url,options) 地址 + 参数
  - 返回值也为promise对象,高级的网络请求工具都返回pro对象,网络请求不成功,pro对象状态就为失败,代码就不会再执行,==但是和fetch不同的是,axios返回的对象不需要二次转化,固定的把响应数据存储在返回的pro对象的data属性内,通过pro对象名.data即可获取.==
- axios ==默认get请求== 语法如下:
  - 如果不写带参数直接请求url即可 (GET)
  - 如果是GET携带参数,需要先对options配置内部参数内容,固定配置参数为 ==params : { key1 : value1 , key2 : value2 , ...}== , 将其放入options对象内部再进行网络请求
  - ==如果是POST请求==,和fetch一样,对options内部进行配置,当然不再需要params了
    - method -> post ...
    - header -> {Content-Type : "...."}
    - data ==(不是body了)== -> { key1 : value1 , key2 : value2 , ...}
- 获取数据通过解构赋值直接获取(简单),例如:  let { data } = await axios(".......", options)
- 代码: 
  ```
    <body>
    <button id="btn">GET发送请求 axios</button>
    <button id="btn2">GET发送请求 axios携带数据</button>
    <button id="btn3">POST发送请求 axios携带数据</button>
    <!-- npm下载在本地文件中 -->
    <script src="./node_modules/axios/dist/axios.js"></script>
    <!-- 直接网络请求 -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script> -->
    <!-- 把js代码复制到本地用 -->
    <!-- <script src="./axios.min.js"></script> -->
    <script>
        // axios : 网络请求发起工具,泛用性非常强,同时支持前端和nodejs使用
        // 缺点 : 代码比较繁琐复杂,适合大项目,简单的请求测试没有必要

        // axios基本应用
        // - 参数: (url,options) || (options) 
        // 请求方式默认get
        // 返回值默认promise对象(高级的网络请求工具的返回值都是promise对象)
        //  - pro对象成功之后的数据是一个对象,对象中的data属性(固定)里面存放着响应数据,需要通过对象->data属性->获取响应数据

        // 1. 发送不携带数据的请求(默认get)
        let btn = document.querySelector("#btn")
        btn.addEventListener("click", function () {
            // 发送基础的get请求
            axios("http://localhost:8888/test/second")
                .then(res => {
                    console.log(res); // 一个对象,里面有许多信息
                    console.log(res.data); // 获取相应数据
                })
        })

        // 2. 携带数据发送get请求
        let btn2 = document.querySelector("#btn2")
        btn2.addEventListener("click", async function () {
            // 请求配置对象
            // 如果想要携带数据get请求,我们需要传递 params 参数, 这个参数的数据要求类型为对象, 这个对象数据会被格式化之后放入到url之中; 
            let options = {
                params: {
                    name: "hello",
                    age: 18
                }
            }
            // 解构赋值直接获取属性data内容,注意data是固定的,不要更改 !!!
            let { data } = await axios("http://localhost:8888/test/third", options)
            console.log(data);
        })

        // 3. 携带数据发送post请求

        // 1. 请求类型如何改变为POST -> method
        // 2. 如何配置请求头 headers
        // 3. 如何配置请求体body -> data
        let btn3 = document.querySelector("#btn3")
        btn3.addEventListener("click", async function () {
            // POST请求
            let options = {
                // 请求类型
                method: "POST",
                // 自定义请求头,不携带数据data不生效
                headers: { "Content-Type": "application/x-www-form-urlencoded" },
                // data是作为请求体被发送的数据
                data: {
                    name : "hello",
                    age : 100
                }
            }
            // 解构赋值直接获取属性data内容,注意data是固定的,不要更改 !!!
            let { data } = await axios("http://localhost:8888/test/fourth", options)
            console.log(data);
        })


    </script>
    </body>
  ```
- axios安装:
  ```
    // axios : 
    // 查找axios插件 :  
    //   - nodejs 下载 axios插件;   指令 : npm i axios

    // 可以通过 CDN 引入axios : 
    // 引入 axios 插件 : 可以获取到axios的使用环境; 
    // - 通过路径 : ./node_modules/axios/dist/axios.js
    // - 通过线上地址引入 axios 代码 : 
    //   - https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js
    // - 通过本地路径引入 axios 代码 : (通过网络请求找到axios代码,复制下来存入本地自己创建的js文件中 -> axios.min.js)
    //   - src="./axios.min.js"
  ```
## 商品页面交互练习
### 商品页面---商品列表

### 商品页面---商品详细数据

## 用户页面交互练习
### 介绍
> 首先,用户的学习板块分为引入和综合,03和04的结合实现了最基础的功能,用户的登录和注册结合,最简单的
> 05用户登录-用户中心版 在内部可以发现和许多页面的结合, 每一次都是当前阶段的功能,
> 最后也就是现阶段的完善代码,完整的完成了需求,即用户登录->用户注册(如果没有登录账号)->登录成功进入新的用户中心->用户中心有修改密码和修改信息和退出登录三个功能

## 网络基础相关
### http
- 网络安全协议: 复制了源码md文件,具体东西讲的不多,了解即可
- 已经复制给目录了

### cookie
#### cookie的基础知识
- ==cookie是被前端淘汰的技术,现在的localstorage可以代替它,我们学习的目的就是简单了解并应用简单的cookie操作==
- 了解基本的如何设置cookie等知识

#### cookie封装
- ==重点在处理数组的部分,使用分割和过滤,一维数组->二维数组拆分数据的方法思路很值得学习,其余的看看即可,cookie不重要==

### json跨域

#### 跨域
 - 跨域:==向其他服务器发起网络请求== 
    - 同源策略: 这个策略主要目标是不让我们向别的服务器发起请求
    - 界定服务器是不是自己的如下:
         - 请求的 ==协议/域名/端口== 三个内容与请求源是否相同
         - ==如果三者有一者不同,就会触发跨域错误==
- 常见源 : 
        1.==本地文件==: file://D:/ 没有端口和域名
        2.==服务器==: http://127.0.0.1:5500/ 协议->http 域名->127.0.0.1 端口->5500 (live server 在自己电脑上建立的服务器)
- 典型跨域错代码:
  ```
  // 跨域错误:
        let btn = document.querySelector("#btn")
        btn.addEventListener("click",function (){
            // 向百度发一个网络请求
            fetch("https://www.baidu.com")
        })
  ```
- ==报错信息(file 与 http 都会有)==
    - Access to fetch at 'https://www.baidu.com/' from origin 'http://127.0.0.1:5500' has been blocked by CORS policy ==请求被CORS阻止==
    - No 'Access-Control-Allow-Origin' header ==没有上面的请求头==
- 解决: 
    > ==注意: 如果服务端不想给跨域请求数据,我们前端是解决不了跨域问题的!!!!==
    - 学习目标: 在服务端给跨域请求数据的前提下,我们服务端配合完成跨域请求(后续几节内容)
         1. jsonp跨域(前+后)
         2. cors跨域(后)
         3. 服务器代理跨域(proxy) (代理服务器)

#### jsonp跨域
- jsonp请求: ==不同于ajax请求,定义了一个带有src属性的script标签,那么浏览器会根据src属性来发起请求,**这是前端单方面的跨域请求,算是一种请求数据的方式,但是限制极大**==
  > 注意:
  > 1.我们发起请求后收到的响应数据都会被当成js来执行,响应数据必须符合js代码规则,否则报错,之前我们ajax请求得到的响应数据,比如说对象啥的,是直接可以提取出来使用的,但是这里是不可以的 
  > 2.我们发起的请求只能为get
  > (更好的保护浏览器不受危害,所以留了个这样的设定,请求数据和响应数据均受到巨大限制的请求,而且只能请求数据,不能传入数据,没有危害性)  
  - 测试:
  ```
    <!-- 在网络栏中,看请求数据,不在xhr/http栏,在js栏中 -->
    <script src="https://www.baidu.com"></script> 
  ```
- 如何发送一个jsonp请求:
  - 我们把原本的ajax请求替换为script标签的src请求
  - 我们发送jsonp请求一定结合接口文档发送
  - jsonp请求就是把参数拼接到url上(get请求),在通过script发起请求
    `https://www.baidu.com/sugrec?prod=pc&form=pc_web&wd=你好&cb=callback`
  - ==特殊地,我们如果发起jsonp跨域请求,我们必须在前端准备一个函数,这个函数是全局函数,**因为请求得到响应数据时,是以函数调用的形式进行数据传递的! 响应数据作为函数形参,调用函数来实现响应函数的传递**==
  - 如下,cb作为请求参数,规定了回调函数callback接受响应数据
    ```
      <script src="https://www.baidu.com/sugrec?prod=pc&form=pc_web&wd=你好&cb=callback"></script>
      <script>
          function callback(res) {
              console.log(res)
          }
      </script>
    ```
  > 这种请求是自动的,不受事件触发驱使的,不受控制的自发的
  > 发起一个script + src 请求 , ==打开页面就会自动发起请求 , 会导致一个问题, 一旦发起请求就会有响应数据,**所以请求应当放在全局回调函数之后(js的单线程运行,请求回来数据时如果全局函数还没挂载就承接不了响应数据)**==
#### jsonp跨域事件驱动
- ==事件驱动: 还是动态添加dom节点, **创建-配置-插入-执行(绑定事件)**==
  ```
    <button id="btn">发起jsonp请求</button>
    <script>
        // 事件驱动
        //  - dom创建script标签
        //  - 给script标签新增src属性
        //  - 把script标签放入页面

        // 事件驱动好处: 就是可以灵活改变src内部的内容

        let btn = document.getElementById("btn")
        function sendJsonpRequest(){
            // - 创建script标签
            let script = document.createElement("script")
            // 添加src属性
            script.src = "https://www.baidu.com/sugrec?prod=pc&form=pc_web&wd=你好&cb=callback"   
            // 把script标签放入页面
            document.body.appendChild(script)  
            // 注意这样会使script标签冗余
            // 解决: 插入script标签后,立即删除,因为script的标签放入到页面之后,请求就发出去了
            script.remove()      
        }
        // 准备全局函数,接受回调函数
        function callback (data){
            console.log(data);
        }

        // 每次点击都能得到一次响应数据
        btn.addEventListener("click",sendJsonpRequest)
        
    </script>
  ```
#### jsonp实战之百度模糊搜索案例
## CORS跨域(重要)
- CORS，全称为“跨域资源共享”（Cross-Origin Resource Sharing），是一种机制，它使用额外的 HTTP 头来告诉浏览器允许一个网页从另一个域（不同于该网页所在的域）请求资源。这样可以在服务器和客户端之间进行安全的跨域通信。
- 跨域请求是指从一个域向另一个域发起的HTTP请求。
- 对于简单请求，浏览器会直接发送请求并在响应中检查以下 CORS 头部：
- ==Access-Control-Allow-Origin：指示允许访问资源的源。==
- ==**CORS是纯后端设置的,和前端没关系**,添加关键请求头,多提一嘴,在真正写服务端口时,*是不安全的==
- 在服务端(cors-server.js)添加上 res.setHeader("Access-Control-Allow-Origin" , "*");
- 使用cors接口时,服务端必须是我们自己写的,别人的服务端可不会给你配置cors,==如果服务器启用了cors,我们可以使用所有ajax技术,轻松实现跨域,这个服务器允许你跨域访问它,轻松获取响应数据使用==
- 卖座网站的这个网络响应说明,他是允许跨域的,在后端设置好了CORS,只不过要传递一些特殊参数放入请求体body,后端接受检查后,才允许你请求数据
  [![pA5wDpR.png](https://s21.ax1x.com/2024/11/29/pA5wDpR.png)](https://imgse.com/i/pA5wDpR)

## nodejs cmd 操作指南
### node cmd 基本使用
****
**==提醒==: 本章节所有的代码均在js内部,执行要在cmd中,打开文件所在资源管理器中的位置后,对搜索框输入 cmd回车打开进行执行**

- 简单的指令 : node + 空格 + 文件名字 --> 执行js文件
- cls 清屏
- 按向上键 ^ 返回上一次的指令,可以多次按,上下键灵活选择
- ctrl + c + c 强制结束程序,用于服务器关闭
- exit : 关闭cmd
- ==nodemon(安装了nodejs热启动插件)== : 后期可以实时运行nodejs代码,不必重复开启关闭, 语法为 nodemon + 空格 + 文件名
  .......
****
### 第三方模块
> 下载器工具npm就是负责把第三方包下载到本地的工具, 只不过这个工具需要使用指令进行驱动 , cmd
> ==之前我们下载swiper和axios都是这样,打开相应的文件路径后,输入cmd回车,打开控制台,输入下载指令==

- 基本指令:
  - ==通过nodejs下载卸载即npm (node的npm就和python内的pip一样,就是下载工具)==
  - 有个网站==npmjs.com,有许多的第三方插件,缺点全英文看不懂==
  - 下载 : `npm install 第三方包的名称` : ==install 可以简写为 i==
  - 卸载 : `npm uninstall 第三方包的名称` 
- 安装样例:
  - ==安装指令非常简单 : `npm i axios`==
  - 安装下来的插件放在 node_modules 文件夹之中 
- 安装的部分文件解释
  - package.json 
    - 项目依赖说明书 , 当前的项目用到了哪些第三方模块, 在package.json之中注明; 
    - package.json可以描述的信息非常多 , 测试指令, 核心文件 , 项目描述...(自己添加)
  - package-lock.json 
    - 这是一个详细的版本记录 , 为了防止版本使用出现差异,所以nodejs默认创建了这么一个文件, 这个文件我们不需要进行任何操作; 
- nodejs 软件和常规的软件有啥区别 : 
  - 需要cmd进行指令下载,而非常规的应用商店或exe等
- nodejs的使用
  - 创建同目录的js文件,使用下载插件(例如axios)的内部工具,==记得先引入==
### 全局模块和局部模块
- 局部模块: 把插件下载到一个特定的文件内部,之前的axios和swiper我们都是这么下载的
- 如何下载全局模块:
  - 下载之后，会在cmd命令行上多出一个指令 
  - ==下载的时候我们需要在下载指令后面添加 `-g`参数才可以实现全局的包的下载==; 
- 全局模块下载插件nodemon
  - ==安装指令可以在任意路径下执行==
  - 注意 : 我们安装全局模块，不会在当前文件夹之中出现 `node_modules` 文件夹及 `package.json` , `package.lock.json` ,安装进入了nodejs的文件根目录了
  - 测试nodemon安装成功的方式是在命令行上输入指令 `nodemon --version` 正常返回版本号,那么则表示 nodemon 指令可以使用了, 也就是说我们的全局的包安装成功; 
- nodemon 作用
  -  就是改完代码就会实时启动nodejs,不用和之前一样重启服务器, 打开方式 `nodemon + 空格 + 文件名`
   
## nodejs内置模块
### fs
- 主要功能: ==读取==文件内容和==修改==内容,分为==异步与同步==,需要**提前获取**
- 1.**获取**: `let fs = require("fs")`
- 2.**读取**: ==异步== fs.readFile(路径,编码格式,回调函数)
        ==同步== fs.readFileSync(路径,编码格式)
  - **路径**:目标文件相对本文件的路径,也可以是目标文件的绝对路径
  - **编码格式**: "uft8" , ==**注意带有图片的html文件读取不能使用utf8格式读取,会报错,不要写格式空着就行**==
  - ==回调函数(只要读取文件就会被调用,内部是读取后处理的代码)==: 回调函数的2个参数 (err,data) err: 报错信息 ; data: 成功后获取的文件内容
- 3.**修改**: ==异步== fs.writeFile(路径,写入内容,回调函数)
             ==同步== fs.writeFileSync(路径,写入内容)
  > 注意 : 第一 : 有文件就修改,没有就创建一个并且写入
  > 第二 : 回调函数的参数只有一个了,err,如果修改失败,err就是报错信息
  > 第三 : 没有编码格式了 ; 变为"写入内容" , 其余与读取一样

### path
- 主要功能:  ==path主要是用来拼接字符串路径,可以很好的拼接路径,并不会被./影响,只要两个url之间有合理顺序的层级关系,就能拼在一起==
- ==语法==: `path.resolve( url1, url2 , ... urln )`
- ==简便写法==: `let {resolve} = path + resolve(url....)`,解构出path的主要用法,以后使用直接resolve(),而不用path.resolve()
- ==**常量 __dirname**:== 代表当前文件的绝对路径,后期根据当前文件的路径找到根目录路径,用于拼接
> 真正理解这个path的作用要去server训练中,看看如何使用path + __dirname拼接出我们想要的页面路径的index.html 和 404.html(一般都设计根目录root)
### http
- http : ==可以开启一个自己的服务器,服务器的内部逻辑由自己编写==
- 开启一个服务器需要以下几个步骤
  - 引入http: `let http = require("http")`
  - 开启服务器(==创建一个服务器对象,同时定义好一个请求处理函数==): `let server = createServer((req,res) => {...})`
  - 监听端口: `server.listen(3000,() => {console.log(server.address().port)})`
  - 向服务器发请求: 在浏览器按照地址打开服务器
    > ==注意: 如果修改代码需要重启cmd和浏览器的服务器==

- 1.开启服务器
    > 1.语法: http.createServer(请求处理函数)
    > 请求处理函数: 服务器接收到请求,这个函数就会被调用
    > 返回值: ==服务器对象==,这个对象用来决定监听的端口号
    > 2.回调函数的参数:
    > req: 请求携带数据(请求报文解析的内容)
    > res: 响应处理工具,我们可以使用这个对象之中的工具,进行响应报文配置
    > 3.res的一些方法:
    > res.write() 向响应体中写入内容
    > res.end() 终止http请求,==**不写请求就不会终止,也就不会有响应数据**==
- 2.监听端口
  ```
    什么是端口? 计算机有65535个端口号,我们规定一个端口号作为访问我们当前服务器的路径(就比如之前的8888服务器)
    4位数的端口比较安全,其他的可能会导致开启服务器失败,比如两个服务器共用一个端口这种情况,碰到了换一个号

    默认端口号: 如果你的协议如下...,并且使用如下端口号,那么可以省略这个端口号
    http: 80 , https : 443 比如: 百度等网站
    但是自己的服务器在自己的电脑上,不能这么随意部署端口号,在大公司中,端口号是纯后端的工作
  ```
    > 服务器监听端口 server.listen(端口号,回调函数)
    > 获取端口的值 server.address().port
    > 监听时调用回调函数,回调函数内可以打印端口号来确定是否开启成功

    > 注意: 我们的服务器程序开启成功之后, cmd命令行会被占用, 因为服务器是一个监听行为; 他会一直等待请求,这样我们的命令行就会被挤占卡住
    > 如果想要关闭程序需要使用 ctrl + c + c 指令退出cmd监听; 重启cmd的命令行 
- 3.向服务器发起请求(本节课发起请求的方式十分的狭隘)
  - 在浏览器里面输入文件的服务器路径
    服务器路径: 
    我们需要在路径前添加服务器传输协议(这里就是http)
    域名: 因为我们使用本机访问本机,我们可以使用环回ip 127.0.0.1 , 或localhost
    端口: 3000
    总结: http://localhost/8888/ + 文件地址 或者 http://127.0.0.1:/8888/ + 文件地址
### server(总结练习)
- **总结nodejs的内置模块fs,path和http,结合三者做一个小demo**
- ==小型本地服务器,初步了解浏览器与服务器的交互==
- http创建的服务器也称为'页面服务器',==页面服务器和live server 插件类似,通过创建这个服务器,我们可以了解live server的工作原理==
- 1.==**首先构建基本文件结构**==,创建文件夹04_2server,内部文件夹root(==静态资源文件夹==)和==服务器逻辑代码js文件==(04_2server.js)
- 2.==**服务器的启动与访问**==
  - ==nodemon(热更新)启动服务器==--省事,代码改了服务器同步更新,不必改一次代码就重启一次服务器; node是后端,在当前文件夹内打开终端,输入`nodemon 文件名`
  - ==请求由本地浏览器地址发送,刷新一次页面就等于重新发送了一次请求,直接在浏览器地址栏输入localhost:3000即可访问到本地创建的http服务器==; 本地服务器域名固定为 localhost/127.0.0.1; 端口号是在创建服务器时自己定义的
- ==**3.构建服务器的js代码(04_2server.js)**==
- ==3.1搭建服务器: nodejs内置的http模块==
  ```
    1.引入http
    let http = require("http")

    2.创建http服务器
    let server = http.createServer((req, res) => {
      // 服务器逻辑代码
    })

    3.监听端口号3000
    server.listen(3000, () => {
        console.log(`服务器开启,端口号${server.address().port}`)
    })
  ```
- ==3.2createServer的服务器逻辑代码==
- 默认参数req: 请求体 包含了很多的请求信息,可以打印,在浏览器请求一次后,可以在终端看到req的信息,非常多!
- ==比较重要的信息,比如请求的路径信息url和请求方式method==
  - ==url小知识: 浏览器发起请求时会默认发送2个请求,你自己输入的地址和/favicon.ico==
  - 这个/favicon.ico是浏览器图标,如果你不打算配置这个图标,可以禁止这个网络请求
  [![pA5OWyn.md.png](https://s21.ax1x.com/2024/11/30/pA5OWyn.md.png)](https://imgse.com/i/pA5OWyn)
  ```
    if(req.url === '/favicon.ico'){
        return res.end()
    }else{
        console.log(req.url)
    }
    console.log(req.method) // 浏览器请求就是GET
  ```
  > ==res.end()是必要的,意为终止http请求,不写它默认请求就不会终止,服务器始终处于监听请求的状态,也就不会返回响应数据==
- ==3.3配置对应的页面==
- ==浏览器和服务器的交互规则:(基于本地服务器http构建)==
  - 浏览器发起请求时携带路径信息,这个路径信息代表对应的html
  - 服务器收到浏览器路径信息,从根目录(root)寻找,找到对应的html后,读取内容,进行数据返回
  - ==其中路径拼接靠path,数据读取靠fs==
- 额外提醒: req.url获取的数据就是浏览器请求地址的后面部分
  浏览器请求地址由http://localhost:3000 + 请求信息req.url组成
  - http: 请求协议
  - localhost: 域名 (网上你能搜索到的页面,域名都是买的)
  - 3000: 端口号 (网络上端口号也不是数字,人家在后端会进行操作改为别的信息)
- ==例如: `http://localhost:3000/test.html`的req.url为/test.html==
- ==3.3.1 配置绝对路径==
- 配置绝对路径是为了给fs读取文件提供文件地址
- ==使用path==
  ```
    引入path,简写解构出方法resolve 用于拼接url
    let {resolve} = require("path")

    // createServer的服务器逻辑代码-----------------
    let user_url = resolve(__dirname,"./root", "." + req.url)
  ```
- path配置规则: 
  - ==重要参数__dirname会获取本文件的绝对地址,后面是继续接下一个地址,参数必须写./,写/则是直接从根路由开始拼接,两者天差地别,如下== 
    - D:\前端vscode源码\源码\前端Plus\第二阶段全栈赋能\专题十一\Day38\04_2server\root\test
    - D:\test
  - ==把root和test拼接进去了==
- 然后fs会根据这个绝对地址从本地电脑上找到这个文件读取并返回
  ```
    // 引入fs
    let fs = require("fs")

    // createServer的服务器逻辑代码-----------------
    let user_data = fs.readFileSync(user_url)
    res.write(user_data) // 把数据放入响应体,再次访问页面时,显示对应的html
  ```
- 比如你在根目录root下创建了index.html,访问时在浏览器输入http://localhost:3000/index.html, 经过req.url提取出/index.html,
- 再经过path的resolve拼接 __dirname + ./root + ./index.html 最终频出绝对路径 D:\前端vscode源码\源码\前端Plus\第二阶段全栈赋能\专题十一\Day38\04_2server\root\index.html
- fs根据这个路径读取里面的所有html代码内容,最后通过res.write向响应体中写入内容
- ==页面就会显示你的html页面内容了,这和live server异曲同工,他也是在本地创建一个http服务器来展示你的页面,端口号为5050==
 [![pA5XgAK.png](https://s21.ax1x.com/2024/11/30/pA5XgAK.png)](https://imgse.com/i/pA5XgAK)
- ==设置404页面,用户输入错误地址统一返回这个路径==
- ==**使用try0-catch,成功走try,失败走404catch**==
- 可以分为 404html或res.write("404信息")
- ==1.res.write()==
  ```
    try{
        let user_data = fs.readFileSync(user_url)
        res.write(user_data) // 把数据放入响应体,再次访问页面时,显示对应的html
    }catch(e){
        // 读取文件错误: 路径错误
        // 返回数据可以是页面也可以是一段字符串
        // nodejs无法正常显示带有中文的字符串内容,需要额外设置res的请求头(注意是res的请求头,不是req的请求头)
        // 之前在CORS跨域的笔记,后端解决方案cors的设置也是给res设置请求头: res.setHeader("Access-Control-Allow-Origin" , "*");
        // 这里的请求头如下设置即可正常显示中文字符串
        res.setHeader("Content-Type","text/html;charset=utf8")
        res.write("请求路径错误,请检查url是否正确!")
    }
  ```
- ==404.html,在根目录root下,创建404.html,内部写好样式==
  ```
     try{
        let user_data = fs.readFileSync(user_url)
        res.write(user_data) // 把数据放入响应体,再次访问页面时,显示对应的html
    }catch(e){
        //  fs的路径可以是相对路径也可以是绝对路径
        let notFound = fs.readFileSync("./root/404.html");
        res.write(notFound)
    }
  ```
- 最后html内部有图片格式,就不要配置编码格式了,直接不写就行,否则图片会报错无法显示
- 其实html内的图片src也是个网络数据请求,写的是相对地址,http服务器会自动给你拼接好的
## express
### express基础
- 路由的优势 ,  express 给我们提供了路由机制 , 让我们方便的搭建接口 
- 中间件优势 , 我们在进行某些操作之前, 完成某些操作之前中间放入一部分部分功能

****
- 须知:
  - 需要下载express插件 npm i express
  - express也是个对象,由许多的方法,使用起来和http等差不多,需要引入
  - ==**使用express服务器**==
    - 引入express,配置服务器地址和端口号
    - 在终端开启(cmd)express框架下的nodejs服务器
    - 在浏览器对服务器发起请求(最简单的测试方法,有局限的)
****

- ==express基础(不涉及路由等,最基础的)==
  - 1.引入express: 
    `let express = require("express")` 
  - 2.创建一个 express 的实例对象; 
    `let app = express()`  ==app就是一个express对象,可以用app来进行服务器的各种操作了==
  - 3.监听端口
    `app.listen(3000,(req,res)=>{console.log("已经监听到端口3000")})`
  - 4.配置请求处理函数(==**语法与http均有所不同**==)
    `app.use("/",(req,res)=>{res.rend("hello!")})`
     默认地址'/',响应数据书写不在为res.write()+res.end()组合,直接一个rend即可

### express路由
****
- ==全局路由 : 它的响应处理函数一般不涉及具体业务!==
  - 全局路由负责使用中间件 app.use()
  - 全局路由负责引入并挂载子路由 `app.get/post...('url',子路由)`
- ==子路由 : 我们一般会把业务写在子路由之中==
  - 子路由都是一个独立的js文件, 放在独立的文件夹之中进行存放; 
****

- 1.照常例引入express工具和创建express对象app
- 2.创建存放子路由的文件夹,routers,在内部创建多个js文件,每个js文件视为一份子路由,其内部含有许多请求处理函数
  - ==子路由内部处理:==
    - 创建一个路由对象(事先引入express)
      `let router = express.Router()`
    - 向路由对象上添加请求方法
      `router.get("\",(req.res) => {处理方法...})`
      > ==**注意:**== 
      > 1.我们的路由不能使用use api了 , 因为use是不限制请求方式的路由, 在编写服务端程序的时候不够严谨; ==即全局路由使用use,而子路由要具体到get post等,所以需要把use替换成服务端需要的请求方式,例如get post等==
      > (get post put delete) 
      > 3.浏览器地址栏发送的请求只能是get请求, 如果需要发送其他类型的请求 , 需要使用ajax或者其他第三方工具,例如axios
    - 暴露子路由对象给主文件 (==nodejs模块化==)
      `module.exports = router`
- 3.==在主文件中(主路由文件)==
  - 引入子路由文件(例: 文件名为index)
  `let index = require("子路由文件相对于主路由文件的路径")`
  - 把子路由挂到主路由上
  `app.use("/",index)`
- 4.监听--略--
- 5.==**浏览器的请求,就是在地址栏上输入地址发送请求来测试服务器的运行**==(==注意事先cmd打开服务器再发送请求==)
  - **实现子路由某个功能的请求路径是 : 全局路由的路径(在全局中配置这个子路由时给的路径) + 子路由中这个功能函数配置的路由;**   
    ==最终的目标是访问具体功能 : 路径应该是  **基准路径(就是localhost:3000/)** + 主路由路径 + 子路由路径==
    ==**全局和子路由的路径如果为'/',那就是默认没有路径,基准路径后啥也不写就能访问到**==
    > 接口定义规范:
    > ==主路由规定业务类型,根据业务类型命名路径名称==
    > ==具体功能实现放在子路由之中,需要根据具体功能命名;==
    > 例如: 我们要定义一个用户接口,在主路由中我们定义的路径就笼统为"/user",而在相应的子路由文件(user.js)中,我们定义子路由对象的路径就可以多元化命名,比如这个处理函数负责用户登录,那么路径为"/userLogin",那个处理函数负责查询信息,路径就为"/userInfo".
    > ==不同功能访问路径不同,这样当我们想要用户登录功能时访问localhost:3000/user/userLogin; 当我们想要用户信息时访问localhost:3000/user/userInfo==
    > **相应的代码更加详细: 位置为第二阶段-专题10-Day39-express-02express路由**
### express中间件
- ==本节具体仅讨论子路由文件中如何使用express中间件==
- express框架一个请求的多个处理函数,==简化代码,减少冗余,方便维护==
- 具象化为以下:
  - 没有中间件(子路由对象配置处理函数如下):
    router.get("/",(req,res)=>{==所有的处理代码都要写在这一个响应函数内部,十分不利于维护,且冗余==})
  - 有中间件(分为三级)
    - 路由器内的中间件 : 在同一个路由方法里面有多个中间件, 中间件之间相互调用 
    - 跨域路由的中间件 : 在两个同名路由之中有多个中间件,这些中间件之间相互调用; 
    - 错误处理中间件 : 统一的错误处理中间件; 
- 具体解释三个中间件,如下
  - ==**1.路由器内的中间件:**== (如下体现,一个子路由内部不再是单独一个处理函数,而是两个函数名)
  `router.get("/first" , middleware1, middleware2 )`
  对这两个中间件具体使用如下
    ```
    function middleware1( req , res , next ){
      // 请求处理 
      console.log("中间件1被调用了"); 
      setTimeout( ()=>{
          next();
      } , 1000)
    }
    function middleware2(req , res , next ){
        // 响应处理  
        console.log("中间件2被调用了");
        res.send("中间件2给的响应数据")
    }
    ```
    > 解释:
    > 1.只要路由的路径被请求了, 从左到右的第一个中间件middleware1就会被调用; 
    > 2.middleware1被调用后,内部最后执行next()即意味着在顺次执行下一个中间件middleware2
    > 3.每一个中间件函数都有三个参数 req res next , 其中next是启动下一个中间件的关键
  - ==**2.跨域路由的中间件**==
  - 如下配置(两个子路由的地址都为second,handlerReqData和handlerResData可以衔接,那么和handlerErrorTip就属于跨域了)
  - `router.get("/second" , handlerReqData , handlerResData )`
    `router.get("/second" , handlerErrorTip )`
  - 代码:
  ```
  function handlerReqData( req , res , next ){
    // 负责处理请求数据的 : 
    // 请求数据正常那么我们调用 handlerResData() 中间件
    // 请求数据不正常那么我们调用 handlerErrorTip() 中间件 

    // 注意 : 请求数据都放在req对象之中 , GET请求数据可以通过 req.query 这个属性进行获取; 
    // 携带数据请求,按照get的语法就是 url?key1=value1&key2=value2&....
    // console.log( req.query );

    // 需求 : 请求之中必须携带 name 和 age两个参数  , 如果不携带那么我们就报错;
    let { name , age } = req.query;

    if( name && age ){
        // 如果name和age参数都存在那么我们就调用响应处理函数; 
        // 直接调用next就是同级别路由的下一个中间件handlerResData(); 
        next();
    }else{
        // 如果我们想要跨域跳转到下一个路由的中间件handlerErrorTip
        // 传入的参数 route 是必须的! 是固定的! 
        next("route")
    }
  }

  function handlerResData( req , res  ){
      // 处理响应数据的时候可以直接返回json格式的数据 , express给我们提供了json格式的处理工具, 这个处理工具可以直接传入对象, express会把对象格式化成json然后进行返回; 
      let data = {
          // 响应数据我们可以随意定义; 
          code : 1,
          // 携带的数据 
          info : req.query,
          // 提示信息 : 
          message : "你传递的数据我已经收到了,放在info之中给你查看一下"
      }
      res.json( data )
  }

  function handlerErrorTip( req , res ){
      let data = {
          // 响应数据我们可以随意定义; 
          code : 0,
          // 提示信息 : 
          message : "抱歉你传递的数据不全，需要传递name和age字段数据!"
      }
      res.json( data )
  }
  ```
  > 总结重点: 
  > 1.==跨域跳转为next("route"),固定这么写;即从中间件handlerReqData跳转到中间价handlerErrorTip==
  > 2.==**get请求下的新方法req.query,作用是获取请求信息**==
  > 3.测试时为浏览器携带参数,也就是路径格式为 url?key1=value1&key2=value2&....
  > 4.res.json(data)直接在浏览器页面中返回data的json数据
  - 3.==**错误处理中间件 : 统一的错误处理中间件**==
    - ==错误处理路由我们应该定义在app.js 之中,因为所有的错误都会进入到这个路由里面;== 
    - 在主路由文件中代码如下:
    ```
    app.use(( err , req , res , next )=>{
      console.log(err); // 控制台打印错误信息
      // 错误信息中打印下状态status为500,并在页面书写"服务器错误"
      res.status(500).send("服务器错误"); // 连缀写法
    })
    ```
    - ==在子路由中判断是否进入app.js的错误处理函数==
    ```
    if(name === "haha"){
        next({message : "错误信息"})
    }
    ```
    > 总结: ==不是next()或next("router");**前者是同一个路由跳进下一个中间件(1),后者是跨域路由跳转(2)**==;
    > ==next()内部放入对象作为参数,对象内配置好错误信息,然后可自动跳转到主文件app.js中的错误处理中心==

### 拓展关于express的req参数
- ==1.req.query==
- req.query用于获取查询字符串,查询字符串是 URL 中?后面的部分，以key=value的形式出现，多个参数之间用&连接。
- ==比如: url?name=123&age=100 ---> { name: '123', age: '100' }, 通过`req.query.name/age`可以访问到==
> 
- ==**2.`req.params`属性（在路径中有参数时）**==
   - **用途**：如果GET/POST/PUT请求的URL路径中包含参数，`req.params`可以用来获取这些参数。这种参数通常是路径的一部分，通过`:`在路径定义中表示(==动态路由==)。
   - **示例**：
     - 定义一个路由，如`app.get('/api/users/:id', (req, res) => {...})`。当发送一个GET请求到`http://example.com/api/users/2`时，`id`参数的值可以通过`req.params`获取。
   - 示例代码:
     ```javascript
       app.get('/api/users/:id', (req, res) => {
         const userId = req.params.id;
         console.log(userId); // 输出2
         res.send(`User with id ${userId} information retrieved.`);
       });
      ```
  > ==kerwin的element小demo里有,动态路由的配置:id常用于记录学生的id信息的,方便针对性地更新/删除这个学生的数据==
- ==**3.req.url属性**==
- 用途：==req.url可以获取**完整的请求 URL 路径**==，包括查询字符串部分。它提供了整个请求的路径信息，在某些情况下，可能需要对整个 URL 进行解析或者记录请求的完整路径时会用到。
- 对于前面提到的http://example.com/api/users?id=1&name=John这个请求, req.url的值就是`/api/users?id = 1&name = John`(==除了基础路径的协议和域名没拿==)
>
4. ==**`req.headers`属性（与请求相关的元数据）**==
   - **用途**：虽然不是直接获取GET请求的参数，==但`req.headers`包含了请求头的所有信息==。在某些情况下，请求头中可能包含与请求相关的重要数据，如`Authorization`头用于认证信息，`User - Agent`头用于获取客户端的浏览器或设备信息等。这些信息可以帮助在服务器端更好地处理GET请求。
   - **示例**：
     - ```javascript
       app.get('/api/users', (req, res) => {
         const userAgent = req.headers['user - agent'];
         console.log(userAgent); 
         res.send('User information retrieved.');
       });

  > ==特别是Authorization,我们在kerwin的eleDemo中学习**req.headers["authorization"]?.split(" ")[1]帮助我们获取了请求信息中是否有token信息**; 
  > 然后又通过**res.header("Authorization", newToken)**,在返回的响应头数据中,给Authorization属性设置了新的token,之后在axios拦截器的axios请求成功阶段中,重新把这个res中的token存入本地,更新了token值==

### express第三方中间工具
- 讲了两个工具的用法 : 
  - ==第一个是express自带的方法==,express.static(url)
  - ==第二个新工具cors==(json跨域工具),**这个需要`npm i cors`下载**;  
- ==**第一个:static静态部署文件夹**== 
  - ==对文件夹进行静态开放,使得所有请求优先从目标文件中寻找,一般为public文件,这是默认规则==,**下一节工程化创建项目文档中的public文件夹就负责此功能**,设置代码为`app.use(express.staic(./public))`,url的路径是相对主文件的相对路径,没有public文件会自动创建
  - 在pubilc文件夹中创建相关文件,后续请求中通过"==基础路径(http://localhost:3000/) + 文件名=="可直接访问到此文件
- ==**第二个cors()工具**==
- 作用: ==使用 cors 跨域,直接使用第三方插件来完成请求头配置==
- 例如: 可以全局或局部地给express路由res.headers关于跨域配置信息,`access-control-allow-origin: * `
- ==cors()配置分为全局配置和局部配置,()内部的只有一个参数,即配置信息==
  - **事先下载并引入cors省略**
  - **全局配置** : 在主路由文件app.js中,直接`app.use(cors()) // 之后所有的在app.js服务器下的网络请求中均携带请求头`
  - **局部配置** : 主路由中,我们会引入子路由用于配置,想要给谁加请求头,就在配置use中加上cors
    - 实例代码 : 
    - `let test = require("./routers/test") // 引入test文件中的子路由`
    - `app.use("/",cors(...),test) // 给所有向test子路由文件的网络请求添加请求头`
    - 查看方式为 : 网络-响应标头-access-control-allow-origin : *

### express项目构建工具(项目工程化)
- express-generator 项目构建工具 : ==在cmd上一键构建项目初始架构,在需求文件夹中使用==
- **1.下载并执行(cmd)**: `npx express-generator --view=ejs`,输入此指令后,系统会自动下载工具并创建对应文件夹
- 下载后直接运行`npx express-generator`
- **2.创建的文件夹介绍**(都是默认的,以后在业务需求中也这样使用这些文件夹,什么该放什么有规定)
  - ==文件介绍==
    app.js：应用的主文件，设置中间件和路由。
    bin/www：启动脚本，设置服务器端口并启动服务器。
    public/：静态文件目录，存放 CSS、JavaScript 和图片等。
    routes/：路由目录，定义应用的路由。
    views/：视图目录，存放模板文件。
    node_modules/：依赖包目录。
  > 注意: 执行指令之后会创建对应的服务端结构, 结构创建之后我们并不能直接运行服务端环境，==我们需要安装依赖之后才能完整执行服务端功能;== 
- **3.安装所有的文件依赖**
  - 代码: 输入`npm i`指令可以快速根据`package.json`文件之中的依赖下载所有的依赖插件; 
- **4.运行服务器** 
  - 运行服务器是**根据`package.json`文件中的 `scripts`属性规定的启动指令执行的,==我们主要查看 scripts 属性的左侧的数据==,**==这个数据就是指令名,右侧的数据是具体的指令值==
  
  - **我们运行`scripts`指令的方式是 `npm run 指令名`,即`npm run start`**

- 5.**修改npm对应的指令**
  - ==我们常使用nodemon来运行服务器,这样更加方便,为了项目文件也能如此,我们需要修改其启动的源代码,位置还是在`package.json`文件中的 `scripts`属性中的`start`对象中,把==`node ./bin/www` => `nodemon ./bin/www`; 让我们的服务器实现热启动, 这样我们在开发项目的时候会更加方便; 

****
- ==**总结步骤(cmd)**==
  1.安装项目基本结构 指令 : `npx express-generator --view=ejs` 
  2.安装项目文件的所有依赖 `npm i`
  3.修改package.json内部script的启动源代码 start : 'node' --> 'nodemon'
  4.启动项目 `npm run start`

### express项目构建的简化
- ==精简:==
  - view删除,router内部的默认文件删除
  - app.js内部曾经对router内部的两个路由文件的引入也要删了(注释掉了),ejs相关的也删除了,同时package.json内部也删除ejs的版本号
  > ==唯一要注意的是,如果要精简,那么在删除完package.json中的ejs版本号再进行npm i的依赖下载,从而防止下载关于ejs的依赖项目文件==

### 路由表(项目工程化)
- ==就是把我们的原本放在app.js之中的路由引入更改到routes文件夹之中进行,**这样代码更简洁,也是项目规范**==

- ==**1.思路**==: 
  - 1.创建routes文件夹的第一个文件index.js,这个js文件内部主要内容就是对route的其他js文件进行路由引入操作
  - 2.在app.js中直接把route中的路由表文件index.js挂起,从而减少了app.js的代码冗余
  - 如下图: 
    [![pAGLrLR.png](https://s21.ax1x.com/2024/10/09/pAGLrLR.png)](https://imgse.com/i/pAGLrLR)
- ==**2.细致操作**==:
  - 1.==在子路由文件夹routes中创建test.js和user.js,做好子路由定义工作并暴露给index.js==
    - 代码: ==**简化: 引入express与Router()写在一起**==
    - test.js
      ```
        let router = require("express").Router();

        router.get("/", ( req , res )=> {
            res.send("这是test路由!");
        })

        module.exports = router;
      ```
     - user.js
        ```
          let router = require("express").Router();

          router.get("/userLogin", ( req , res )=> {
              res.send("这是用户登录子路由!");
          })
          router.get("/userInfo", ( req , res )=> {
              res.send("这是用户信息子路由!");
          })

          module.exports = router;
        ```
  - 2.==在路由表index.js中,做好曾经app.js的引入工作,**并暴露**==
    - 代码:
      ```
        // 这个index.js 是路由的配置文件, 相当于把原本在app.js 之中的配置路由的代码拿到这里进行路由表配置; 

        let router = require("express").Router()
        // 我们的主路由挂载流程就不再app.js里面进行了, 我们在 index.js 里面进行; 

        // 路由表,所有的route文件中的路由可以在这里挂起,像一个表格,精简且有序
        // app.js有自己的默认代码,index.js的路由挂载防止所有的代码冗余到app.js

        // 1. 挂载test路由 : 
        let test = require("./test");
        router.use( "/test" , test )
        // 2. 挂起user路由: 
        let user = require("./user")
        router.use("/user",user)

        module.exports = router;
      ```
  - 3.==在主文件app.js中直接引入index.js路由表==
    - 代码:
      ```
        // 把路由表直接挂在到app上; 
        // 简写: 这种路径引入表示直接引入 routes/index.js , index.js是系统默认寻找的文件名字
        let routes = require("./routes");
        app.use( routes );
      ```
### express + Mongodb流程化
- ==这是一种思路,即使以后我们的数据库不再是mongodb,是mysql,即使后端不再是简单的nodejs+express框架,而是springboot框架; 依旧要有层级意识,即不要把所有的事情放在一个文件中做,这样代码冗余,后期不好维护; 正确的做法是,在默写默认规则下,创建多个不同文件夹,把工作流程分工,每个部分负责一个板块,依次相连,完成整个一个后端操作数据库的流程==
- kerwin的express后端分工如下(4个文件夹)
  - routes: **负责定义子路由和请求方式**
  - controllers: **接受前端的req,发送axios请求,返回res给前端**,==同时必要时对req进行数据整理等操作(例如: 动态路由:id的获取/token密码更新的操作)==
  - service: **根据前面axios请求的req信息,进行数据库操作**,==同时必要的化对req进行数据整理再进行数据库的查询==  
  - model: **创建非关系型数据库mongodb的文件,创建相应集合,返回出这个集合对象(==也就是模型==),然后在service文件操纵这个模型** 
   > 1.非关系型数据库称之为'集合'; 像sql这种关系型数据库称之为'表'
   > 2.创建的这个集合在后端对应会有一个模型对象,操纵这个模型就可以同步操作数据库内集合的数据了
## 文件上传
### Multer基本使用

****
  文件上传的文件名字有中文会变为乱码,由于我们上传文件是通过form表单直接传递的,而非axios,文件编码的配置等需要addData等操作,后面的几节才会有解决
****

- ==**注意:这里的文件上传是通过配置表单进行的,而kerwin的eleDemo的文件图片上传是通过整理form表单数据后,携带数据向后端发axios,最后存入数据库**==
- ==文件上传==
  前端用户发送图片,图片由后端接收转到到服务端设备上的操作(未必是图片,所有文件都行,课程里以图片传输为主),==nodejs的文件上传功能主要就是使用 **`multer` 插件**实现的==  
- ==Multer工具插件==
  - ==使用Multer==: 在相应的文件夹中,下载插件`npm i multer`
  - Multer 是一个 node.js 中间件，用于处理 **multipart/form-data 类型**的表单数据，==它主要用于上传文件== 
    > 注意: Multer 不会处理任何非 multipart/form-data 类型的表单数据;在form表单中==enctype属性==是用来确定类型的
  - ==multer中文文档==: https://github.com/expressjs/multer/blob/master/doc/README-zh-cn.md
  - ==很好的CSDN社区文章==,详细介绍了Multer诸多用法,在此笔记没有涉及的也有许多,地址:https://blog.csdn.net/Charissa2017/article/details/105207422


- ==问题 : 请求方式为post怎么办?== 
   测试接口的时候需要前端来完成接口的请求发送, 浏览器直接发请求这个事行不通, ==浏览器地址栏只能发起get请求,由于上传的文件是图片,其数据量较大,我们必须使用post发起上传文件的网络请求==
- ==解决:**通过form表单请求解决,并给form表单的属性配置好**==
   - 在public中创建 '文件上传.html' (==express自动构建的项目中public是静态开放部署==),这样在浏览器中直接请求这个html文件的路径进入页面,在通过form发起网络请求

- 1.==upload.js文件(配置Multer的js文件)==
    ```
    // 1.引入multer和设置子路由
    let multer = require("multer")
    let router = require("express").Router()

    // 2.配置multer中间件
    // 配置项 : 配置上传文件的位置
    // Multer 接受一个 options 对象，其中最基本的是 dest 属性 , 这将告诉 Multer 将上传文件保存在哪
    // 如果你省略 options 对象，这些文件将保存在内存中，永远不会写入磁盘。(其余见文档)
    let upload = multer({dest : "uploads/"})

    // 语法: upload.single(fieldname) 上传单个文件内容，如一次只上传一张图片。fieldname为上传时文件的字段名称
    // 在form表单的input上传文件中,其name要与这个字段fieldname相同,用于接收input那传来的文件
    // 最后定义: 请求子路由url , multer中间件 , 相应处理函数
    router.post("/profile",upload.single("avatar"),handlerRes)

    // 响应处理函数()
    function handlerRes (req,res){
        // 我们图片上传完后,图片信息在req中,在single上传文件处理完成后,我们可以使用这些数据进行操作
        // req.file 图片存储文件夹 , req.body 文本域数据(几乎不用)
        let data = {
            code : 1,
            file : req.file,
            body : req.body
        }
        res.json(data) // 查看下数据
    }
    // 3.暴露给路由表文件index.js
    module.exports = router
    ```

- 2.==文件上传.html==的代码和解释:
    ```
    <h2>文件上传</h2>
    <form action="/upload/profile" method="post" enctype="multipart/form-data">
      <!-- enctype="multipart/form-data",这是最重要的,Multer 不会处理任何非 multipart/form-data 类型的表单数据。-->
      <!-- 
        1.action:写好了文件上传的express配置的路由地址
        /upload/profile是上传文件的主路由+子路由,最后锁定router.post("/profile",upload.single("avatar"),handlerRes)
        2.method设置了请求的方法 post
      -->
  
      <input type="file" name="avatar">
      <!-- 上传文件类型type为文件file -->
      <!-- name属性值为字段集fieldname,即(multer.single(fieldname)) -->
      
        <!-- 图片之后会在uploads文件夹内,需要后缀添加.jpg可以打开,后期我们可以自己配置,自动添加 -->
        <!-- 为了避免命名冲突,还会给上传的文件改名字,如果不希望这样做,需要手动设置 -->
      <button>提交图片</button>
    </form>
    ```
- ==综上:==
  - upload.js定义了multer的基本属性
    - 配置了上传文件存储地址dest
    - 配置了上传文件要求,即single()单个上传和其字段集fieldname(与input的name对应)
    - 配置了router的url,Multer中间件和处理函数
  - 文件上传.html
    - 解决post请求问题method
    - 配置form表单的action(路由地址)和enctype="multipart/form-data"
### 文件名更改和优化项目结构
- 1.文件名更改:
  - 上一节课我们在对应的文件夹中查看上传的文件时,会发现名字被更改,并且没有后缀了,想要打开图片需要手动添加后缀例如.jpg/.png等,原因是计算机为了避免命名冲突,Multer默认会修改上传的文件名为随机字符。==如果想自定义文件名称,可以在DiskStorage中配置==
- 方法 : 
  - 1.配置diskStorage `let storage = multer.diskStorage(Pro)`,==参数Pro代表一个对象类型数据,这样就配置好了一个名为storage的multer对象==
  - 2.Pro对象的参数配置,有两个属性,第一个文件存储路径属性destination,第二个文件名称属性filename,==配置具体信息时稍微不同一般思路,它们都用函数进行配置,函数都有三个参数,req,file,cb(回调函数),req是请求头信息,file是上传文件的信息,**cb是配置信息关键,其第二个参数即为配置的信息**==
  - 3.cb函数配置 
    - 文件路径 : cb(null,url) url:存储地址的绝对路径
    - ==url: 必须绝对路径,使用path的resolve拼接==
    - 文件名称 : cb(null,name) name:文件名称
    - name文件名称还是要有随机数字防止重名,我们使用的是Math.==random()生成的随机数字后转化为字符串,还可以拿Date.now()数字戳解决==,而文件的原始名称和后缀是在req.file属性中获取originalname属性后,再使用path的parse方法解析这个属性获得两个新的属性name(名称),ext(后缀),最后三者拼接即可
  - ==关于path.parse的知识点补充==
    - 功能：将路径字符串解析为一个对象，该对象包含路径的各个部分，如root（根目录）、dir（目录）、base（文件名 + 扩展名）、name（文件名）和ext（扩展名）。
    - 代码示例: 
      ```javascript
        const filePath = '/home/user/projects/file.txt';
        const pathObject = path.parse(filePath);
        console.log(pathObject);
      ```
    - 打印结果:
      ```
        {
          "root": "/",
          "dir": "/home/user/projects",
          "base": "file.txt",
          "name": "file",
          "ext": ".txt"
        }
      ```
    - ==**originalname就是文件的上传时原始名字**,比如为'404notfound.png',通过path.parse(originalname)解析后为 {"name":"404notfound" , "ext":"png" },解构后两者中间拼接一个随机数字符串防止重名即可==
  - 4.应用配置(将配置好的内容放入对象作为multer的参数)
    `let upload = multer({storage})`
  - 5.代码: diskStorage的配置
      ```js
        let storage = multer.diskStorage({
          // 配合文件存储路径的属性 : 
          destination : function( req , file , cb ){
              // cb 就是路径配置函数 : 
              // 我们要调用cb函数传入路径信息实现上传文件的路径配置; 
              // cb 的第二个参数就是文件存储的路径; 这个路径应该是一个绝对路径; 
              // 注意 : 我们要配置的路径信息是 public 文件夹下的 images 文件夹;
              cb( null , resolve(__dirname , "../public/images") )
          },
          // 配置图片名称
          filename : function( req , file , cb ){
              // originalname : 图片的原始名称; 
              let { originalname } = file;
              // 拆解图片路径可以使用path对象之中的parse工具  
              let { ext , name } = parse( originalname );
              // 文件名是用 原名称 + 随机数(toString把数字类型转化为字符类型) + 后缀名拼接成的! 
              cb( null , name + "-" + Math.random().toString().slice(2) + ext );
          }
      })
      ```
- 2.优化路由结构
  - 在express项目工程文件中route负责路由的定义,引用和应用路由的文件,内部应当简洁,所以diskStorage这个子路由配置我们应当放入一个新文件夹utils(工具),==在这里面完成上面4个方法步骤,并完成应用配置,最后暴露upload,然后在route文件夹的upload.js中引入utils文件夹中的upload-utils.js文件暴露的upload,之后直接使用upload即可,**这样route文件夹内文件十分简洁,这是项目工程化的规则**==
- 下面是代码实例,经过项目结构优化
  - ==utils文件夹内的upload-utils.js文件代码:==
    ```
    // 1.引入multer path
    // 其中resolve和parse提前结构出来,方便后期使用
    let multer = require("multer")
    let { resolve, parse } = require("path")

    // 2.图片配置: 图片上传位置和图片名字都可以通过multer.diskStroage()函数进行统一配置
    let storage = multer.diskStorage({
        // 配置文件存储路径的属性
        destination: function (req, file, cb) {
            // 在这里面写配置信息; 
            // cb 就是路径配置函数 : (回调函数)
            // 我们要调用cb函数传入路径信息实现上传文件的路径配置; 
            // cb 的第二个参数就是文件存储的路径; 这个路径应该是一个绝对路径; 
            // 注意 : 我们要配置的路径信息是 public 文件夹下的 images 文件夹;
            // 拼接路径,从utils文件夹../跳出,在进入pubilc文件夹的images文件夹中
            cb(null, resolve(__dirname, "../public/images"))
        },
        // 配置图片名称
        filename: function (req, file, cb) {
            // 写配置信息
            // 获取下file信息,发现originalname是文件的初始名字
            // console.log(file);
            let { originalname } = file
            // 拆解图片路径可以使用path对象的parse工具
            // console.log(parse(originalname));
            // 发现后缀名存在ext属性中,名称存在name属性中
            let { name, ext } = parse(originalname) 
            // 配置路径信息 还要调用cb
            // 第二个参数是文件名字,其组成为 文件原名 + 随机数 + 后缀名
            cb(null,name + "-" + Math.random().toString().slice(2) + ext)
            // toString 对象->字符串 
            // slice(2) 截取数组[2](包括[2])及后面的所有数
            // 形如 OIP-C-904353539615333.jpg
        }
    })
    // 3. Multer配置 upload已经是一个配置了storage的multer对象了
    let upload = multer({ storage })
    // 4. 暴漏upload
    module.exports = upload
    ```
  - ==route文件夹内upload.js代码:==
    ```
    let router = require("express").Router()

    // 1.引入upload(在upload-untils内部我们已经配置好了并暴露了)
    let upload = require("../utils/upload-untils")
    // 后续使用的upload就是在utils内部配置好的Multer对象

    // 2.使用配置了storage(diskStorage)的multer对象upload
    router.post("/profile", upload.single("avatar"), handlerRes)

    // 类似下面的函数handlerRes也应该拆分出去,严格来叔upload文件中只能由引入操作和简单调用
    // 响应处理中间件
    function handlerRes(req, res) {
        let data = {
            code: 1,
            file: req.file,
            body: req.body
        }
        res.json(data)
    }

    router.get("/", (req, res) => {
        res.send("load功能路由!")
    })

    // 3.再次暴露,方便在路由表index.js文件中使用
    module.exports = router
    ```
### 多文件上传
- 复习并学习新的文件上传
- ==upload在talis文件夹中配置好并暴露,在route文件中直接使用upload的multer方法即可==
  - 1.**单字段单文件上传upload.single()**
  - 参数:一个,即字段集
    代码: `router.post("/profile", upload.single("avatar"), handlerSingleRes)`
  - 2.**单字段多文件上传upload.array()**
  - 参数:一个,还是字段集
  - 变化:在html的form表单中,给input添加一个multiple属性用于选中多个文件即可
  - 代码:`router.post("/profiles", upload.array("avatars"), handlerArrayRes)`
  - 3.**多字段单文件上传upload.fields()**
  - 参数:一个对象数组,数组内的每一项都是一个对象,内容是字段集
  - 代码: 
    ```
    let fileds = [ // 2个字段集 avatar1 avatar2
      {name : "avatar1"},
      {name : "avatar2"}
    ]
  
    router.post("/fields", upload.fields(fileds), handlerFieldsRes)
    ```
  - 变化: html内form,再写一个input,然后把相应的name改为字段集,并且去掉multiple
  > ==注意:每一种文件上传配置的route地址都不同了,请求action要改到对应的地址==
- ==对三种文件上传响应函数的处理方式==
  - ==都有2个参数 req 和 res== , 其中**req.file**属性最为重要,它是文件上传许多重要信息
  - 如下图(==单文件上传实例==):[![pAJjaCV.png](https://s21.ax1x.com/2024/10/10/pAJjaCV.png)](https://imgse.com/i/pAJjaCV)
  - (==单字段多文件==)而如果多个文件上传,就是存入数组,变为一个对象数组,相应的属性变为req.files,如下图:[![pAJjd3T.png](https://s21.ax1x.com/2024/10/10/pAJjd3T.png)](https://imgse.com/i/pAJjd3T)
  - 当然我们不需要这么多复杂的数据,我们提取重点两个数据,**文件名和文件的路径**
    > 注意: 这里的req.files内的路径是电脑的绝对路径,在互联网图片显示是绝不允许这种绝对路径的,这里借用map修改了下路径url,在互联网上都应是http图片
  - 最后,==多字段单文件上传==,通过req.files获取的对象是字段集和其上传文件信息组成的对象,如下图:[![pAJjg4x.png](https://s21.ax1x.com/2024/10/10/pAJjg4x.png)](https://imgse.com/i/pAJjg4x)

> ==在这里基本完善了文件上传的类型,还可以设置文件最大上传数量,文件上传的大小限制等,都在那片CSDN文章内(详见本章节第一节Multer的地址)==

### ajax网络请求(多文件上传项目内)
- ==**之前我们总是用form表单进行网络请求,这次我们用ajax请求**==
- 新东西: ==new FormData()==,一个参数,即form表单的dom对象
- 思路: 
  - 1.form表单不动,获取其发送网络请求的按钮dom对象和form表单的dom对象(==用于new FormData()的参数需要==),之后设置点击事件
  代码: 
    ```
      let btn1 = document.getElementById("btn1")
      let form1 = document.getElementById("form1")
      btn1.addEventListener("click",sendUploadData)
    ```
  - 2.配置点击事件响应处理函数, ==**首先把form的默认行为删除**==,创建XMLHttpRequest()网络请求并配置参数,发送请求,==唯一不同这里的POST请求不需要设置请求头==,**使用FormData创建表单数据对象,用于发送,如果要携带文件数据进行form表单发送,这是必须的要设置的,它可以打包整理你的form表单数据**,最后设置onload处理函数检查请求是否成功
  - 代码:
    ```
       function sendUploadData(e){
            // 阻止form的默认提交行为
            e.preventDefault()
            // 配置ajax请求
            // 注意: post请求,但是我们当前的文件上传请求不需要额外设置请求头

            // 1.创建xhr对象
            let xhr = new XMLHttpRequest()
            // 2.配置发送信息(发送格式/地址)
            xhr.open("POST","/upload/profiles")
            // 3.创建存储表单数据的FormData
            // 参数为获取的表单dom对象
            let fd = new FormData(form1)
            // 4.发送请求(直接把fd放入即可)
            xhr.send(fd)
            // 5.响应数据
            xhr.onload = function(){
                let data = JSON.parse(xhr.responseText)
                console.log(data);
            }
        }
    ```
  > ==注意: 这里的ajax是由老旧的XMLHTTP发送的,正常情况下都用axios发送,所以推荐kerwin讲解的eleDemo笔记的最后部分升级战略的Center布局和接口处理部分,结合axios理解==

### 简易登录及文件规范工程化

- 思维导图: [![pAJxnl8.jpg](https://s21.ax1x.com/2024/10/10/pAJxnl8.jpg)](https://imgse.com/i/pAJxnl8)



### 项目拆分总结(很重要)
- ==从express-generator第三方工具开始,我们逐步规范化工程文档的构成,之后的路由表index,utils,pubilc到今天,彻底完善工程化文件的规则==

- ==**文件介绍(精简后)**==
    - **app.js**：应用的主文件，设置中间件和路由。==现阶段使用方面为引入路由表index.js和设置总错误处理中间件== 
    **bin/www**：启动脚本，设置服务器端口并启动服务器。
    **public/**：静态文件目录，存放 CSS、JavaScript 和图片等。==目前所用创建html文件==
    **routes/**：路由目录，定义应用的路由==现阶段引入路由,使用路由==。
    **node_modules/**：依赖包目录。==下载的第三方工具都在这==
    **utils**: 工具性质的文件夹,旨在配置一些参数等工作,大家公用的一些常用的装配工作,比如,整个项目是一个服装生产工厂,而工具文件夹utils封装了一个贴标签的函数,那么所有的别的流程下的工作都可以借用这个贴标签的工作函数来完成工作中的一部分,而不用重复地写这一段代码
    **middleware**: 中间件函数
    **controller**: 所有的响应处理函数
    **package-lock**:下载的第三方工具的版本号
    **package.json**:下载的第三方工具的依赖文件,通过npm i直接下载
  > ==**记得暴露!!!!!否则别的文件识别不到,module.exports={...}**==
  - 思维导图: [![pAJLcUP.jpg](https://s21.ax1x.com/2024/10/10/pAJLcUP.jpg)](https://imgse.com/i/pAJLcUP)
