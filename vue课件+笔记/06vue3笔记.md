## 初始vue3
- **官方文档很有帮助**
- vue3官方文档:https://cn.vuejs.org/guide/quick-start
- 在初学vue3阶段,==我们使用的是CDN的形式结合html浅尝vue,为了更快的使用,我们选择把vue的源代码下载在本地,直接使用script--src引入==,这种方式是最基础的vue引入,相对比vite,vue/cli更方便,但是也有许多局限,新手入手为主
- 在官方文档的快速上手里有vue的源代码文档,地址为https://unpkg.com/vue@3/dist/vue.global.js
  把源代码复制到本地文件夹,然后使用script--src引入即可
- edge查看md文件: file:///D:/前端vscode源码/源码/MarkdownFile/vue课件+笔记/06vue3笔记.md
## vue2与vue3响应式数据的底层逻辑
- 响应式数据:==顾名思义,就是vue内部的代码改变,随之网页的代码内容随之改变==
- ==具体介绍了 "js vue2 vue3 "的响应式底层逻辑==,vue2是基于js的definedPropert实现的,有很多缺点,而vue3是基于proxy实现的,更快更方便
- 代码:
    ```
    <div id="box">box</div>
    <div id="box1">box1</div>
    <script>
        // 探究vue如何实时修改数据的

        // 看看js如何做?
        // 原生js拦截方法
        // Object.definePropert
        var id = document.getElementById("box")
        var id = document.getElementById("box1")
        var obj = {}
        // 往obj添加一个属性myname
        Object.defineProperty(obj,"myname",{
            // 单纯获取myname的值是执行get函数
            get(value){
                console.log("get",value);
                return box.innerHTML
            },
            // 如果修改myname的值时,执行set函数,并真的对myname进行修改
            set(value){
                console.log("set",value)
                // 更新页面如下
                box.innerHTML = value
            }
        })

        // 以上是Vue2的底层逻辑,有很多缺点
        // Vue3进行改进为ES6 proxy 方法

        // ES6 proxy代理
        var obj1 = {}
        // vm 代理的更改影响原obj1 , 直接操作vm 即可
        // 更加优秀的拦截效率: 不必一个个拦截,代理单个属性"myname" , 而是直接代理整个对象 , 无论那个属性都可以
        // 把obj1作为目标代理对象放入, vm.a 就是a作为key传入,返回obj1中a这个属性的value,如果修改,如vm.a = 100,同理set拦截也是把要改的值value(100)获取并重新赋值给vm.a , 修改后 , 如果访问obj1.a也同理改变了
        var vm = new Proxy(obj1,{
            get(obj1,key){
                console.log("get");
                return obj1[key]
            },
            set(obj1,key,value){
                console.log("set");
                obj1[key] = value
                box1.innerHTML = value
            }
        })

    </script>
    ```
## createApp().mount() API
- 首先引入vue官方文档 (相对路径): `<script src="../线上vue.js代码复制/vue.js"></script>`
- ==双花括号 `{{}}`== :  vue会把里面的东西当作js来运行,也是在html中响应vue的一个方法
  > 注意: ==支持js的基础计算 + - * / , 三木运算 , 拼接字符串( + "") , 甚至于函数应用 , array.slice(0,2) 调用了数组的slice方法==
  > **但是不支持js的语句 , 比如 赋值变量(var a = 1) , 条件语句( if(...){...} ) , 循环语句 , while语句等**
- ==Vue.createApp(obj).count("XXX")== : 前面的就是放入配置对象,是vue代码的配置区 ; 后面是挂载对象,一般挂在根节点(div)上,**记得提前给根节点设置id或class值 , id+# ; class+.**
  > 注意: ==vue挂在需要根节点,body不可以作为根节点,一般是div,vue支持多个单独挂载,但通常是一个div最为根节点包裹了整一个vue项目,这样我们不用重复进行单一挂载了,此配置对象obj中的vue代码对此根节点内的html代码生效==
- 代码:
  ```
      <body>
      <!-- 双花括号 , vue会把里面的东西当作js来运行 -->

      <!-- {{}}支持js的基础计算 + - * / , 三木运算 , 拼接字符串( + "") , 甚至于函数应用 , array.slice(0,2) 调用了数组的slice方法 -->
      <!-- 但是不支持js的语句 , 比如 赋值变量(var a = 1) , 条件语句( if(...){...} ) , 循环语句 , while语句等  -->
      <div id="box">我是kerwin {{10 + 20}}</div>
      <div id="box2">我的vue {{100 + 200}}</div>

      <script>
          // 启动vue , 挂载在box节点 , id=box标签内部的所有{{}}都有效
          Vue.createApp().mount("#box") // 使用了两个方法 createApp count
          Vue.createApp().mount("#box2")
          // 注意: vue挂在需要根节点,body不可以作为根节点,一般是div,vue支持多个单独挂载,但通常是一个div最为根节点包裹了整一个vue项目,这样我们不用重复进行单一挂载了
      </script>
      /body>
  ```

## createApp(obj)配置(选项式):
### data(){}配置
  - ==下面是选项式写法,是vue2的主流写法,vue3更新了组合式写法(后面讲),在vue3中,两种写法都支持==
  - 知识点一: ==ES6对于对象内函数的简写方式,这样理解data的写法了==
  - 知识点二: **data(){...}是固定写法**,内部返回一个对象,数据是一些变量的状态,这些vue变量返回出去,可以在其对应的根节点领域内使用,最简单就使用`{{}}`体现,==记得是变量,不是字符串,别乱加""==
  - 代码:
    ```
    <!-- 双花括号 , vue会把里面的东西当作js来运行 -->
    <!-- 既然是js领域,那么变量也可以放入执行 -->
    <div id="box">
        <!-- 注意: 不要加"" , 那是字符串,不是变量 -->
        <!-- 而myname需要提前定义,下面的createApp中 -->
        myname : {{myname}} 
    </div>
        // ES6的知识点
        // 对象的简写
        //     {
        //         a : 1,
        //         b : 2,
        //         getA : function(){....}   ------> ES6 : getA(){....}
        //     }

        Vue.createApp({
            data(){
                return {
                    myname  : "kerwin" // 状态,html会随着这里改变而改变,这就是响应式数据的体现
                }
            }
        }).mount("#box")
    ```
### vue配置标签属性 v-bind:
- ==控制标签属性的vue语法:==  `v-bind:` (意为vue指令) **简写:   `v-bind:` 为 `:`**
- 具体语法 `v-bind:属性名 = "vue变量(js代码区)"`
- 属性名是任意的都可以,比如`id class src style` 
- 简要介绍代码区块:
  - vue变量型 :  `v-bind:class=color` ==color作为变量在data(){}定义好值了==
  - js代码区型 : `v-bind:class=" isLogin?'red':'yellow' "` ==运用三目运算选择red或yellow字符串,而isLogin在vue区进行定义true或false==
  - 组合式vue变量型 : `v-bind = "imgObj"` ==imgObj在vue区定义好了此标签的一些属性,注意这里不能乱改名字了==
  - ==布尔型注意事项: 略,有关于""的问题==
- 代码:
  ```
    <style>
        .red{
            background-color: red;
        }
        .yellow{
            background-color: yellow;
        }
    </style>


    <!-- 控制标签属性的vue语法 v-bind: (意为vue指令)-->
    <!-- 简写: v-bind: 为 : -->
    <div id="root">
        <!-- v-bind:js地盘 , 动态绑定,内部的js代码可以响应式变化 , 可以通过app代理完成数据响应式更改 
        color被当作变量,而变量color在vue中定义为"red" -->
        <div v-bind:class=color>111111</div>
        <!-- isLogin三目运算 , 单引号是因为外面有双引号了, red和yellow在这里代表字符串 -->
        <!-- isLogin = false  选择yellow字符串 , 最后即为 class = "yellow" -->
        <div v-bind:class="isLogin?'red':'yellow'">22222</div>
        <!-- 简写: v-bind: 为 : -->
        <!-- 支持绑定所有属性 src href id style ...-->
        <img :src="url" alt="" :width="width">
        <!-- 在控制台 通过app.url = 新url 可以实时修改图片 -->

        <!-- vue 支持动态绑定多个值 -->
        <img v-bind = "imgObj">

        <!-- 注意: 动态绑定下布尔值的问题 -->
        <!-- 动态绑定下, 你带个双引号无所谓,会自动转化为 disabled = false (可以点击)-->
        <!-- 你如果正常写,给false变成字符串了,那么disabled功能就失效了,即 disabled = "false" X  disabled = false V -->
        <button :disabled="isDisabled">click</button>

    </div>
    <script>
        var obj = {
            data(){
                return {
                    isLogin : false,
                    color : "red",
                    url : "https://static.maizuo.com/pc/v5/usr/movie/878f3f2dc9ad07a08d37f2fe5affbc32.jpg?x-oss-process=image/quality,Q_70",
                    width : 300,
                    isDisabled : false,
                    // 绑定多个值
                    imgObj:{
                        // 内部的属性名不能乱写了,img标签内部有什么属性,就写什么属性
                        src : "https://static.maizuo.com/pc/v5/usr/movie/91212ec9eb28b3f163984d77f77a4da9.jpg?x-oss-process=image/quality,Q_70",
                        width : 300
                    }

                }
            }
        }
        // div-root内的所有vue代码 代理给app变量了, 通过app.属性 可以实时修改数据(响应式)
        var app = Vue.createApp(obj).mount("#root")
    </script>
  ```
### vue绑定事件 v-on (methods:{}配置)
- vue绑定事件 : 之前js绑定事件,获取dom对象,然后进行dom.onclick = Func(){} / Func名字 进行绑定(或者addEventListener()) , ==在vue中绑定语法为`v-on绑定事件类型 = "Func()"`== , **简写: v-on ---> @**
  > 注意: 
  > 1.==绑定事件名不是onclik,是addEve的click写法==,之前学的所有事件名都是如此
  > 2.函数名字加不加双引号都行,**加不加()也都行,但是加()是为了传参,如果不需要传参是可以不加的**
- **==methods:{}配置==**
  - **我们给==事件绑定的处理函数==就都放在这里**,==这样我们的选项式vue配置项就齐全了==,如下
  - 代码:
      ```
          // vue 配置
          var obj = {
              // 这里写数据
              data(){
                  return {
                      myname : "kerwin",
                      变量 : 值,
                      .....
                  }
              },
              // 这里面写函数
              methods:{ 
                  handlerClick(){
                      ....
                  },
                  函数名(){
                      函数内容
                  },
                  .....
              }           
          }
          // 创建一个vue3并赋值给app ,看过vue3响应式数据底层逻辑后,app得到的是一个proxy代理对象
          var app = Vue.createApp(obj).mount("#root")
      ```
- methods内的this值:==指向为实例化对象proxy的值,就是外面app的值==
  **即通过this我们可以获取到data(){...}内的数据值,只要this.名字即可获取,这样我们就可以在响应函数内操控它们了**
- ==下面代码的操作==: (通过处理函数的this调用)
    - 改变变量的值从而改变页面的内容 {{myname}}
    - 改变变量的值使得标签指向不同的class,从而改变其css属性, :style
    - 改变isShow的布尔值,从而改变三目运算结果,影响其class,进而改变其css `:class="isShow?'':'hidden'`
- 代码:
  ```
    <style>
        .hidden{
            display: none;
        }
    </style>

    <!-- vue绑定事件 -->
    <!-- v-on:click = Func (意为监听click事件,click不能改,监听什么事件就写什么,Func作为函数名字随意) -->
    <!-- 简写 @  即 @click = Func -->
    <div id="root">
        {{myname}}
        <!-- <button onclick="handlerClick()">click</button> -->
        <!-- Func加不加括号都行,加括号更多的是为了传参 -->
        <button @click=handlerClick()> click vue </button>
        <div :style="color">颜色板</div>
        <!-- 如果isShow是true 那么就没有class样式,默认显示 ; 如果为false,就会是hidden (单引号意为这个hidden是字符串而非变量) -->
        <div :class="isShow?'':'hidden'">我是显示或者隐藏</div>
    </div>

    <script>
        // vue官方支持写法(选项式写法)
        var obj = {
            // 这里写数据
            data(){
                return {
                    myname : "kerwin",
                    color : "background-color : red",
                    isShow : true
                }
            },
            // 这里面写函数
            methods:{ 
                handlerClick(){
                    console.log("click");
                    console.log(this); // this: 指向为实例化对象proxy的值,就是外面app的值
                    this.myname = "你好 世界!" // this.myname = app.myname
                    this.color = "background-color : yellow"
                    this.isShow = false // 或 this.isShow = !this.isShow
                }
            }           
        }
        var app = Vue.createApp(obj).mount("#root")
    </script>
  ```
### 初学 v-show/if/for 语法糖
- 3个新指令 ==**v-show , v-if , v-for**==
- ==1.v-show== 
  - 语法 : `v-show = "isShow"` isShow就是个自定义的名字
  - ==isShow为true 就显示 , 为false就隐藏==
  - ==isShow就作为vue的data(){}内部的一个变量==
  - 代码: `<div v-show="isShow">我是显示或者隐藏</div>`
  > 注意: 隐藏即为display: none 这种情况下标签不占位 
- ==2.v-if==
  -  语法: `v-if="isShow"` ,同理如果isShow条件为true就渲染它,如果条件为false,直接删除这个节点
  -  ==相比于隐藏,它是在代码层面上直接没了,在控制台的源代码中,这行代码注释为v-if了==
  - 代码: `<div v-if="isShow">我是创建或删除</div>`
> 注意: 1.v-if和v-show后面是表达式,函数,三目等都可以,最后要的是结果true或false,
> 2.v-if相对于v-show更懒,v-if如果不成立,对于那个标签是直接不创建的,而v-show无论如何都是先创建出来,再根据条件,选择是否对其隐藏(display),所以v-if有更高的创建开销,v-show有更高的初始渲染开销
- ==3.v-for==
  - 语法 : `v-for = "(item,index) in Array" `,==**不只是针对数组数据,这里以数组为例子**==
  - ==两个参数,第一个是值,第二个是索引下标(从0开始)==
  - 解释: 每次遍历Array,把每一项的内容和索引下标存入临时变量item和index,再次遍历到下一项时,item和index也会随之更新
    > item,index作为临时变量,只能在此标签中访问到它们
  - 代码:
    ```
        <ul>
            <li v-for="(item,index) in list">
                {{index + "---" + item}}
            </li>
        </ul>
    ```
### 增加,删减表单案例06 + v-model 语法糖
- v-model:  ==意为在input中每次输入东西就会把内容传递给mytext, 而mytext是vue区data(){}区块的一个变量,它可以快速获取input内的value值,无需dom对象等复杂操作,**同时methods代码中也使用evt.target这个原生js方法获取相同的值(看看即可)**==
- 语法: `v-model= "mytext"`
- 这是一个双向绑定指令, 意为==双向意味不仅是input输入框内的信息会更改mytext的值,而且反向也能改,如果通过app.mytext赋值等方式给mytext的值更改,那么会同样映射到输入框中==
- 代码: `<input type="text" v-model="mytext">`
- 具体代码:
  ```
    <!-- 增加,删减表单案例 -->
    <div id="root">
        <!-- 提示: input事件是输入框内容发生改变时触发 -->
        <!-- <input type="text" @input="handleInput">  -->

        <!-- 表单控件绑定 -->
        <!-- vue 语法糖 v-model= "mytext" -->
        <!-- 双向绑定指令: 在input中每次输入东西就会把内容传递给mytext -->
        <!-- 注意: 双向意味着反向也能改,如果通过app.mytext等方式给mytext的值更改,那么会同样映射到输入框中 -->
        <input type="text" v-model="mytext"> 
        <button @click="handleAdd">add</button> 
        <!-- mytext : {{mytext}}  -->

        <!-- 最初始的页面渲染,通过for遍历数据数组渲染页面,缺点是每次都要重复把所有数据渲染一次 -->
        <ul>
            <li v-for="item,index in datalist">
                {{item}} <button @click="handleDel(index)">del</button>
            </li>
        </ul>

        <!-- v-show -if -on 等 后面可以放表达式的 -->
        <!-- 后面的那个表达式成立就为true(数组为空就显示),不成立就为false(数组不为空就隐藏),使用表达式表示true与false -->
        <div v-show="datalist.length===0">暂无数据</div>
    </div>

    <script>
        var obj = { 
           data(){
                return {
                    mytext: "",
                    datalist: ["111","222","333"],
                }
           },
           methods:{
                handleAdd(){
                    // console.log(this.mytext)
                    if(this.mytext === ""){ // 不写东西就不添加
                        return 
                    }else{
                        this.datalist.push(this.mytext)
                        this.mytext = "" // add后清空输入框,双向绑定的优势体现出来了
                    }  
                },
                // handleInput(evt){
                //     // js原生方法
                //     // 可以拿到一个input事件对象(没传参默认有)
                //     // 通过寻找事件源间接找到了事件对象,然后找到其value
                //     console.log(evt.target.value);
                //     this.mytext = evt.target.value
                // },
                handleDel(index){
                    // console.log("del",index);

                    // 提示: array.splice(a,b) 删除数组项的工具,返回删除后的数组
                    // a是索引(从0开始) b是从a这个索引开始删除几个
                    this.datalist.splice(index,1)
                    // 删除完成后datalist数据改变,根据响应式数据特点,页面又会重新渲染1次,同时更新绑定的del按钮和其index值,不影响下次删除
                }
           } 

        }
        var app = Vue.createApp(obj).mount("#root")
    </script>
  ```
### 总结createApp().count()基本用法(选项式)
- 代码:
  ```
    <script src="../线上vue.js代码复制/vue.js"></script>

    <body>
    <div id="root">
        .....
    </div>

    <script>
        
        var obj = {
            data(){
                return {
                    ....
                }
            },
            methods:{
                .....
            }
        }

        var app = Vue.createApp(obj).mount("#root")

    </script>
    </body>
  ```
- 1.最上方引入vue本地文件
- 2.html设置根节点,内部正常写html代码,根节点为了mount挂载用
- 3.创建vue3 app , 这是一个proxy对象,这不重要
- 4.配置obj和挂载count , obj的数据在挂载区域内使用
- 5.obj配置 分为data区 和 methods区 , data区定义变量 , methods区定义函数 , 主要是事件处理函数
- 6.跟节点内部使用 v-... 或 {{}} 等vue语法 , 再结合着obj配置一起使用, 简单实现vue3的功能

## Vue基础(非项目结构)
### v-html
- v-html: ==可以识别html语法,并加载在页面中==
- 语法: `<div v-html="myhtml"></div>` ,在data(){}中去定义myhtml的值
- ==**具有风险性:**==
  - ==如果用户在代码片段内部写一些**攻击脚本(js)**,引入后很危险==,要确保这个给你数据的网站是安全的,所以官方也就限制了{{}}的使用,同时提供了v-html给你自己选择使用
  - ==自己人写的后端给的数据可以这么用,但面对外来用户的数据就不能使用了==
- 代码:
    ```
        <div id="root">
            <!-- {{myhtml}}  -->
        </div>

        <script>
            
            var obj = {
                data(){
                    return {
                        // ``模板字符串发送
                        myhtml : `<b>123</b>` // 带代码片段的
                    }
                },
                methods:{

                }
            }

            var app = Vue.createApp(obj).mount("#root")
        </script>
  ```
### class绑定
- ==对象写法(前面用过)==: `<div :class="classObj">123456</div>`
> 1.在classObj内部配置关于class的信息,之前我们在img上用过,配置了img的src,width,height多个属性
> 2.可以通过app.classObj.XXX = "" 实时添加属性和值,同时页面会随之改变,这就是vue3响应式数据底层逻辑的优势,proxy针对的是对象,vue2很麻烦的
- ==数组写法== : `<div :class="classArr">asdsas</div>`
> 1.配置classArr = [{...},{...},{...},....],每一个对象都是对属性的配置,==内部不一定是对象,主要看外面承接的是谁,就比如这里的数组是字符串数组,配置给class用==
> 2.通过app给数组push新内容,就会实时更新页面中相关数据,同理的pop unshift等更改数组内容的都有效,==但是map,filter,slice不改变数组内容,返回新数组的这种方法无效,后面在数组变动检测中会讲==
> 3.==这里的写法都是简洁写法,你可以直接把对象,或者对象数组堆在div 标签里面,但是显得代码冗余,所以使用了中间变量代替了==
- 代码:
  ```
        <style>
        .aaa{
            background-color: red;
        }

        .bbb{
            color: yellow;
        }

        .ccc{
            font-size: 25px;
        }
    </style>
    
    <div id="root">
        <!-- 对象写法 -->
        <div :class="classObj">123456</div>

        <!-- 数组写法 -->
        <!-- <div :class="['aaa','ccc']">asdsas</div> -->

        <div :class="classArr">asdsas</div>
    </div>

    <script>
        
        var obj = {
            data(){
                return {
                    classObj: { // 代表aaa ccc 会挂在class上
                        aaa:true,
                        bbb:false,
                        ccc:true
                    },
                    classArr: ["aaa","bbb"],
                }
            },
            methods:{

            }
        }

        var app = Vue.createApp(obj).mount("#root")
    </script>
  ```
### style绑定(和class一样)
- 对象写法: `<div :style="styleObj">asdfasdf</div>`
> 注意: 
> 1.配置styleObj属性时,推荐使用**驼峰写法**,==在js中没有 background-color这种变量书写方式,所以你要给back...再加个引号,麻烦,直接使用驼峰==
> 1.1在styleObj对象内部配置时的具体体现 : 
> 'background-color' : "red" ---> backgroundColor : "red"
> 2.依旧可以动态改变内部值, app.styleObj.xxx = xxxx

- 代码:
  ```
    <div id="root">
        <div :style="styleObj">asdfasdf</div>
        <div :style="imgObj"></div>
        <button @click="handleAjax">click</button>

    </div>

    <script>
        // url : https://static.maizuo.com/pc/v5/usr/movie/878f3f2dc9ad07a08d37f2fe5affbc32.jpg?x-oss-process=image/quality,Q_70
        
        var obj = {
            data(){
                return {
                    // 每个对象同时配置多项数据
                    styleObj : {
                        backgroundColor : "pink",
                        fontSize : "20px"
                    },
                    imgObj : {
                        width : "200px",
                        height : "200px",
                        backgroundSize : "cover",
                    }
                }
            },
            methods:{
                handleAjax(){ // 没有ajax,模拟一种点击后,出现图片的效果
                    this.imgObj.backgroundImage = "url(https://static.maizuo.com/pc/v5/usr/movie/878f3f2dc9ad07a08d37f2fe5affbc32.jpg?x-oss-process=image/quality,Q_70)"
                    // console.log(123);
                },
            }
        }

        var app = Vue.createApp(obj).mount("#root")
    </script>
  ```
- 数组写法1: `<div :style=[styleObj1,styleObj2]>asdfasdf</div>`
  - styleObj1/2在data里是对象, `{} {}`
- 数组写法2: `<div :style=imgArr></div>`
  - imgArr在data里是对象数组,`[{},{},{}]`
> 1.依旧可以使用数组方法push,pop等改变页面(==同理不包括map filter这种不改变数组数据的方法==)
> 2.push新内容后,如果有重复,后面会覆盖前面

### v-if v-else-if v-else + template
- ==v-if v-else-if v-else:==
- 类似于js `if - elseif(可多个) - else`,我们也在v-if基础上添加相同的if逻辑链条,功能是一样的,不多赘述
  
- 代码:(根据state状态码判断添加哪一个div数据)
  ```
    <div id="root">
        <!-- 没有通过if判断的另外两个div压根不会创建,再代码中根本没有,节省了机器的性能消耗 -->
        <ul>
            <li v-for="(item) in datalist">
                {{item.title}}
                <div v-if="item.state === 0">
                    <b>未付款</b>
                </div>
                <div v-else-if="item.state === 1">
                    <b>已完成</b>
                </div>
                <div v-else>
                    <b>等待付款</b>
                </div>
            </li>
        </ul>
    </div>

    <script>
        
        var obj = {
            data(){
                return {
                    // 后端传递的数据里,state是状态码,需要我们再具象化一点,比如 0 代表未付款 1代表已完成 2代表等待支付
                    datalist : [
                        {
                            title : "aaa",
                            state : 0
                        },
                        {
                            title : "bbb",
                            state : 1
                        },
                        {
                            title : "ccc",
                            state : 2
                        }
                    ],

                }
            },
            methods:{

            }
        }

        var app = Vue.createApp(obj).mount("#root")
    </script>
  ```
- ==template==: 包装元素(==无论如何自己是不会显示在代码层面的==)
  - 当isShow为true时,template会把包裹的内容显示,自己消失,
  - 若为false,就都不显示
    > 1.==template的内部包装元素显示与否,**与v-if的结果相关**==
    > 2.==可以与v-if v-for 搭配使用,后面解决v-for + v-if搭配问题时很有用==
    > 3.将多个元素包装在一起同生共死,省的一个个单独包装了,并且template自己不影响别人
- 代码:
  ```
        <template v-if="isShow">
            <div>111</div>
            <div>222</div>
            <div>333</div>
        </template>
  ```
### v-for
- v-for拓展:
  - 1.解构功能: `item -> {title,state}` 
  `v-for="({title,state},index) in datalist"`
  ==把datalist这个对象数组的每一项对象的内部解构出来了==
  - 2.in<===>of (js迭代器 kerwin的ES6的课)
  `v-for="item in Obj"`等于`v-for="item of Obj`
  - 3.支持对象key,value遍历,==直接提取每一项对象的key与value==
   `v-for="(value,key,index) of Obj" // 代表 值,key,索引`
  - 4.遍历数字,特殊地从1开始,没啥用
    `v-for="item in 10" // 会打印li+(1~10)`

### v-if与v-for组合 + template
- ==**首先v-if v-for 同时作用于同一个标签是不可以的**==
    - 形如 `v-for="({title,state},index) in datalist" v-if="state===current"` 
    - ==问题: v-if根本识别不了v-for内的变量==
- 解决: ==使用template分开v-if和v-for==

- 同时由于template的特殊性(无论如何都不显示在代码层面),结合v-if,v-for可以对之前的案例进行优化,使用v-if减少了dom的创建
- 代码:
  ```
    <div id="root">
    ------------------------------------------------
        <!-- 这里还学选下拉式列表,select功能省略,写死了 -->
        <!-- 选项 current = 0 -->
    ------------------------------------------------
        <!-- 问题: v-for内部变量出不来,v-if识别不了v-for内部的变量 -->
        <!-- <ul>
            <li v-for="({title,state},index) in datalist" v-if="state===current">
                {{title}}----{{index}}
            </li>
        </ul> --> 
    -------------------------------------------------
        <!-- 使用template分开v-if和v-for,这样v-if可以识别到v-for内的数据了
        还有一个缺点,li会被先创建出来,tem + v-if只能影响li内部内容的创建,这样还是浪费资源-->
        <!-- <ul>
            <li v-for="({title,state},index) in datalist">
                <template v-if="state===current">
                    {{title}}----{{index}}
                </template>
            </li>
        </ul> -->
    -------------------------------------------------
        <!-- tem + v-for 组合 -->
        <!--如下,tem包装元素是不显示在代码层的,所以li通过v-if的审查,能创建就创建,不能创建,tem也不会影响代码层,减少创建损耗 -->
         <ul>
            <template v-for="({title,state},index) of datalist">
                <li v-if="state===current">
                    {{title}}---{{index}}
                </li>
            </template>
         </ul>

        <!-- 上面的功能也可以后期使用Filter方法过滤(js领域) -->
    </div>

    <script>

        var obj = {
            data() {
                return {
                    // 后端传递的数据里,state是状态码,需要我们再具象化一点,比如 0 代表未付款 1代表已完成 2代表等待支付
                    datalist: [
                        {
                            title: "aaa",
                            state: 0
                        },
                        {
                            title: "bbb",
                            state: 1
                        },
                        {
                            title: "ccc",
                            state: 2
                        }
                    ],
                    current: 0,

                }
            },
            methods: {

            }
        }

        var app = Vue.createApp(obj).mount("#root")
    </script>
  ```
### v-for的key值设定
- vue如何更新数组数据? 
  - vue采用"==就地更新=="策略,==按照索引更新数据,修改数组后,按照索引进行打补丁==,相同项复用,不同项就修改,新增项就添加,删减项就删除
  - **但是这个基础逻辑对于在数组中插入数据的操作没有人为使用数组插入语法简单**,比较死板,如果在数组插入数据,使用数组插入工具更新一次即可,而按照vue逻辑,就要多次修改后面的内容

- vue如何解决"就地更新"的短板?
  - 为此,==vue使用了key值作为识别每一项的标识,通过唯一的id进行对比,并使用了diff算法,极大优化了过程==,达到了"顺序不同就排序,插入就根据两侧id直接插入,多了少了就添加删除"效果,尽最大努力复用数据,重新排序,直接插入,从而减少性能损耗
  - **而id作为识别数据的关键,一般来自后端的SQL库的id数据,==达到不重复效果==**
  - ==这种操作往往使用在数据量极大的列表操作==,大量的li删减修改添加,需要vue辅助,提升性能

- vue检查dom改变的底层逻辑: 
  - ==虚拟dom : vue中在代码与真实dom对象之间有一层"虚拟dom"区域,内部是js对象,存储着dom的基本信息==,**由于js原生代码比dom创建要快的多,所以vue首先在虚拟dom层对比两者的变化,然后给被修改者打补丁,最后重新根据打过补丁的虚拟dom重新渲染dom对象**-->
  - 优点 : 减少dom的创建,节省了计算机渲染dom的时间; 使用原生js对比数据,加快了对比速率,性能更好了
- 给v-for添加key值的语法: `v-for="({title,state,id},index) in datalist" :key="id"` ==即:key="xxx"==
- 代码:
  ```
    <div id="root">
        <ul>
            <!-- 给每个li添加id , :key="..." -->
            <li v-for="({title,state,id},index) in datalist" :key="id">
                title:{{title}}----index:{{index}}---id:{{id}}
                <div v-if="state === 0">
                    <b>未付款</b>
                </div>
                <div v-else-if="state === 1">
                    <b>已完成</b>
                </div>
                <div v-else>
                    <b>等待付款</b>
                </div>
            </li>
        </ul>
    </div>

    <script>
        var obj = {
            data() {
                return {
                    // id : 来自后端SQL唯一标识信息
                    datalist: [
                        {
                            title: "aaa",
                            state: 0,
                            id : 1
                        },
                        {
                            title: "bbb",
                            state: 1,
                            id : 2
                        },
                        {
                            title: "ccc",
                            state: 2,
                            id : 3
                        }
                    ],
                }
            },
            methods: {

            }
        }

        var app = Vue.createApp(obj).mount("#root")
    </script>
  ```
### 数组变动侦测
- 根据vue的底层逻辑(proxy),只有原数组发生改变才会实时改变页面相关数据
- ==对于数组改变的操作形如 push pop unshift shift 等是可以被检测到的,但是对于 map concat filter slice concat 等**对原数组不产生影响的,而是返回一个新数组**==
- **所以vue只能采取下面的方法,重新赋值以达到数组改变,从而渲染页面** `this.datalist = this.datalist.map(item=>"kerwin + " + item)`
- 代码:
    ```
    <div id="root">
        <ul>
            <li v-for="item in datalist" :key="item">
                {{item}}
            </li>
        </ul>
        <button @click="handleClick">click</button>
    </div>

    <script>
        var obj = {
            data(){
                return {
                    datalist : ["aaa","bbb","ccc"]
                }
            },
            methods:{
                handleClick(){
                    // this.datalist = this.datalist.map(item=>"kerwin + " + item)
                    this.datalist = this.datalist.concat(["123","456"])
                }
            }   
        }

        var app = Vue.createApp(obj).mount("#root")
    </script>
    ```
### 模糊搜索案例015
- ==提示:==
  - `str.includes("xxx")` 如果字符串xxx在str字符串内有匹配,则为true,否则为false
  - `array.filter(item=>表达式)` 表达式结果为true,此item保留; 表达式为false,此item删除,item为遍历array数组的每一项数据,==返回值为筛选好的数组(原数组不变)==
  - `v-model="mytext"`: 输入框内容就在mytext内部,双向响应数据
- ==方法1(v-for + v-if + template 模板化)==
- 代码:
  ```
        <div id="root">
        <!-- v-model -->
        <input type="text" v-model="mytext">
        <ul>
            <!-- 纯模板方案 -->
            <!-- item.includes("xxx")  -->
            <template v-for="item in datalist" :key="item">
                <li v-if="item.includes(mytext)">{{item}}</li>
            </template>
        </ul>
    </div>

    <script>
        
        var obj = {
            data(){
                return {
                    mytext : "",
                    datalist : ["aaa","bbb","aca","bca","abc","bbc","cab"]
                }
            },
            methods:{

            }
        }

        var app = Vue.createApp(obj).mount("#root")
    </script>
  ```
- 方法2: (==@input事件绑定 + 数组变动侦测解决方案 浪费点内存==)
- 代码:
  ```
         <div id="root">
        <!-- v-model -->
        <!-- filter + @ -->
        <input type="text" v-model="mytext" @input="handleIpt">
        <ul>

            <li v-for="item in datalist" :key="item">
                {{item}}
            </li>
        </ul>
    </div>

    <script>

        var obj = {
            data() {
                return {
                    mytext: "",
                    datalist: ["aaa", "bbb", "aca", "bca", "abc", "bbc", "cab"],
                    baklist : ["aaa", "bbb", "aca", "bca", "abc", "bbc", "cab"]
                }
            },
            methods: {
                handleIpt(){
                    // 有许多种方法解决,这里学最简单的复制方案.后面会学新的 (浪费点内存)
                    // 复制一份baklist,由于筛选方法不影响原数组,所以baklist永远不会有所变化,有筛选条件就更新,没有条件就原样还给datalist
                    this.datalist = this.baklist.filter(item=>item.includes(this.mytext))
                }
            }
        }

        var app = Vue.createApp(obj).mount("#root")
    </script>
  ```
- 方法3:(==针对方法2的改进,函数表达式方法==)
- ==之前讲过 {{}} 以及 v-XXX系列后面的领域是js地盘,那么我们在v-XXX内部可以插入methods定义的函数来实现默写功能==
- 代码:(==**仔细看注释**==)
  ```
    <div id="root">
        <input type="text" v-model="mytext">
        <ul>
            <!-- test()是执行函数 test是打印函数, 两者不一样 -->
            <!-- 实现原理: 提前在test()函数内把数组筛选完成并返回筛选后的数组,然后直接就按照筛好的数组创建li就可以了 -->
            <li v-for="item in test()" :key="item">
                {{item}}
            </li>
        </ul>
    </div>

    <script>

        var obj = {
            data() {
                return {
                    mytext: "",
                    datalist: ["aaa", "bbb", "aca", "bca", "abc", "bbc", "cab"],
                }
            },
            methods: {
                test() {
                    // 同理,每次返回出去的数组都是筛选好的数组,但是filter对原数组是没有影响的,所以datalist是不会变的
                    // 相对于方法2节省了一部分内存
                    return this.datalist.filter(item => item.includes(this.mytext))
                }
            }
        }

        var app = Vue.createApp(obj).mount("#root")
    </script>
  ```
### 事件处理器
- **给标签绑定事件处理函数的几种写法**
- ==内联写法==(适用于简单的计算,比如简单的表达式,三目,+-*/等,单行)
  `<button @click="count++">add+1</button> {{count}}`
- ==函数写法==
  - **不带()的写法** (==vue会偷偷自动给你的函数传递一个事件对象evt==)
    ```
    html内部:
    <button @click="handleClick2">click1</button>

    vue - methods内部 :
    handleClick2(evt){
        console.log(evt);
    }
    ```
   - **带()的写法** (==可以传递参数,同时也可以传递事件对象evt,不过严格规定了写法,为 **$event**==)
        ```
            html内部:
            <button @click="handleClick3(1,2,$event)">click2</button>

            vue - methods内部 :
            handleClick3(a,b,evt){
                console.log(a,b)
                console.log(evt)
            }
        ```
    > 注意: ==evt在函数中的主要作用是阻止事件默认行为==,比如"冒泡行为",evt.stopPropagation(),或者提交表单等默认行为
### 事件处理修饰符
- 偷懒的修饰符语法可以用较少的代码实现复杂的功能,相对于js获取dom后,在进行的多种繁琐操作,vue只需在事件触发后加点语法后缀即可实现相同功能
- .self : ==只有事件源是自己触发才执行函数,别人冒泡上来的不算(事件源是孩子节点),**间接地阻止了"冒泡"(加在父节点身上)**==
- .stop : ==在事件前添加事件修饰符,阻止默认行为,**能直接阻止冒泡行为(加在子节点身上)**==
    - **冒泡事件解释与代码实例**
    > 冒泡: 子节点的行为会冒泡到父节点上,触发同样的事件处理函数,例如点击子节点,"点击"这个行为会冒泡到父节点上,如果父节点有click事件处理函数,那么就会被执行,下面是例子
    ```
    <!-- 测试.self 只接受父节点行为,间接阻止"冒泡"-->
    <div @click.self="handleClick1()">
        <!-- 测试.stop 阻止"子节点冒泡"默认行为  -->
        <button @click.stop="handleClick2()">111</button>
        <button @click="handleClick3()">222</button>
    </div>
    ```
- @submit.prevent : ==阻止表单提交行为,**可以借此检查表单提交的数据**==
  ```
    <form action="" @submit.prevent="handleSubmit()">
        <button type="submit">登录</button>
    </form>

    handleSubmit(){
        // 不阻止默认提交事件,会跳转网页,下面的打印会一闪而过
        // 写了后,就会停在这里,如此就可以在这里进行表单数据提取与测试了
        console.log("submit")
    }
  ```
- .once : 一次性使用
  - 只能不带()的函数使用: `<button @click.once="handleClick4">抽奖</button>`
  - 如果带()函数使用,就曲线实现功能如下
    ```

        html :
        <button @click="isOnce && handleClick5()">抽奖2</button>

        vue - data :
        isOnce: true

        vue - methods : 
        handleClick5() {
            console.log("抽奖2");
            this.isOnce = false
        }

    ```
- .passive(在js也没见过的一个属性): ==一般用于触摸事件的监听器(就是移动端,手机平板这类),改善移动端设备的滚屏性能,**阻止系统自动监听"滚动时是否有阻止事件"这种无谓操作**==,因为一般我们都不会去写阻止事件,但是系统就会默认去检查有没有,所以很浪费性能,写了这个后,就不会检查了,**但是用了.passive就不要在浏览器里写.prevent了,会报错的**
- ==简而言之,告诉浏览器,你可以不用去查询程序有没有阻止默认事件,反正我也没写==

### 模态框案例018
- 模态框: 点击后出现一个框,此网页其他的部分变为半透明暗色,同时点击这些部分或者在框内点击关闭按钮,会直接退回到原网页
- ==案例主要应用知识点: **应用.self或.stop阻止冒泡,去实现功能**==
- 代码:
  ```
    <div id="root">
        <button @click="isShow=true">模态框</button>
        <!-- 阻止冒泡行为, 可以在overlay的click.self,也可以在center上写个@click.stop vue命令,不用写具体内容了 -->
        <div id="overlay" v-show="isShow" @click="isShow=false">
            <div id="center" @click.stop>
                用户名 : <input type="text">
                <button @click="isShow=false">登录</button>
            </div>
        </div>
    </div>

    <script>
        
        var obj = {
            data(){
                return {
                    isShow: false
                }
            },
            methods:{

            }
        }

        var app = Vue.createApp(obj).mount("#root")
  ```
### 表单输入绑定 v-model与input
- ==记录选项状况:(单选,多选都一样,下面以多选为例)==
  `<input type="checkbox" v-model="isChecked">记住用户名`
    > ==1.isChecked是状态,**与input-checkbox绑定的**==
    > ==**2.复选框的选择影响状态的isChecked布尔值**==,
    > ==3.v-model会记录isChecked布尔值,判断复选框是否被勾选==
    > ==4.此过程节省了js获取dom再判断的繁琐过程==
- **==input系列==**
  - **==复选框系列input-checkbox==**
  - 代码:
    ```
    <div>
        <input type="checkbox" v-model="favList" value="篮球">篮球
        <input type="checkbox" v-model="favList" value="足球">足球
        <input type="checkbox" v-model="favList" value="排球">排球
    </div>

    // 在vue-data里面 : favList是一个空数组如下
    data(){
        favList: []
    }

    ```
    > 1.==每次点击一个复选框,v-model就会把对应此复选框的value值放入数组,取消点击就会删除==
    > 2.==**数组内的value顺序与点击顺序有关**==
  - ==**单选框系列input-radio**==
  - 代码:
    ```
    <div>
        <!-- 数组+value+picked picked即所选的value 记录选择情况 -->
        <input type="radio" v-model="picked" value="篮球">篮球
        <input type="radio" v-model="picked" value="足球">足球
        <input type="radio" v-model="picked" value="排球">排球
        <button>提交</button>

        // 在vue-data里面 : picked是一个空字符串如下
    data(){
        picked : ""
    }
    </div>
    ```
    > 1.==由于单选框只选择一个,所以用不上数组,一个空字符串变量即可==
    > 2.==同理复选框,v-model会把单选的value赋值给picked==
- ==**select系列 select + option**==
  - ==相对于input,select系列更加聪明,即使不写value,selected也会读取option的innerHTML去获取,**当然还是建议写value**==
  - 代码:
    ```
    <select v-model="selected"> 
        <option value="篮球v">篮球</option>
        <option value="足球v">足球</option>
        <option value="排球v">排球</option>
    </select>
    ```
    > 1.select+option是下拉列表选项,只能选一个,所以同radio-input,使用空字符串变量即可
    > 2.其余同理,value会被赋值给selected
### 订单筛选器案例019_2
- 案例解释: 使用下拉列表选项框选择对应条件的数据,==此案例是对商品进行4种分类,选择对应种类后,页面会更新为此条件商品的列表集合==
- 案例使用知识: 
  - ==select+option+v-model的表单输入绑定==
  - ==对select,动态绑定value值,**:value,温故"动态绑定的领域为js领域"这一概念,巧妙完成了字符串->数字的转化**==
  - ==template + v-for + v-if的使用(减少无谓dom创建,提高性能,**这里的减少无谓dom创建指的是不符合条件的商品不会被创建出来**)==
  - ==使用了ES6解构了对象数组==
  
- 代码:
  ```
    <div id="root">

        <h2>订单筛选</h2>
        value: {{selected}}
        <div>
            
            <!-- 对全部订单单独if判断下 -->
            <select v-model="selected">
                <!-- state是数字num 所以value这里加:(动态绑定) 意味着后面双引号内部是js领域,"0"不在是字符串0,而是js中的数字0 -->
                <!-- === "值与类型"都匹配,所以这里要让value的值为num,使得渲染时v-if能够正常运行 -->
                <option value="all">全部订单</option>
                <option :value="0">未付款</option>
                <option :value="1">已取消</option>
                <option :value="2">待发货</option>
                <option :value="3">已完成</option>
            </select>
        </div>

        <!-- 判断商品是否要被创建 v-if -->
        <ul>
            // ES6解构赋值 
            <template v-for="({title,state},index) of datalist">
                <!-- 只渲染state符合selected条件的商品 -->
                <li v-if="state===selected">
                    {{title}}
                </li>
                <!-- 'all' 就是字符串all,全部商品都渲染  -->
                <li v-if="selected==='all'">
                    {{title}}
                </li>
            </template>
        </ul>
    </div>

    <script>

        var obj = {
            data() {
                return {
                    // selected默认值
                    selected: "all",
                    // 后端发来的数据
                    datalist: [
                        {
                            title: "手机1-未付款",
                            state: 0
                        },
                        {
                            title: "手机2-未付款",
                            state: 0
                        },
                        {
                            title: "电视1-已取消",
                            state: 1
                        },
                        {
                            title: "电视2-已取消",
                            state: 1
                        },
                        {
                            title: "冰箱1-待发货",
                            state: 2
                        },
                        {
                            title: "冰箱2-待发货",
                            state: 2
                        },
                        {
                            title: "洗衣机1-已完成",
                            state: 3
                        },
                        {
                            title: "洗衣机2-已完成",
                            state: 3
                        },
                    ]
                }
            },
            methods: {

            }
        }

        var app = Vue.createApp(obj).mount("#root")
    </script>

  ```
### 购物车案例020(大复习)
- 购物车案例实现的功能有:
  - 复选框点击商品后,自动计算器金额,同时改变数量后,同步金额变化
  - 全选/全不选 与 单个选项框的"联动",==这是个双向功能,要分别写两个函数==
  - 删除商品按钮(06学过),==同时与全选系列联动==
- 案例知识点:
  - ==input-checkbox复选框知识点==
  - ==计算金额sum 使用reduce原生js知识==
  - ==**深入讲解checkList与dataList绑定item具体是什么,答案是地址,这个在解释页面响应式数据时是重点理解**==
  - ==del删除功能fiter知识==
- ==**案例重点**==:
  - 1.把html与style调试好
  - 2.我们有datalist和checklist两个数组
    - datalist作为后端传递的数组,内部是商品的全部数据;
    - checklist是一个空数组("input-checkbox复选框 + 数组"),配置的value值是item,这个item是从datalist中获取的value值,即单个对象数据
  - ==3.解释响应式数据变化==: 删除增加商品项和改变商品数量对金额的影响
    - 1.sum金额的变化依赖checklist函数变化,所以选择商品项会直接影响到checklist数组的长度,影响到sum,从而重新计算金额
    - 2.改变商品数量,在代码中是datalist的事情,但是由于data与check共用"item"钥匙(地址),所以当真正的item对象内部属性number被改变时,check根据"钥匙"发现item内部值变化时,也会受影响,进而影响sum,总而言之,data与check由于共同绑定的item,变为一根绳上的蚂蚱,任何item的变化都会影响到他俩
   - ==4.全选/全不选的双向功能要求的两个函数:==
     - 全选/全不选 ---> 单个选项选不选
     - ==因为check遵循:value=item,所以全选就相当于把data的所有item数据复制了一份给check==,所以如果isAllChecked是true,就是全选,直接把datalist数据全部赋给checklist即可,否则直接赋空值即可(全不选)
     - 单个选项选不选 ---> 全选/全不选 ==主要应付del功能==
     - 我们使用删除功能del后,依然能识别到全选与全不选,就要看check与data的数量了(注意排除全删完的情况,那时候check=data=0,但是不属于全选情况)
     - 即当check(点击选项框)的个数与原本数据个数一致且不为0时,为全选
     - 否则为全不选


    > **此项目几乎把所有前面学过的知识杂烩到一起,整了个案例,虽然一些实现功能略显复杂,但是是对前面所学知识的一次很好的复习**
- 代码:
  ```
    <div id="root">
        <ul>
            <!-- 选择区 -->
            <li>
                <!-- 绑定change事件handleAllChange 实现 全选框->单个框的逻辑判断 -->
                <div><input type="checkbox" v-model="isAllChecked" @change="handleAllChange"><span>全选/全不选</span></div>
            </li>
            <!-- for 商品区 -->
            <!-- v-if 与 v-for不能在一个标签里, 当datalist还有内容也就是不为0时,执行下面的商品区代码,否则执行v-else的空空如也提示代码 -->
            <template v-if="datalist.length">
                <li v-for="(item,index) in datalist" :key=item.id>
                    <div>
                        <!-- 动态绑定value 即:value -->
                        <!-- 绑定change事件handleItemChange 实现 单个框->全选框的逻辑判断 -->
                        <input type="checkbox" v-model="checkList" :value="item" @change="handleItemChange">
                    </div>
                    <div>
                        <img :src="item.poster" alt="" width="100px">
                    </div>
                    <div>
                        <div>名称:{{item.title}}</div>
                        <div style="color:red">价格:{{item.price}}</div>
                    </div>
                    <div>
                        <!-- 改变item是属于改变了datalist,为何计算金额依赖的checkedList也会改变数据呢 -->
                        <!-- 无论datalist还是checkedList,它们绑定的item都是这些对象值的一把"钥匙",就是地址,所以只要是item变化了,data和check跟随"钥匙"找到item发现变化了,也就响应式变化了 -->
                        <!-- 简而言之 , item中的数据只要变化,data和check跟着响应 -->
                        <!-- 影响datalist,进而影响checkList  -->
    
                        <!-- :disabled="item.number===1" : 当item.number===1表达式成立时,按钮失效,这是一个边界检测,同理也有最大值limit边界检测 -->
                        <button @click="item.number--" :disabled="item.number===1">-</button>
                        {{item.number}}
                        <button @click="item.number++" :disabled="item.number===item.limit">+</button>
                    </div>
                    <div>
                        <button @click="handleDel(index,item.id)">删除</button>
                    </div>
                </li>
            </template>
            <!-- 当商品删除完后再显示 -->
            <li v-else>商品空空如也</li>
            <!-- 金额区 -->
            <li>
                <!-- 计算金额函数,sum()数据依赖checkList,checkedList变化牵一发动全身,影响到sum(),这里的页面布局也就会响应式变化 -->
                <!-- 只有选中进入checkList数组才会被纳入计算 -->
                <div>总金额:{{sum()}}</div>
            </li>
        </ul>
    </div>

    <script>

        var obj = {
            data() {
                return {
                    // 勾选的商品数据数组
                    checkList: [],
                    // 全选按钮设置
                    isAllChecked: false,
                    // 模仿后端传递数据
                    datalist: [
                        {
                            id: 1,
                            title: "商品1",
                            price: 10,
                            number: 1,
                            poster: "https://static.maizuo.com/pc/v5/usr/movie/878f3f2dc9ad07a08d37f2fe5affbc32.jpg?x-oss-process=image/quality,Q_70",
                            limit: 5
                        },
                        {
                            id: 2,
                            title: "商品2",
                            price: 20,
                            number: 1,
                            poster: "https://static.maizuo.com/pc/v5/usr/movie/02e5b8507b28a6417eb2712643f3b246.jpg?x-oss-process=image/quality,Q_70",
                            limit: 5
                        },
                        {
                            id: 3,
                            title: "商品3",
                            price: 30,
                            number: 1,
                            poster: "https://static.maizuo.com/pc/v5/usr/movie/7f52c31fd9aae778bed7a64d1cbd60c2.jpg?x-oss-process=image/quality,Q_70",
                            limit: 5
                        },
                    ]
                }
            },
            methods: {
                // 计算金额功能
                sum() {
                    // 方法1:
                    // var total = 0
                    // for(var i = 0; i < this.checkList.length; i++){
                    //     total += this.checkList[i].price * this.checkList[i].number
                    // }
                    // return total

                    // 方法2: js原生方法 reduce
                    // 两个参数 第一个是函数,第二个是prev初始化值
                    // 语法:  arr.reduce((prev,item)=>prev+item,0) prev代表上次计算结果,item就是遍历的每一项value
                    return this.checkList.reduce((total, item) => total + item.price * item.number, 0)
                },
                // 删除功能
                handleDel(index,id){
                    // 列表更新 --> datalist
                    this.datalist.splice(index,1)
                    // 金额更新 --> checkedList
                    // 更新checkList数组,记住filter是不改变数组内容的,会返回一个新数组,所以要覆盖之前的数组
                    // filer语法 : arr.filter(item=>表达式) 表达式为true,此item留下,否则删除
                    this.checkList = this.checkList.filter(item=>item.id !== id)

                    // 删除时,同步下全选问题,它不会自动执行
                    this.handleItemChange()
                },
                // 全选/全不选 ---> 单个选项选不选
                handleAllChange(){
                    // console.log(this.isAllChecked);
                    // 三目,首先checklist绑定的value是item,也就是datalist的整一个单项数据{....}
                    // 如果isAllChecked是true,就是全选,直接把datalist数据全部赋给checklist即可,否则直接赋空值即可
                    this.checkList = this.isAllChecked?this.datalist:[]
                },
                // 单个选项选不选 ---> 全选/全不选
                handleItemChange(){
                    // console.log(this.checkList.length,this.datalist.length)
                    // 当check(点击选项框)的个数与原本数据个数一致且不为0时,全选框选中
                    if(this.checkList.length === this.datalist.length && this.checkList.length !== 0){
                        this.isAllChecked = true 
                    }else{ // 否则就全选框不被选中,两个情况,一个是有的data没check,另一个是删完了, data清空了
                        this.isAllChecked = false
                    }
                }
            }
        }

        var app = Vue.createApp(obj).mount("#root")
    </script>

  ```
### 表单修饰符
- 配合v-model的使用
- ==**.lazy**== ==懒惰的(由@change底层渲染==), **失去焦点且内容改变时才会重新渲染** ==原v-model是由@input底层渲染,一旦有变化就触发==
    `<input type="text" v-model.lazy="mytext">`
- ==**.number** 输入内容的数字部分自动转化为数字类型==
  - 如果有非数字的部分内容,会被截取,如果没有一个是数字,那么就无能无力了,全原样转化为字符串
  - 不添加的话,即使输入数字也会默认把数字类型转化为字符串类型
    `<input type="text" v-model.number="mynumber">`
    >
  - ==如果type=number这么写,**在vue里会自动转化,如果在原生js上这么写就会无效**,同时这个输入框只能输入数字==
    `<input type="number" v-model="mynumber2">`
- ==**.trim**(js中也有,为 str.trim()) **字符串的首尾空格删除**,,主要防止用户注册用户名时无意识打出的无谓空格,进而把空格也当作有效数据保存,出现下次用户登录时不输入相应空格无法登录的情况==
    `<input type="text" v-model.trim="username">`
### 计算属性(不能传参)
- 计算属性是==为了简化计算代码,从而把复杂操作写入计算属性中,而html只需引用即可,计算属性会把计算结果return出去==

- ==**计算属性有新的区域,computed区域**==,结构如下:
  ```
    var obj = {
            data(){
                return {

                }
            },
            computed:{
                // 书写格式形同函数,但是使用时不可以带括号
                Func(){
                    ........
                    return ...
                }
            },
            methods:{

            }
        }

        var app = Vue.createApp(obj).mount("#root")
  ```
    > 注意: 
    > 1.==因为computed在data之下,**所以computed的计算属性名不允许与data变量重名**,否则会系统会先解析data内的数据,从而重名的这个计算属性就被废弃了==
    > 2.==书写格式形同函数,**但是在html使用时不可以带括号(下面有使用代码)**==


- ==计算属性computed与函数方法methods的区别:== 
  - 计算属性: 相比于函数,结果会缓存,后期如果重复使用此次结果,会直接调取缓存内容,性能优化,在需要重复大量复杂计算时,计算属性相对于函数方法更有优势
  > ==注意: 在vue3中计算属性不可以传递参数==
- ==计算属性的使用规则:==
  - 1.凡是为了计算一个结果return出去而写的函数方法都可以转化为计算属性
  - 2.但是像绑定事件配置响应函数这种事,还是函数方法的专项,计算属性不能胜任
  - ==**总结为专精计算领域**==

- 计算属性computed与函数方法methods的区别的代码:
  ```
    <div id="root">
        <!-- 对比计算属性和函数方法的区别: -->

        <!-- 作为计算属性,不要加括号,内容为return的值 -->
        <div>计算属性: {{myComName}}</div>
        <div>计算属性: {{myComName}}</div>
        <!-- 调用函数方法要加括号才会执行,不加就相当于简单打印了下函数内容 -->
        <div>函数方法: {{myMetName()}}</div>
        <div>函数方法: {{myMetName()}}</div>
    </div>

    <script>
        
        var obj = {
            data(){
                return {
                    myname:'kerwin',
                }
            },
            computed:{ 
                myComName(){
                    console.log("计算属性")
                    // 基于依赖(this.myname)修改之后,重新计算一遍
                    return this.myname.substring(0,1).toUpperCase() + this.myname.substring(1)
                }
            },
            methods:{
                myMetName(){
                    console.log("函数方法")
                    return this.myname.substring(0,1).toUpperCase() + this.myname.substring(1)
                }
            }
        }

        var app = Vue.createApp(obj).mount("#root")
    </script>

  ```
### 计算属性的可写可读
- ==首先计算属性一般可读用的多,我们一般用于计算,而非赋值,所以可写用的少,并且可写有固定格式==
- 格式如下代码:
  ```
    var obj = {
            data(){
                return {

                }
            },
            computed:{
                // 仅可读写法
                Func(){
                    ........
                    return ...
                },
                // 可读可写写法,形如对象
                Func : {
                    // 可读功能区
                    get(){
                        .......
                        return ...
                    },
                    // 可写功能区,value接受写入的数据
                    // 没有return
                    set(value){
                        console.log(value)
                    }
                }

            },
            methods:{

            }
        }

        var app = Vue.createApp(obj).mount("#root")
  ```
    > ==可写的计算属性写法如对象,并且有get()和set()两个函数区,其中get还是可读区,负责把计算的值return出去,而set主要接受写入数据,**并且set内部可以根据获取的数据,对data,get等数值进行更新(使用赋值覆盖即可,记得加this,就如下面的实例代码**==)
- 实例代码(下面的写入是从终端中赋值写入的):
    ```
        <div id="root">
        <!-- 作为计算属性,不要加括号,内容为return的值 -->
        <div>计算属性: {{myComName}}</div>
        <div>日期:{{computedDate}}</div>
    </div>

    <script>
        
        var obj = {
            data(){
                return {
                    myname:'kerwin',
                    year : 24,
                    month : 12,
                    day : 31
                }
            },
            computed:{ 
                // 尝试给计算属性赋值
                // 写成对象形式 可读可写
                computedDate:{
                    // get内部只对计算结果进行二次加工然后return出去,不要写dom操作及异步请求等
                    get(){
                        return `${this.year}-${this.month}-${this.day}`
                    },
                    // 接受写入的值
                    // 这里通过终端直接赋值,默认为"XXX-XXX-XXX"格式
                    set(value){
                        console.log("写入的内容" + value.split("-")); // 按-分割内容
                        // this.year = value.split("-")[0]
                        // this.month = value.split("-")[1]
                        // this.day = value.split("-")[2]

                        // ES6 [a,b,c] = arr (即有 a=arr[0] b=arr[1] c=arr[2] 的效果)
                        [this.year,this.month,this.day] = value.split("-")
                    }
                },
                // 函数()形式,只可读
                myComName(){
                    return this.myname.substring(0,1).toUpperCase() + this.myname.substring(1)
                }
            },
            methods:{
                
            }
        }

        var app = Vue.createApp(obj).mount("#root")
    </script>
    ```
### 计算属性之购物车案例
- ==主旨:利用了新学的计算属性可读可写的属性,改造了购物车案例==
- ==改造==: 
  - 1.sum从methods转入computed,实现从函数->计算属性的转变
  - 2.删除全选与单个选项框的双边函数,实现2个函数->2行代码的简化,这里面的计算属性为isAllChecked
  - 3.并简化了del功能内部的"单个选项->全选的函数调用",直接删除即可
- ==**解释**==:
  - 1.sum就略了,简单应用了计算属性写法
  - ==**2.删除全选与单个选项框的双边函数**==
    ```
    html :
    <div><input type="checkbox" v-model="isAllChecked"><span>全选/全不选</span></div>

    vue-computed :
    isAllChecked: {
        get() {
            // 单个选项 --> 全选/全不选
            return this.checkList.length === this.datalist.length
        },
        // checked可以接受到选项框勾选的情况,布尔表示
        set(checked) {
            // console.log(value);
            // 全选/全不选 --> 单个选项
            checked = this.checkList ? this.datalist : []
        }
    }
    ```

    - 单个选项 --> 全选/全不选
      - return出去的是一个表达式,条件和原案例都一样,只要满足条件,返回出去的表达式就为true,给isAllChecked赋true即全选,不满足就赋值false
    - 全选/全不选 --> 单个选项
      - checked是可写接受的数据值,而这个值正是v-model观察选项框是否被勾选的而接受的布尔判断值,如果全选框被勾选,响应给v-model的数据就是true,而checked接受的也为true,根据三目运算,令this.checkList等于dataList即可满足所有的单个选项框都被选中,同理false略.
  - 3.并简化了del功能:
    - 删除时,观察内部代码,影响到了checklist和datalist表,所以数据发生改变,会其一发动全身地重新计算get与set,然后影响到isAllChecked,进而影响到全选框的勾选,相当于一个自动化了
  - 代码:
    ```
        
    <div id="root">
        <ul>
            <!-- 选择区 -->
            <li>
                <!-- isAllChecked纳入计算属性,并把全选系列功能函数全部删除代替为计算属性 -->
                <!-- 可写: v-model + 计算属性 , 可以把选项框勾选的情况"写入"计算属性isAllChecked内部set()中 -->
                <div><input type="checkbox" v-model="isAllChecked"><span>全选/全不选</span></div>
            </li>
            <!-- for 商品区 -->
            <template v-if="datalist.length">
                <li v-for="(item,index) in datalist" :key=item.id>
                    <div>
                        <input type="checkbox" v-model="checkList" :value="item">
                    </div>
                    <div>
                        <img :src="item.poster" alt="" width="100px">
                    </div>
                    <div>
                        <div>名称:{{item.title}}</div>
                        <div style="color:red">价格:{{item.price}}</div>
                    </div>
                    <div>
                        <button @click="item.number--" :disabled="item.number===1">-</button>
                        {{item.number}}
                        <button @click="item.number++" :disabled="item.number===item.limit">+</button>
                    </div>
                    <div>
                        <button @click="handleDel(index,item.id)">删除</button>
                    </div>
                </li>
            </template>
            <!-- 当商品删除完后再显示 -->
            <li v-else>商品空空如也</li>
            <!-- 金额区 -->
            <li>
                <!-- sum纳入计算属性行列 -->
                <div>总金额:{{sum}}</div>
            </li>
        </ul>
    </div>

    <script>

        var obj = {
            data() {
                return {
                    // 注意: 系统找vue属性时优先找data 再找计算属性, 所以这里的变量名不得与计算属性名相同

                    // 勾选的商品数据数组
                    checkList: [],
                    // 模仿后端传递数据
                    datalist: [
                        {
                            id: 1,
                            title: "商品1",
                            price: 10,
                            number: 1,
                            poster: "https://static.maizuo.com/pc/v5/usr/movie/878f3f2dc9ad07a08d37f2fe5affbc32.jpg?x-oss-process=image/quality,Q_70",
                            limit: 5
                        },
                        {
                            id: 2,
                            title: "商品2",
                            price: 20,
                            number: 1,
                            poster: "https://static.maizuo.com/pc/v5/usr/movie/02e5b8507b28a6417eb2712643f3b246.jpg?x-oss-process=image/quality,Q_70",
                            limit: 5
                        },
                        {
                            id: 3,
                            title: "商品3",
                            price: 30,
                            number: 1,
                            poster: "https://static.maizuo.com/pc/v5/usr/movie/7f52c31fd9aae778bed7a64d1cbd60c2.jpg?x-oss-process=image/quality,Q_70",
                            limit: 5
                        },
                    ]
                }
            },
            computed: {
                // 计算金额功能 + 计算属性
                sum() {
                    return this.checkList.reduce((total, item) => total + item.price * item.number, 0)
                },
                // 全选/全不选
                // 利用计算属性的可读可写特性,优化两个函数为两行代码,并解绑了两个事件,使得代码整洁多了
                isAllChecked: {
                    get() {
                        // 单个选项 --> 全选/全不选
                        return this.checkList.length === this.datalist.length
                    },
                    // checked可以接受到选项框勾选的情况,布尔表示
                    set(checked) {
                        // console.log(value);
                        // 全选/全不选 --> 单个选项
                        this.checkList = checked ? this.datalist : []
                    }
                }
            },
            methods: {
                // 删除功能
                handleDel(index, id) {
                    this.datalist.splice(index, 1)
                    this.checkList = this.checkList.filter(item => item.id !== id)
                    // 删除功能也不必另写"单个选项 --> 全选/全不选"功能函数了
                    // 计算属性在del商品时,数据发生改变,会其一发动全身地重新计算get与set,然后影响到isAllChecked,进而影响到全选框的勾选
                },
            }
        }

        var app = Vue.createApp(obj).mount("#root")
    </script>


    ```
### 监听器watch
- ==**监听的代码有新区域,即script内watch区**==
- ==**监听字符串**==
  - **监听字符串作用**: ==一旦监听的字符串发生改变,自动触发此监听器的内部函数,相对比绑定函数@input=Func要方便==
  
  - 代码:
    ```
    <div id="root">
        
        <input type="text" v-model="mytext">

        <ul>
            <li v-for="item in datalist" :key="item">
                {{item}}
            </li>
        </ul>

    </div>

    <script>

        var obj = {
            data() {
                return {
                    mytext: "",
                    datalist: ["aaa", "bbb", "aca", "bca", "abc", "bbc", "cab"],
                    baklist : ["aaa", "bbb", "aca", "bca", "abc", "bbc", "cab"]
                }
            },
            watch:{

                // 监听谁写谁的名字,本次为监听字符串类型
                // 监听变量mytext的值,2个参数,代表当前值和上次的值
                // 当mytext发生改变时触发,执行内部代码
                // 相对于计算属性,能够使用dom操作,ajax等,而watch适合干这个
                
                mytext(value,oldvalue){
                    console.log(value,oldvalue)
                    setTimeout(()=>{
                        this.datalist = this.baklist.filter(item=>item.includes(this.mytext))
                    },1500)
                },

                // 对于监听字符串,还有两个写法
                // 第一个: 
                // mytext : function(){

                // },

                // 第二个: anyFunc函数就在methods里面写即可
                // mytext : "anyFunc"
            },
            computed:{

            },
            methods: {
                // anyFunc(){
                //     //.....
                // }
            }
        }

        var app = Vue.createApp(obj).mount("#root")
    </script>

    ```
    - ==提取注释信息==
    
    > 1.本次为监听字符串类型,变量为mytext
    > 2.==监听谁写谁的名字,在watch内写一个**同名函数mytext**==,当mytext发生改变时触发,执行内部代码
    > 3.这个函数==有2个参数,代表当前值value和上次的值oldvalue==
    > 4.==**相对于计算属性,watch能够使用dom操作,ajax,异步程序等**==
    > 5.函数有3个写法,最推荐==mytext(value,oldvalue){...}==

- ==**监听对象**==
- 代码:
  ```
    <div id="root">

       <select v-model="obj.year">
            <option value="2022">2022</option>
            <option value="2023">2023</option>
            <option value="2024">2024</option>
            <option value="2025">2025</option>
       </select>

       <select v-model="obj.month">
            <option value="12">12</option>
            <option value="1">1</option>
            <option value="2">2</option>
       </select>

    </div>

    

    <script>
        var obj = {
            data(){
                return {
                    obj : {
                        year : "2024",
                        month : "12"
                    }
                }
            },
            watch:{
                // 监听对象的写法
                // 按照对象的属性进行监听,一旦改变,触发执行内部函数
                // "obj.year" : function(value){
                        // console.log(value) // 打印监听year改变后的值
                // },
                // "obj.month" : function(){
                        // .....
                // }

                // 如果嫌函数一个个写麻烦,可以这样,anyFunc写在methods里
                // "obj.year" : "anyFunc",
                // "obj.month" : "anyFunc"

                // 如果觉得对象的属性太多了,可以这样写
                obj:{
                    // handler deep immediate都是固定写法
                    handler(value){
                        // 每次obj改变,监听触发,会把整个改变后的对象打印出来,为proxy对象
                        console.log(value)
                    },
                    deep:true, //复杂对象进行深度监听,意为对象内部无论嵌套多深,任何一个属性被改变,都会被监听到
                    // 监听只有在数值改变时才执行,那么第一次初始化的值如何被监听呢?
                    immediate:true //立即触发一次监听,即对初始化的值监听一次
                }


            },
            computed:{

            },
            methods:{
                // anyFunc(value,oldvalue){
                //     console.log(value,oldvalue)
                // }
            }
        }

        var app = Vue.createApp(obj).mount("#root")
    </script>

  ```
  - ==注释内容提取==
   > 1.==**监听对象是状态data(){}内的对象**,本此监听对象为obj==
   > 2.==监听对象有许多写法,**推荐最后一个写法,注释很详细(重点看下handler,deep,immediate的作用和handler的参数)**==
   > ==**注意:监听对象不是函数写法了,是类似计算属性的写法,还有就是依旧监听谁写谁的名字**==
### fetch axios 讲解和测试
- fetch axios学过了,没听,案例十分简单
- 不过建议听听,里面有个.json的没听过
### 过滤器
- vue3没有过滤器,计算属性和函数方法代替,其中计算属性无法传参
- 很简单,这里略

### 原生组件初学
- 十分复杂,不要学了,在034,具体认识三个标签即可
- 即 template(HTML) script(JS) style(CSS)

## Vue Cli 项目构建
### 使用Vue CLI创建Vue3项目的步骤

1. **全局安装Vue CLI：**
   
   - 打开命令行工具（如Terminal或Command Prompt）。

   - 运行以下命令安装Vue CLI：`cnpm install -g @vue/cli`。cnpm(淘宝路径下载)
    > 说明下,在把淘宝镜像进行全局设置后方可使用cnpm下载
    > cnpm是淘宝镜像下载第三方工具的指令
   
   - 如果npm 下载较慢可以选择使用淘宝镜像来进行下载 
   
     ```
     npm install -g cnpm --registry=https://registry.npmmirror.com
     ```
   
2. **创建新项目：**
   
   - 在命令行中运行`vue create project-name`，将`project-name`替换为你想要的项目名称。
   - 选择在创建过程中使用Vue3。
   
3. **选择配置选项：**
  
   - 在创建过程中，Vue CLI将提示选择预设配置或手动选择特性。选择Vue3作为Vue版本。
   - 可根据需求选择其他配置，如Babel、TypeScript等。
   - ==第一次配置好后,保存了,以后就默认这个配置了==
   
4. **切换路径：**
   
   - 项目创建完成后，进入项目目录：`cd project-name`。

5. **运行项目：**
   
   - 运行`npm run serve`启动开发服务器。
   - 访问`http://localhost:8080/`查看项目运行情况。

**==注意事项：==**

- 确保已安装Node.js和npm。
- 在创建项目时选择Vue3版本。
- 根据项目需求选择合适的配置选项，如TypeScript、CSS预处理器等。
- **定期更新Vue CLI版本，以使用最新功能和修复bug。==Vue Cli已经不更新了,我们推荐vite==**
### Vue CLI 构建的项目构成

- 我们说重要的组成部分:(==初学所认识的==)
  - node_modules: 里面是项目的依赖(==这是vue cli文件体积巨大的原因==)
  - pubilc : 内部有个index.html ,这个就是我们显示的网页,启动项目时,vue会自动往里面引文文件
  - package.json : 命令的配置(当时改node->nodemon的地方),内部我们也会找到`npm run serve`中`serve`的扩展
  - vue.config.js: 控制vue规则,后面课程中我们在里面设置了代理服务器
  - **==src核心==**
    - components: 内部写局部组件,后期引入App.vue
    - main.js: 创建vue,挂载vue的地方
    - App.vue: 使用组件,引入组件(从components引入)的地方
### 初步解释项目文件关系

- main.js:(==vue项目的入口,从这里创建的,引入的,延伸的==)
    ```
    import { createApp } from 'vue' // 从vue中引入API
    import App from './App.vue' // 支持单文件组件(相对路径) ES6模块化语法


    createApp(App).mount('#app')

    ```
    > 1.==App/App.vue: APP变量名,就这个vue的obj,而被引入文件APP.vue内部详细写了如何配置==
    > 2.挂载#app,在public-index.html中,已经自动把根节点div-id="app"定义好了,不用管理
    > 3.createApp,自动引进vue的API,别管
    > 4.==main.js文件名别乱改,系统默认寻找main.js==

- App.vue:(==创建vue的关键,createApp(obj)的obj==)
  - ==学过了组件初学习都知道那个很麻烦,而单文件组件很好的解决了这个问题==
  - ==**分为三大块,每个板块的内容注释有,一定记得导出,供main.js用**==
  ```
    <template>
        HTML
    </template>

    <script>
        JS区(后面也会写TypeScript在这里面)
        import ... from '相对路径' // 可以引入组件的

        export default { // 必写,导出,这样main.js才能引用你
            vue区 data(){} methods ..... 
        }
    </script>

    <style>
        CSS
    </style>
  ```
  

  > ==**这个文件是子组件的集合处,不建议在这里面写大量的实际代码,会导致代码冗余混乱,用局部组件写完引入即可**==

- components文件夹内部的vue(==写法和App.vue一样,作为局部组件,导出后供APP.vue用==)

### 自定义标签 + 局部组件相关知识
- 自定义标签就是原生中没有的,我们自己写的,例如`<kerwin></keriwn>`
- ==**系统把自定义标签认定为组件,我们可以通过对组件的详细编写,引入后,直接用**==
- **案例**:
  - ==需求==: 我们想要一个按钮,点击后在终端输出内容
  - ==操作==: 在MyApp.vue中(主组件),内部我们写了一个自定义标签Navbar,然后从components详细写了这个需求的功能文件Navbar.vue,之后引入直接使用
  - ==components-局部组件-Navbar.vue==
    ```
        <template>
            <div>
                 I'm Navbar !!!
                <button @click="handleClick">click</button>
            </div>
        </template>

        <script>
            export default {
                methods: {
                    handleClick(){
                        console.log("navbar-click")
                    }
                }
            }
        </script>

        <style> </style>  
    ```
    > 1.在template中我们写好了简单的html代码,并绑定事件
    > 2.在script中,我们写了click事件的响应处理函数,随后导出
  - ==MyApp.vue==
    ```
    <template>
        // 我们的组件
        <Navbar></Navbar>
    </template>

    <script>
        // 1.局部引入 import 变量名字 from `目标组件的相对路径` 
        import Navbar from "./components/Navbar.vue";
        export default {
            // 2.引入后在这里注册
            components:{
                // 写法1: "Navbar" : Navbar 
                // 写法2: 同名简写如下
                Navbar
            }
        }
    </script>

    <style> </style>
    ```
    - ==组件的引入分为局部和全局==
        ==只有当大量组件都需要某个相同功能时,才会从全局中注册组件,供大家使用==,**但是一般不推荐全局,因为全局组件注册需要在main.js文件中进行,还是老问题,会冗余,混乱,重名,冲突**
        > 
    - **局部引入的写法(谁用给谁引入)**: ==先import引入,再在components里注册,上面代码中有注释==
    - **全局引入的写法(在main.js文件中)**
    ```
        import { createApp } from 'vue' 
        import App from './MyApp.vue' 

        // 1.引入局部组件
        // import Navbar from './components/Navbar.vue'

        createApp(App)
        // 2.在全局注册局部组件
        // 有两个参数,局部组件名和引入的组件变量名
        // 可以在任意组件中使用这个Navbar组件
        .component("Navbar",Navbar)
        .mount('#app')
    ```

    > 1.==我们使用的自定义标签名字要与我们定义的组件变量名一致==
    > 2.在template我们使用自定义标签Navbar(相当于使用了组件Navbar),在script中我们引入并注册了Navbar组件
    > 3.==**局部组件的特点,谁用给谁引入,局部组件之间的状态互相不影响,无论父子,爷孙,兄弟关系,后面会学习局部组件的数据共享**==
    > 
  - ==关于局部组件状态和样式的解释:==
    - 状态: 就是data(){}中的变量
    - 样式: 就是style内部的css样式
  - ==状态的互不影响==: 局部组件中的变量互相无法调用,乱调用也是未定义状态
  - ==样式的解释==: 
    - ==如果子组件在样式style不添加`scpoed`属性,就会被父组件的样式覆盖,写法为`<style scoped></style>`==
    - **原理解释:** 
      - 在index.html中vue会自动引入css样式,子组件不写scpoed,引入顺序中,父组件会在最后,可能就会覆盖前面子组件的css样式
      - 如果你写了scpoed参数,vue会给每个标签的class配以个id名,保证唯一不重复,这样就不会被覆盖样式了
### Vue CLI的代理功能
- 在vue中我们利用devSever去实现一个代理服务器功能
- 代理服务器的作用: ==使用我们电脑的端口服务器作为中介,向猫眼发送请求获取响应数据,绕过服务器的跨域阻止协议== 
- 如何操作?
  - 在官网vue cli 搜索 devSever,将配置内容复制进vue.config.js文件
  - ==配置devSever的信息,**然后重启服务器才能生效**==
- 配置devSever参数(**==注释很详细==**)
    ```
    devServer: {
        proxy: {
            // 正常的url : 请求协议 + 域名 + 端口
            // 其中我们自己电脑的端口都是数字 3000 8080等
            // 但是猫眼后端定义的端口就不是单纯的数字了,可以自定义的任意名字,取决于人家后端怎么写的
            // 端口是什么就写什么,猫眼正好是/api,所以不用改了
            // 如果是/kerwinapi,就改成那样
            '/api': {
                // target写的是请求协议+域名
                target: 'https://i.maoyan.com',
                changeOrigin: true
            }
        }
    }
    ```
- 请求如何写? (==在局部组件MaoYan.vue中写==)
    ```
    <template>
        <div>
            <button @click="handleClick">猫眼</button>
        </div>
    </template>

    <script>
        export default {
            methods: {
                handleClick(){
                    // 我们要请求数据的猫眼url如下:
                    // https://i.maoyan.com/api/mmdb/movie/v3/list/hot.json?ct=%E8%A5%BF%E5%AE%89&ci=42&channelId=4
                    // fetch(里面就写端口就可以了,http赋值给vue.config.js里target了)
                    fetch("/api/mmdb/movie/v3/list/hot.json?ct=%E8%A5%BF%E5%AE%89&ci=42&channelId=4")
                    .then(res=>res.json())
                    .then(res=>{
                        // 打印响应数据
                        console.log(res)
                    }) 
                }
            }
        }
    </script>

    <style> </style>
    ```
    > ==1.使用的fetch,fetch内部的url不在是完全体了,只有url的端口部分,http协议和域名部分写在devServe里面==
    > ==2.fetch+devServe是一体的,单独写fetch会跨域,单独devServe会报位置错误==
    > 3.**配置完好后记得重启服务器**
### Vue ClI 转化
- 浏览器只识别 html + css + js 老三样的格式,不认识vue,所以文档中让我们在终端中输入指令`npm run bulid`(==注意先结束服务器 ctrl + c==)
- ==生成的dist文件夹==就自动把vue转化为老三样了,这样你发给后端即可
## vite集合
### vite项目构建
**使用Vite创建Vue3项目的步骤：**

1. **全局安装Vite：**
   - 打开命令行工具。
   - 运行以下命令安装Vite：`cnpm install -g vite`。(cnpm淘宝路径下载)

2. **创建新项目：**
   - 在命令行中运行`npm init vite `。(mac的同学尽量使用npm 安装。否则可能电脑会因为权限不足报错)
   - 官网上为 `npm create vite@latest` 

3. **进入项目目录：**
   - 进入新创建的项目目录：`cd project-name`。

4. **安装依赖：**
   - 运行`npm install`安装项目依赖。

5. **运行项目：**
   - 运行`npm run dev`启动开发服务器。
   - 打开浏览器访问`http://localhost:3000/`查看项目。

**注意事项：**
- ==确保已安装Node.js和npm。==
- Vite是一个新型的构建工具，具有快速的冷启动和热更新功能。
- Vite不需要预先将代码编译成文件，因此启动更快，适用于现代化的前端开发。
## 父子关系与通信
### 父传子
- 父传子: ==从父组件向子组件传递信息,可以是状态或是自己写的值==
- 父传子要求: **父和子之间都要相互配合,==关于父引入局部子组件就不赘述了==**
- ==**父组件几种传递的写法**==:
  - ==下面这些Navbar标签都是在template里的==
  - 写法1: (==直接写值==)
    `<Navbar title="首页" left="返回" right="返回"></Navbar>`
  - 写法2: (==封装入对象==) 
    `<Navbar v-bind="propObj"></Navbar>`
    ```
        // 对象propObj配置就在data(){}内部即可,如下
        data() {
        return {
            propObj: {
                title: "首页", // 在对象中,带-的属性要加引号
                left: "返回",
                right: "返回"
            }
        }
    },
    ```
    > ==在注释中,带-的属性要添加引号,而在子组件中使用这个属性要用驼峰写法==
  - 写法3: (==动态绑定状态==)
     `<Navbar :title="mytitle"></Navbar>`
    ```
        data(){
        return {
            mytitle: "首页状态" 
        }
    },
    ```
    > ==**看到动态绑定,我们一定要意识到,后面已经是js领域了**,所以那个mytitle不是字符串了,而是一个变量(也就是下面的状态),**我们还常用:把一些字符串转化为我们想要的数据类型,比如字符串下的数字和布尔值转化为真正的数字类型和布尔类型**==
- ==**子组件接受与应用**==
  - ==使用新的属性props接受父传递的属性,在data(){}内部==
    ```
    data(){
        // 接受父组件属性,下面是父组件的属性名字,会自动接受其值,应用到子组件内部
        props: ["title", "left", "right"]
    }
    
    ```
    > **注意**:==子组件props内部的名字与父组件传入的属性名要一致==
    > **基本的用法**:
    > 1.在script内部应用的话,要记得加this,比如this.title,这样就可以用父组件传递的title值了
    > 2.也可以在template里直接用,用{{}}方法,不用加this
- ==**单向绑定特性**==: 父组件修改属性的值可以影响子组件,但是子组件不能修改属性反过来影响父组件,因为这样子会很混乱
> 
- ==另类的改变父组件的值==: ==**虽然我们子组件无法改变父组件的值,但是父组件的值传递到子组件里面后,我们可以加工后再使用**,实现了另类的改变,当然这个操作对父组件没有任何影响==
- 改变的方法由两个,**计算属性和函数方法**
  - ==统一修改父组件的title值(**记得在script内部使用要加this**)==
  - 计算属性修改(==自动的==):
    ```
        template : 
            计算属性修改(自动的):{{computedTitle}}
        script-computed :
            computed:{
                computedTitle(){
                    return this.title + "计算属性修改完了"
                }
            }
    ```
  - 函数方法修改(==需要触发==): 
    ```
        template:
            <!-- 1.状态修改就是,创建一个子组件状态,然后通过赋值,获取父组件的属性值,之后就可以任意修改了 -->
            <button @click="handleClick2">状态修改</button>
            状态修改(手动点击按钮执行): {{ mytitle }} 

        script-data:
            data(){
                return {
                    mytitle : ""
                }
            }

        script-methods:
            methods:{
                handleClick2() {
                    this.mytitle = this.title + "状态修改完了"
                }
            }
    ```
    > ==**总结**==: 
    > 1.计算属性是自动的,而函数方法需要看你绑定的触发条件,非自动的
    > 2.计算属性只能进行简单的计算返回出去,而函数方法可以在内部进行更加复杂的加工,最后赋值给子组件新创建的状态即可

### 属性验证与默认属性
- ==子组件接受父组件时可以对接受的参数规范其类型,还可以在不输入的情况下给默认值==,如下
    ```
        props:{
            title : String, // 1.直接写
            left : [String,Number], // 2.允许两种(多写几个也行)类型数据
            right : {
                // 3.不传值也会报错,必填
                required: true,
                // 4.属性验证:
                // 固定的校验器,别改名字,校验失败会报警告
                validator(value){
                    // 如果right属性值不是下面三个其一就返回false
                    return ["success","warning","danger"].includes(value) // 检查数组内是否有和value相等的,有为true,没有则为false
                }
            },
            leftShow : {
                required : true,
                type:Boolean 
            },
            rightShow : {
                type:Boolean,
                default: true // 5.默认属性: 即使你不传值,也有个默认值true
                // default不要和required写一起,默认值就是偷懒不传值用默认值的,和必填属性功能冲突了!
            },
        }

    ```
    > 1.props由数组写法变对象写法,内部格式为'属性:{....}'
    > 2.==看注释共有5个要点,不按要求传数据会在终端报警告==
    > 注意: default不要和required写一起,默认值就是偷懒不传值用默认值的,和必填属性功能冲突了!

### 属性透传
- 父组件使用子组件时,直接在自定义标签上加形如class,style,id等,会透传到Navbar组件的根节点上(div),==注意是根节点,就是最外层的那个标签==
- ==如果div有自己的class等,会合并==
- ==vue可以区分这种标准的属性和我们自定义的属性==,所以class会当作正常标签透传,而kerwinClass就会被当做新组件
- ==**事件**同理也能透传给子组件的根节点==

>特殊情况: 比较少,就比如Navbar又有个子组件叫NavbarChild,==但是在Navbar.vue文件中压根没有根节点==(vue3支持,vue2不支持),只有个NavbarChild组件,==那么这个属性会透传给孙子NavbarChild的根组件上== 

- ==组件可以禁止透传(禁止向根节点),也可以通过属性指定透传目标==,如下
  ```
    tempalte:
    <div class="aaa">
        <!-- 下面属性意思是: 向这个标签透传(不影响原生的向根节点透传,如果没有禁止透传,根节点和这个节点都有相同样式) -->
        <button v-bind="$attrs">test</button>
    </div>



    script:
        export default {
            // 禁止透传,来自父组件的透传被阻止了
            inheritAttrs: false,
        }
  ```



### 子传父
- 子传父也需要子和父配合,一个明显区别是: ==父传子是自动的,子传父是被动的,需要触发==
- 父组件方面:(==在子组件自定义一个事件==)
  - 写法1: ` <Child @event="handleEvent"></Child>`
  - 写法2: `<Child @event="handleEvent2($event)"></Child>`
    > 写法1和2的区别就是(),==不带括号的写法可以正常接受子组件传递的参数,而带(),则需要写$event才可以接受==
  - 事件处理函数: (==接受参数的地方==)
    ```
    methods: {
        // 接受子的传递参数(状态),与子组件一一对应
        handleEvent(data) {
            console.log("app-event", data)
        },
        handleEvent2(data) {
            console.log("app-event2", data)
        }
    }
    ```
    > 接受子的传递参数(状态),==与子组件一一对应==,类似于函数的形参接受
  - ==子组件的自定义事件可以是多个==,比如@event1=... @event2=...
      `<Child @event1="handleEvent1" @event2="handleEvent"></Child>`
  - ==这些自定义事件可以加事件修饰符==,例如 .once .self
      `<Child @event.once="handleEvent"></Child>`
- 子组件方面(==触发传递和传参==)
  - **我们知道子传父不是自动的,如何触发子传递父的决定权在子组件那边**
  - ==比如想要通过点击按钮触发传递==
  - 写法1:(==函数法==)
   ```
    template:
        <button @click="handleClick">click</button>

    script:
        methods: {
            handleClick() {
                // console.log(this.childtitle)
                // 通过下面的方法,子就可以触发父的自定义事件了
                // 自定义事件名字,后面写想要传递的状态,如果状态太多,包装进对象传递也行
                this.$emit("event2", this.childtitle)
            }
        }
   ```
  - 写法2:(==直接传递==)
   ```
        <button @click="$emit('event', childtitle)">click</button>
   ``` 
   > 重点总结: 
   > 1.==**传递的关键是$emit()**,第一个参数是想要给那个自定义事件传递,后面的就写要传递的参数,太多了包装进对象即可==
   > 2.写法1函数法相对于直接传递可以对数据进行更多的加工
- ==**子传父的总结**==
  - 父的自定义事件如同接受的钥匙,对应的自定义事件处理函数则为接受子组件参数和加工处理的地方
  - 子组件$emit()第一参数写好要用哪个钥匙,每个钥匙对应着一个父组件自定义事件,后面的参数用来传递子组件的参数
  - 流程就是: 子组件事件触发-->$emit()指定方向和传参-->相关的父组件接受子组件的信息

### 父组件$refs
- **ref - \$refs**: ==通过ref对子组件名字,然后在父组件的js区直接使用"this.\$refs + 名字"调用对应的子组件==
> 注意: 这个方法作为辅助与父传子打配合,但是不能作为主流,因为它的耦合度太高了,后期不好维护
- ==下面是一个简单注册与重置案例:==
- 父组件的ref命名:
  ```
    <!-- 给组件+ref --> 
    <!-- 父传子label和type的信息 -->
    <Field label="用户名" type="text" ref="username"></Field>
    <Field label="密码" type="password" ref="password"></Field>
    <Field label="年龄" type="number" ref="age"></Field>

    <!-- 使用ref获取子组件的数据和修改子组件的值,更简单方便 -->
    <div>
        <button @click="handleRegister">注册</button>
        <button @click="handleReset">重置</button>
    </div>
  ```
  > ==给每个组件设置了ref,并分配了名字,用于区分,在函数功能方法区,我们会使用到这些名字==
- 子组件Field代码:
  ```
    <template>
        <div>
            <label>{{label}}</label>:
            <!-- 动态绑定type类型,后面的type是父传子的信息 -->
            <input :type="type" v-model="myvalue">
        </div>
    </template>

    <script>
        export default{
            data(){
                return{
                    myvalue: ""
                }
            },
            // 接受父的label和type信息并限制类型
            props:{
                label:{
                    type:String,
                    default:""
                },
                type:{
                    type:String,
                    default:"text"
                }
            }
        }
    </script>
  ```
  > ==主要代码是接受父传子的信息,并配给input框,**外加双向绑定v-model(后期注册与重置功能的关键**)==
- 父组件使用$refs控制子组件
  ```   
  js区:
    methods:{
        handleRegister(){
            // 拿到子组件的状态myvalue,同理password和age
            // 然后提交给后端
            // myvalue是子组件的状态,与input进行v-model双向绑定
            console.log(this.$refs.username.myvalue)
            console.log(this.$refs.password.myvalue)
            console.log(this.$refs.age.myvalue)
        },
        handleReset(){
            // 赋空值,重置
            this.$refs.username.myvalue = ""
            this.$refs.password.myvalue = ""
            this.$refs.age.myvalue = ""
        }
    }

  ```
  > ==**通过this.$refs + 名字(ref命名的那个)获取子组件的myvalue值**,实时获取输入框的值,在用户点击注册时,即直接发给后端;点重置则给赋空值.**父组件可以直接对子组件的myvalue状态进行控制**==

### 子组件\$parent \$root
- 重点区分: \$parent 与 \$root  
   ==一个是父组件,一个是根组件==
   - 父组件很好理解,就是当前这个组件的父组件,可以嵌套为爷爷辈等
   - 而根组件,有3个组件A B C,关系是A为B父,B为C父,A只引入了B并使用了B,B引入了C并使用了C,那么相当于A组件使用的B组件内含C组件,C组件在A组件内部,那么他的根组件就是A组件,不论中间有多少层,它的根组件一定是外层的那个组件,解释了为何是A而非B 
  > ==和$ref一样耦合度高,搭配使用,不建议主流==
  - 代码:(A B C 组件)
  - A (==引入B,使用B组件==)
  ```
    A:
    <template>
        <div>
            app 
            <Aparent></Aparent>
        </div>
    </template>

    <script>
        import Aparent from './Aparent.vue';

        export default {
            data(){
                return {
                    title : "app-111",
                }
            },
            components: {
                Aparent
            },
        };
    </script>
  ```
  - B(==引入C,使用C==)
   ```
    <template>
        <div>
            Aparent
            <BChild></BChild>
        </div>
    </template>

    <script>
        import BChild from './BChild.vue';

        export default {
            data(){
                return{
                    title : "parent-111",
                }
            },
            components: {
                BChild
            },
        };
    </script>
   ```
   - C(使用$parent $root)
    ```
    <template>
        <div>
            BChild <button @click="handleClick">click</button>
        </div>
    </template>

    <script>
    export default{
        methods:{
            handleClick(){
                // 拿到父的proxy
                console.log(this.$parent)
                console.log(this.$parent.title)
                // 拿到根组件的proxy,不是爷组件,可以两个$parent叠加,但是那样会很乱
                // App是根组件,Aparent是父组件,最里面的是BChild子组件
                console.log(this.$root)
                console.log(this.$root.title)
            }
        }
    }
    </script>
    ```
    > ==用法和$refs几乎一样,this.(\$parent/\$root) + 要获取的数据,**前半段已经获取到了父组件或根组件了(proxy对象),后面直接'点'想要的状态即可**==

### 跨域通信provide inject
- ==跨域通信主要解决传统的"父子互传"的局限性,也就是当组件嵌套太多时,通过传统的"中间人模式"解决,会造成代码冗余,可维护性低==
  - ==中间人模式==: 中间人模式: 一个父有两个孩子,两个孩子并列,且内部没有嵌套的组件了,可以通过(孩子->父->另一孩子)的方式,让父作为两个孩子联络的中间人(我们的案例做过,子父互传案例中有) 
  - ==中间人模式的局限性==: 当孩子内部由嵌套了许多层组件,就会很麻烦,由此引申出跨域通信
  - ==跨域通信==: 可以跨多层组件的传递,例如爷爷辈向孙子辈直接传递数据,跨过了父辈,不用一级级的中间人模式
  > 注意:**==跨域通信是通过公开信息让其"后代"收到信息(牢记是此组件的"后代"),也就是"辈分"大的组件向"辈分"小的组件公开,不存在反向共享,兄弟间共享,以及没有"血缘"组件的共享(意思是两个组件八竿子打不着,互相中间根本没有任何引入连接关系)==**
- 代码(==**APP是父 Navbar是子**==) 
  - App代码(provide 公开状态)
    ``` 
        methods:{
            provide(){
                return {
                    // 名字 : 属性值
                    navTitle:this.navTitle,
                }
            }
        }
    ```
    > ==**新的公开属性, provide栏**,内部返回的结构为 "名字 : 属性值",上面的操作是App组件公开了自己的navTitle状态,并命名navTitle,**其后代都可以获取这个公开数据**==
    - Navbar代码:
    ```
        <script>
            export default{
                // 注入,承接App的provide
                inject:["navTitle"]
            }
        </script>
    ```
    > ==获取公开信息很简单了,设置新的属性inject,使用数组获取公开的信息,就可以在子组件使用了==
- ==**单项数据流**==: ==后代可以用,也可以在后代里面更改值,但是这里的总公开处的值不会变==,还是老问题,如果任意一个后代都能修改这里的值,那就乱套了,别的后代使用这个值时被更改了会出乱子的
  - ==当然有一个不安全的曲线方式可以解决单项数据流==
  - **即在App把自己公开出去具体为:**
      ```
          provide(){
                return {
                    app: this
                }
          }
      ```
  - 子组件接受后,可以对整个app所有状态修改了 `inject : ["app"]`
  > ==这个方式依旧有风险,等学习到**组合式**就有更好的解决方案了==
### 跨域通信的案例(不安全的方式)
- ==解决中间人办法时,**但是App公开了自己的this,所以不安全**==
- ==实现功能,**点击Tabar里的TabarItem标签时,Navbar头标文字对应改变**==
- 效果图:[![pAwqPPA.png](https://s21.ax1x.com/2024/10/26/pAwqPPA.png)](https://imgse.com/i/pAwqPPA)
- 代码:(==截取关键重点部分==)
- 简单介绍组件关系: ==App是总组件,Navbar和Tabar是兄弟关系,都是App的儿子,在App里并列使用,Tabar有个儿子TabarItem==
  - App代码(==公开自己和**设置状态navTitle**==)
    ```
        data(){
            return{
                navTitle: "首页111"
            }
        },
        provide(){
            return {
                app : this
            }
        },
    ```
  - Navbar(==接受app的信息,实时改变头栏的信息==)
    ```
        <template>
            <div>
                <button>返回</button>
                // 使用app的navTitle状态
                <span>{{app.navTitle}}</span>
                <button>首页</button>
            </div>
        </template>

        <script>
            export default{
                // 注入,承接App的provide
                inject:["navTitle","app"]
            }
        </script>
    ```
    - Tabar(==配置TabarItem的信息,自己本身没啥内容==)
    ```
        template:
            // 通过v-for提取datalist数据,再父传子把data通过item动态绑定给子组件
            <TabarItem v-for="data in datalist" :key="data" :item="data"></TabarItem>

        js:
            data(){
                return {
                    datalist : ["首页","列表","我的"]
                }
            }
    ```
    - TabarItem(==构建li结构,改变app的navTitle值==)
    ```
        template:
            <li @click="handleClick">{{ item }}</li>
        js:
            // 接受父传子: 
            props: ["item"],
            methods:{
                handleClick(){
                    // 修改App的navTitle为选项名字item
                    this.app.navTitle = this.item
                }
            },
            // 接受公开数据: 
            inject:["navTitle","app"]
    ```
    > 总结: ==App公开自己,设置了状态navTitle,**这个navTitle是关键**,TabarItem通过点击处理函数改变app中navTitle的值,这时Navbar实时获取App内的navTitle的信息,实现了和TabarItem传输数据的同步,**这是一个间接影响,中间人是App的状态navTitle**==
### 订阅发布模式
- ==更深层的知识思路,详见kerwin录制的js高级设计模式(6h+),详细讲过"订阅-发布模式",这是个纯js思路的新思维,**订阅发布模式是vuex的基石**==
- **本节课为最简单的模式逻辑,更深入的看看课程,如下**
- store.js文件(新建js文件)
    ```
        // 看kerwin的js设计模式(6h)学习更多~
        export default{
            datalist:[], // 存储
            subscribe(cb){ // 订阅
                this.datalist.push(cb)
                console.log(this.datalist)
            },
            publish(value){ // 发布
                // 遍历datalist数组,每一项cb都是一个函数,并调用
                // 发布时携带参数,执行携带参数的回调函数
                this.datalist.forEach(cb=>cb(value))
            }
        }
    ```
    > 分为三部分
    > 1.datalist是函数存储箱,放函数的
    > 2.subscribe订阅函数,作用是把函数作为参数传入,再把函数放入数组datalist
    > 3.publish发布函数,作用是遍历datalist数组,把里面的所有函数执行一遍,并在执行发布函数publish时,传入参数value,这个value又会作为形参被传入datalist内部的每个函数中执行
    > ==注意: 使用订阅发布模式,别忘了把js文件引入!==
### 非父子通信-订阅发布案例+mounted函数
- ==本案例是**使用"订阅-发布模式"(和父子通信完全无关)去解决跨域通信案例**,属于跳出五行外不在三界中了==
> 
- ==**引入新概念生命周期函数mounted()**(在Navbar使用了):Navbar组件挂载到页面中时,会立即自动执行内部代码,输入另起一行的新方法,mounted(){.....}==
- 代码:
- store.js(==**核心,纯js,和上面的例子一样的,这里不写了**==)
>
- Tabar(==**还是构建TabarItem,没变,详见跨域通信案例,这里也不写了**==)
>
- Navbar:(==订阅函数,函数内容为接受参数value,修改自己的title==)
    ```
        <template>
            <div>
                <button>返回</button>
                <span>{{ title }}</span>
                <button>首页</button>
            </div>
        </template>

        <script>
            import store from './store.js'

            export default{
                data(){
                    return {
                        title: "首页"
                    }
                },
                // 纯js方法-订阅方法模式-vuex的重要基石
                // 提前引入生命周期-mounted()概念, Navbar组件挂载到页面中时,会立即自动执行内部代码
                mounted(){
                    // console.log("12345")
                    // 订阅方法执行 ---> 把回调函数放入datalist数组
                    // 订阅方法传递的回调函数是自带参数的,配合发布时传入参数
                    store.subscribe((value)=>{
                        console.log("我被触发了",value)
                        this.title = value
                    })
                } 
            }
        </script>
    ```
- TabarItem:(==发布函数,把自己的item作为参数传入并执行函数==)
    ```
        <template>
            <li @click="handleClick">{{ item }}</li>
        </template>

        <script>
            import store from './store.js'

            export default {
                props: ["item"],
                methods:{
                    handleClick(){
                        // 点击按钮进行发布调用
                        // 传递参数给store,发布时带上这个参数
                        store.publish(this.item)
                    }
                },
            }
        </script>
    ```
> 总结: 
> ==1.store.js文件中定义:== 
> 订阅函数: 只用传递函数进入数组即可 ; 发布函数: 执行所有存入数组的函数,并且可以携带一个参数,作为执行函数的形参
> 2.==Navbar==: 订阅了一个函数进入数组,函数要求传递参数,这个参数将会赋值给自己的title状态(我们看代码就知道这个状态是头栏的文字显示状态)
> 3.==TabarTitle==:发布函数,因为数组就一个Navbar订阅的函数,所以就执行它一个,然后传递参数,这个参数正是底栏的文字显示item,通过点击触发
> 4.==本案例纯使用"订阅-发布"思路完成,是最简单的订阅发布模式,没有用任何父子通讯的知识==

## 组件进阶
### 动态组件
- ==**提示:组件的基本用法忘了去看Vue CLi项目构建章节的自定义标签和局部组件的相关知识**==
- ==动态组件,内置的,固定写法,锦上添花的功能,**vue3独有**==
- **语法**: `<component :is="which"></component>`
- **意思**:  ==is后面写的谁,就是哪个组件,例如引入了组件Navbar,如果which是Navbar,那么这个动态组件自动转化为Navbar组件,**我们可以动态绑定这个is属性,这样which就更加灵活了**==
- **功能描述**:==**在"订阅-发布"案例下新增功能**,App引入了Home List Center三个组件,新增功能就是点击TabatItem后,显示对应的页面,而这3个组件就是对应的页面结构==
- 如图:[![pAwGkd0.png](https://s21.ax1x.com/2024/10/25/pAwGkd0.png)](https://imgse.com/i/pAwGkd0)
- 代码:
  ```
    App:
    template: 
    <component :is="which"></component>

    methods:
    mounted() {
        var obj = {
            "首页": "Home",
            "列表": "List",
            "我的": "Center"
        }
        store.subscribe((value) => {
            // console.log(value)
            // 使用箭头函数,是顾及this的指向问题
            // 将汉字->对应的组件名,方便动态组件绑定
            this.which = obj[value]
        })
    }
  ```
  > 在mounted(生命周期函数)中,一旦App.vue启动,就自动执行,内部是对信息的处理,我们获取到点击栏目的值后,把对应的汉字转化为了对应的组件英文名字
- ==**动态组件的原理和v-if一样,是创建-销毁机制,这个机制有个瑕疵,有些数据无法缓存**,当下次切换回来时,比如输入框等输入的文本数据会消失,为此vue提供了数据缓存方法==
    - 缓存相关代码如下:
        ```
            1.我们希望有数据缓存,存储用户输入的数据或网络请求的数据和页面,如下
            即对所有的数据缓存
            <keep-alive> // 有时keep-alive也写作KeepAlive
                <component :is="which"></component>
            </keep-alive>
            
            2.有时我们想要有的缓存,有的不缓存,如下
            include后面写的名字,需要在组件中使用name返回出去,具体看三个组件的export default代码 
            <KeepAlive include="home,list">
                <component :is="which"></component>
            </KeepAlive>

            3.也支持动态表达+正则表达式写法 :include= "/home|list/"
            4.数组写法也支持, :include= "['home','list']"
            5.排除法也行 exclude 意为不包含
        ```
    - 缓存组件内部配合(Home为例子)
        ```
            <script>
                // include使用的名字
                export default{
                    name : "home"
                }
            </script>

        ```
    > ==**重点总结**==
    > 1.缓存写法楼两个,XX-XX写法和双驼峰写法
    > 2.有时我们需要对部分数据缓存,+include即可,==但是记得需要子组件打配合==
    > 3.include可以写死具体那些组件的数据需要缓存,也可以动态绑定+正则/数组
    > 4.还有排除法,即哪个组件不缓存,其余一样,exclude

### 组件中的v-model
- ==要想真正从**内核学会使用v-model**解决问题,需要细致拆开v-model在这个语法糖的内核代码==
- ==v-model的庐山真面目==:
  - 语法糖: `<input type="text" v-model="myvalue"> {{myvalue}}`
  - 真面目: `<input type="text" :value="myvalue" @input="handleIpt">  {{myvalue}}`
    > 1.value属性本身就是input的原生属性,代表输入框内的值,如果不动态绑定,那么就是个字符串,所以动态绑定,里面是状态myvalue
    > 2.v-model的双向绑定属性,"状态->输入框"已经由动态绑定value实现此功能了,再通过函数handleIpt完成双向绑定中的"输入框->状态"
  - 配置handleIpt函数和状态myvalue如下:
    ```
        data() {
            return {
                myvalue: ""
            }
        },
        ----------------------------------------------
        // 不带()函数的写法会得到一个事件对象evt
        methods:{
            handleIpt(evt) {
                this.myvalue = evt.target.value
            }
        }
    ```
  - ==对于函数方法的写法,还有个简写==
    - 代码: `<input type="text" :value="myvalue" @input="myvalue = $event.target.value"> `
    - 区别: ==不写函数了,后面写个表达式==(记得num++那个购物车案例数量加减也是这么写的),==这里的evt获取必须写固定的$event==,这个事件处理函数可以通过target获取input的don对象,进而获取其value值 
- ==**利用v-model的底层代码(纯子父互传)去完成当时Field功能(来自父组件$refs) 重述功能: 输入框 + 注册 + 重置**==

  - 父组件App.vue的代码:
    ```
      template:
      1.父传子,传递的名字value,传递的值是状态myvalue的值,动态绑定为了传的myvalue不作为字符串传递进去
      2.子传父,自定义事件@myEvent接受输入框实时的值
      <Field label="用户名" :value="myvalue" @myEvent="handldEvent"></Field>

      js: 子传父(value是子传递过来的数据)
      handldEvent(value) {
          console.log("孩子给我的结果", value)
          this.myvalue = value
      }
    ```
  - 子组件Field.vue的代码:
    ```
      template:
          1.这个value动态绑定,前面的是input原生属性 后面的就是父组件传过来的状态 
          2.函数的作用: 监听输入情况,然后使用函数+evt获取值,最后子传父
          <input :type="type" :value="value" @input="handleInput"> 

      js: 
          props:{
              // 直接接受来自父的值
              value: {
                  type: String,
                  default: ""
              }
          },
          methods: {
          handleInput(evt) {
              // 打印测试,看看是否获取到了子组件input的值
              //console.log(evt.target.value)
              // 传打电话传给父,自定义事件名为myEvent
              this.$emit("myEvent",evt.target.value)
          }
      }
    ```
- ==**直接利用v-model语法糖,这时命名的规则就要听从vue3内部的内置代码了**==
  - ==vue3自己提供的内部代码,**对应动态绑定的value和自定义事件myEvent是有自己的写法的**==
  - 模板为:`:modelValue="searchText" @update:modelValue="newValue => searchText = newValue"`
    > ==即动态绑定名字变为**modelValue**,自定义事件名字变为 **@update:modelValue**==
  - ==这时只需要更改子组件对应的名字即可复现其功能==,**任何组件都可以挂v-model,不过要顺应v-model语法糖内部语法的命名规则**
   >
- ==**使用v-model语法糖来重构代码**==
  - ==默认状态下的代码(App)==: `<Field label="用户名" v-model="myvalue"></Field> // 直接语法糖`
  - ==Field组件==(==**注释详细写明改名处**==):
    ```
        tempalte:
        // 动态绑定的状态 value -> modelValue
        <input :type="type" :value="modelValue" @input="handleInput">

        js:
        props:{ // 接受父组件的信息
            // 名字value->modelValue
            modelValue: {
                  type: String,
                  default: ""
              }
        },
        methods:{
            handleInput(evt) {
                // 更改为vue3内部的自定义事件
                // 自定义事件名字(钥匙) 
                // 钥匙名字 myEvent->update:modelValue
                this.$emit("update:modelValue", evt.target.value)
            }
        }
        
    ```
- ==**vue3支持自定义改名字,即不用vue3默认的名字**==
  - ==改名字==: 如果在绑定时写v-model:kerwin 源代码会被修改为 `:kerwin="myvalue" @update:kerwin=""`,==即你的父传子属性和自定义事件都改名字了,这样子是方便一个标签写多个v-model去实现多个功能==
      - ==App代码==: `<Field label="用户名" v-model:kerwin="myvalue"></Field>`
      - ==Field代码:==
          ```
          tempalte:
          // 动态绑定的状态 modelValue -> kerwin
          <input :type="type" :value="kerwin" @input="handleInput">

          js:
          props:{
              // 接受父组件的属性:
              // 名字modelValue -> kerwin
              kerwin: {
                    type: String,
                    default: ""
                }
          },
          methods:{
              handleInput(evt) {
                  // 改名写法(钥匙名变了) update:modelValue -> update:kerwin
                  // this.$emit("update:kerwin",evt.target.value)
              }
          }  
          ```
### 异步组件
- ==异步引入组件==: 在组件过多时,按需加载组件,不需要刚开始就把所有组件加载,这样会很卡,所以则有了异步组件
- ==**引入异步方法**:(vue原生的方法,在js区引入)==:`import { defineAsyncComponent } from 'vue';`
- 本次使用异步组件基于动态组件案例,再看看图:[![pAwGkd0.png](https://s21.ax1x.com/2024/10/25/pAwGkd0.png)](https://imgse.com/i/pAwGkd0)
- ==我们使用异步组件的方式,**使得Home List Center三个组件成为异步组件**,当我们点击对应底部栏时,才会加载组件内容,而非一开始加载,**具体可以在终端-网络-js请求区,去看看是不是点击后才对对应的组件进行网络请求**==
- 代码(==直接看如何使用==)
  ```
        components: {
            Home: defineAsyncComponent(()=>import('./views/Home.vue')),
            List: defineAsyncComponent(()=>import('./views/List.vue')),
            Center: defineAsyncComponent(()=>import('./views/Center.vue'))
        }
  ```
    > 代码提示:
    > 1.异步组件方法在==components里面挂载==
    > 2.语法为: ==组件名: define...(箭头函数()=>import('相对地址'))==
- **异步组件还可以配置加载中和加载失败的页面**,==配置的不再是箭头函数,是一个对象,内部的属性都是固定写法==
- 代码(==以center组件配置为例子,**注释很详细了**==):
  ```
     Center: defineAsyncComponent({
        // 1.引入地址
        loader: ()=> import('./views/Center.vue'),
        // 2.记得加载和加载失败的组件照常引入
        // 2.1加载组件使用的组件
        loadingComponent: loadingComponent,
        delay: 200, // 200ms没有加载出来就显示加载组件的内容
        // 2.2加载失败后展示的组件
        errorComponent: errorComponent,
        timeout:3000 // 同理3s加载不出来就显示加载失败
        // 注意: 如果是网络慢,显示加载失败了,但是最终网络还是加载出来了,那么还是还会正常显示的
        // 如果网络断了,直接就会显示加载失败页面
        // 所有的网络速度调试都在终端-网络-网速,有正常网,3G网,断网等选项
    }),
  ```
## 插槽
### 插槽的基本应用
- 插槽的作用: ==为了更好实现组件的复用性,看完插槽用法再详细介绍插槽的必要性和优势==
- ==**具体插槽是什么?**== 
  - 比如我们引入了个组件Child,一般我们只是使用这个标签放置在template区域,但是内部是不写东西的,如果里面写东西了,我们可以认定写的东西是"磁带卡",如果没有"卡槽",也无法显示,那么插槽需要子组件打配合,**子组件提供"卡槽",父组件提供"磁带卡",两个结合起来就是插槽的功能了**
- ==具体代码: (App父)==
  - `<Child> <div>我在app组件的html代码</div> </Child>`
- ==Child(子):==
    ```
        <template>
            <div>
                <!-- 插槽 -->
                <slot></slot>
                child
                <slot></slot>
            </div>
        </template>
    ```
    > ==**这个slot标签就是"卡槽"**,我们在父App写的"磁带卡"代码就会在对应的位置显示(**插槽成功**)==
- ==**插槽的具体作用就在这里**==:
  ==例如: 我们做轮播图组件时,用户想要轮播自己的图片和文字,并且想要不同的布局格式,比如文字在图片左边等,如果通过传统的父传子,给子组件Child传递信息,需要传递太多的img和文字模板了,还要传递样式要求,然后在子组件中判断样式之后再显示对应的dom布局格式,仔细想就知道要传递多少的信息,十分复杂冗余==
  **而插槽完美解决这一痛点,我们只需要把轮播的样式做出来,在对应的位置放好插槽,用户想要什么布局格式按照对应位置插入即可,并且图片文字啥的跟随着插入,也就不需要传递信息了,组件只需要完成轮播的样式显示,即轮播的效果就可以了,至于内容和布局,用户自己使用插槽放入即可**
  ==**相当于用户自己在组件里面写代码,添加信息,而组件只是把这些用户写的代码放入对应的子组件卡槽位置,实现高级的复用,这样组件的内容就不再是组件开发者开始时写死的了,用户可以通过卡槽向组件输入自己需要的信息**==

### 具名插槽
- ==具名插槽==: 想要实现多个插槽,需要给每个"卡槽"命名,这样使用者就可以根据"卡槽"名,把自己的代码("磁带卡")分门别类地插入自己想要的对应位置("卡槽")
- 代码(==子,卡槽命名==)
  ```
    <!-- 插槽 -->
    <slot name="one"></slot>
        child
    <slot name="two"></slot>
  ```
- 代码(==父,按名字找卡槽位置,**有简写方法**==):
  ```
    // template自己不会显示
    <template v-slot:one>
            <div>app111111</div>
    </template>
    <!-- 简写 -->
    <template #two>
            <div>app222222</div>
    </template>
  ```
  > 1.父中使用template,是因为它自己不会显示
  > 2.如果子的插槽没有命名(万能卡槽),那么父中没有slot指向的代码都会进去
  > 3.子与父的slot需要配对,如果出现"磁带卡"与"卡槽"不匹配,直接不显示
  > 4.==**在vant4网站中有许多别人写好的组件,而在这些组件中插槽几乎是必须品,可以看看网站提供的组件说明,利用插槽,用用别人写的组件**==
### 作用域插槽
- ==正常状态下的插槽是有作用域限制的,你写在组件里的代码("磁带卡"),只能使用此文件的状态信息等==,**而不能使用组件内部的状态,这和子父互传单向传输一样,为了防止组件间乱改信息造成混乱**
- ==这个功能还是很好的,继续拿出老案例,在父子互传时就有的老将军案例了==
- 具体如图:
  [![pA0SqGF.png](https://s21.ax1x.com/2024/10/26/pA0SqGF.png)](https://imgse.com/i/pA0SqGF)
- ==解释: App是总组件,内部有2个儿子Navbar和Layout,而Layout的有2个儿子,content和sidebar,我们要实现的功能是,点击Navbar的按钮实现sidebar的显示与隐藏==
- 代码: App (==截取重点部分==)
  ```
    <template>
        <div class="root">
            <!-- 插槽 -->
            <Navbar>
                <!-- 可以访问到父组件,直接改变isShow的值即可 -->
                <button @click="isShow = !isShow">展开/折叠侧边栏</button>
            </Navbar>
            <!-- 父传子,动态传值 -->
            <Layout class="layout" :myshow="isShow"></Layout>
        </div>
    </template>
  ```
    > ==isShow是App的一个状态==,在Navbar插槽中通过点击去切换状态,然后子传父给layout组件
- 代码(Navbar)
    ```
    <template>
        <div>
            <!-- 插槽接待处 -->
            <slot></slot>
            <div>vue3的单文件navbar</div>
        </div>
    </template>
    ```
    > ==父组件的button代码通过插槽进入Navbar,Navbar组件得以显示这个button,通过点击触发事件,改变isShow的值,**注意,这时isShow由于作用域问题,只能改变App内的isShow的值,正好省的再子传父了,这样父的isShow可以实时收到Navbar点击按钮的影响进行改变,之后再传入layout,再由layout去显示隐藏自己的孩子,layout代码略**==
- ==作用域的硬性规则也可以打破,使得父组件的"磁带卡"即可以访问自己父组件的内容也可以访问到子组件的内容==
- 语法:(==App引入子组件Nowplaying,需要子组件的datalist数据==)
- 子组件:(==暴露父组件想要使用的数据==)
  **==语法结构==** : `:自定义属性名字="想要暴露的状态名"`
  ```
        <slot :mylist="datalist" name="movie">
            <ul>
                <li v-for="item in datalist" :key = "item.id">
                    {{item.nm}}
                </li>
            </ul>
        </slot>
  ```
  > ==子组件的卡槽,自定义一个属性名,未来取用这个属性值时按这个名字找,暴露子组件的状态datalist,动态绑定为了暴露变量而非字符串==
  
- 父组件:(==获取子组件暴露数据==)
- **==语法结构(标准)==** : `v-slot:组件卡槽name名字="随意起名(本次例子起名为myprops)"`
  ```
    <Nowplaying v-slot:movie="myprops">
        <li v-for="data in myprops.mylist" :key="data.id">
            {{data}}
        </li>
    </Nowplaying>
  ```

  > 1.接受子组件所有的暴露属性,存入myprops这个对象,==通过myprops.XXX按需取用==
  > 2.如果子组件卡槽没写名字name,直接v-slot="XXX"
  > 3.==v-slot:movie 可以简写为 #movie==
  > 4.==可以通过结构赋值获取对象中自己想要的值,#movie={mylist}即可,之后myprop.mylist就全变为mylist即可==
### 插槽作用域之猫眼
- 需求: ==用户想要再猫眼的电影列表上添加一个模糊搜素功能,实现被搜索的电影词条实现标红放大效果,但是猫眼的数据在组件的datalist中,按道理用户使用组件但是无法访问到组件内部的数据==,**这时开发者可以提前将组件中的猫眼数据暴露出去,如果有用户想用,直接获取即可**
- 猫眼组件代码:
    ```
    <template>
        <div>
            <!-- 暴露datalist数据,如果父组件没有使用插槽,那么就默认继续显示下面的源代码即可 -->
            <slot :mylist="datalist" name="movie">
                <ul>
                    <li v-for="item in datalist" :key = "item.id">
                        {{item.nm}}
                    </li>
                </ul>
            </slot>
        </div>
    </template>

    <script>
        // 使用axios
        import axios from 'axios'

        export default{
            data(){
                return {
                    datalist:[]
                }
            },
            mounted(){
                // console.log("123");
                // 在自己服务器请求可以省略协议和域名 还是猫眼的数据
                // fetch("054test.json").then(res=>res.json()).then(res=>{console.log(res)})
                // console.log(axios)
                axios.get("054test.json").then(res=>{
                    // console.log(res.data.data.hot)
                    // 箭头函数确保了this指向同步于外面
                    this.datalist = res.data.data.hot
                })
                
            }
        }
    </script>
    ```
    > ==信息提取: 引入axios,和之前案例一样,提前把猫眼后端的数据存入本地json文件中,通过axios模仿网络请求获取,然后把获取的响应数据赋值给状态datalist,最后把datalist暴露出去,名为mylist==
- 用户的代码(==获取猫眼暴露的datalist数据==)
   ```
    <template>
        <div>
            <!-- 模糊搜索添加样式 -->
            <input type="text" v-model="mytext">
            <Nowplaying v-slot:movie="myprops">
                <ul>
                    <!-- 使用暴露的属性mylist,从对象中提取,其余的相同 -->
                    <!-- 突破了作用域显示,能用自己的,也能用儿子的 -->
                    <li v-for="data in myprops.mylist" :key="data.id">
                        <!-- 模糊搜索添加样式 -->
                        <div v-if="data.nm.includes(mytext) && mytext != ''" style="color:red; font-size: 20px;">
                            <img :src="data.img" style="width:100px">
                            {{ data.nm }}
                        </div>
                        <!-- 没有匹配就没样式 -->
                        <div v-else>
                            <img :src="data.img" style="width:100px">
                            {{ data.nm }}
                        </div>
                    </li>
                </ul>
            </Nowplaying>
        </div>
    </template>
   ```
   > 提示: ==重点看如何引入组件的暴露数据datalist,以及使用它重新构建了猫眼的电影列表==,**至于模糊搜索includes和样式添加,不是本案例的重点**
## 生命周期
### 创建阶段
- ==每个组件的创建都有一套生命周期,开发者可以使用生命周期钩子函数,在特定阶段运行自己的代码==
- ==生命周期钩子执行顺序(**选项式**)==: beforeCreate -> init Options API(开发者自己创建data methods等) -> created -> beforeMount -> 模板编译过程(tempalte编译)  -> mounted
- ==各个生命周期阶段的详细介绍:==
  - beforeCreate: ==几乎不用==,什么都没有,定义的东西啥都还没创建呢,啥也访问不到
  - create: 可以访问到自己定义的所有东西,这也是在网页显示之前最后一次修改它们的机会了,==可以在这里修改数据和初始化数据(记得+this)==
  - beforeMount: ==几乎不用==,tem编译之前,还没挂载dom节点,访问不到dom节点
  - ==**mounted(最常用**==): 挂载dom节点完成,可以访问到dom节点,只有这里可以访问dom,==vue使用dom一般是调用第三方库去实现一些功能==
  - ==常用于 订阅,ajax fetch axios等网络请求,间隔定时器setInterval==
    > 注意: ajax放在非mounted发送请求,你发现也会请求到数据,原因是发ajax是异步的,等你网络请求回来,钩子函数早执行完了(到mounted阶段),所以就可以正常显示,但是我们习惯把它放在mounted函数中去使用
- ==**总结**==:
  - beforeCreate: 什么都访问不到,这时候连最基本的状态都没有
  - create: 已经可以访问到data mehods computed等数据了
  - beforeMount: 访问不到dom节点
  - mounted: 可以访问到dom节点
- 来一个具体实例(==使用echarts: 基于js的图形绘制第三方库==)
- 在这个实例中,我们体会下vue使用dom来引用第三方库的操作,其中echarts是个不错的js绘图工具,按照官方文档学习基本用法
- 代码:
  ```
    <template>
        <div>
            app---{{title}}
            <!-- <div id="main"></div> -->
            <div id="main" style="width: 600px;height:400px;"></div>
        </div>
    </template>

    <script>
    // echarts: 基于js的图形绘制第三方库
    // 导入echarts库,查看官方文档写法, 意思是把所有的方法(*)存入(as)这个对象中(echarts)
    // 在之后使用方法是,就echarts.XXX即可
    import * as echarts from 'echarts';
    export default{
        data(){
            return {
                title : "12345",
                obj : {}
            }
        },
        beforeCreate(){
            console.log("beforeCreate: ",this.title)
        },
        created(){
            console.log("created: ",this.title)
            // 显示前最后一次修改机会
            this.title = "000000"
            // 初始化工作: 记得加this
            this.obj.a = "aaa"
            this.option = {
                title: {
                text: 'ECharts 入门示例'
                },
                tooltip: {},
                legend: {
                data: ['销量']
                },
                xAxis: {
                data: ['衬衫', '羊毛衫', '雪纺衫', '裤子', '高跟鞋', '袜子']
                },
                yAxis: {},
                series: [
                {
                    name: '销量',
                    type: 'bar',
                    data: [5, 20, 36, 10, 10, 20]
                }
                ]
            };
        },
        beforeMount(){
            console.log("beforeMount: ",document.getElementById('main'))
        },
        mounted(){
            // 访问dom的用处: (echarts模块已经npm下载好了,记得引入)
            // 来自官方文档的例子
            var myChart = echarts.init(document.getElementById('main'));
            // option在create里赋值,不让代码在这里冗余,create做做初始化工作挺好的
            myChart.setOption(this.option); // 记得加this才能访问到
        }
    }
    </script>
  ```
  > 总结: 
  > 1.可以看看官方文档的引入操作,注释中解释了这种引入方式,不同第三方工具的引入操作不一定相同,当发现引入失败时,及时查看文档是如何引入的
  > 2.我们把option的配置写在了create中,分散了代码,防止都堆在mounted中,==注意这时无论是定义还是使用都需要加this,create使用this.option初始化了新的状态,而counted也要通过this去获取==
  > 3.dom操作主要是第三方工具需要dom节点区承载它们的方法,来实现具体功能,比如mounted代码中,echarts的init方法需要一个参数,这个参数就是图标显示标签的dom节点
### 更新阶段
- 在mounted阶段,如果我们要更新数据,==就有beforeUpdate和updated两个阶段,前者是还没更新且几乎不用,后者是更新完成常常使用==
- 只要涉及到数据的更新就会有beforeUpdate和updated,==**更新阶段最主要的作用还是操作dom**==
>
- 案例: ==承接echarts的案例,echarts有一个方法resieze(),一旦图标的大小改变调用它就会重构图标大小==
- 正常思路写,如下
  ```
    <template>
        <div>
            app---{{ title }}
            <button @click="handleClick">改变echarts宽度为800px</button>
            <!-- 把style变为动态绑定,对象格式,并把宽度改为变量mywidth,初始化为600px -->
            <div id="main" :style="{ width: mywidth, height: '400px' }"></div>
        </div>
    </template>

    js:
    handleClick() {
        this.mywidth = '800px'
        ------------------------
        console.log(document.getElementById('main').style.width);
        // 发现还是600px,因为生命周期中,更改dom是异步的,是需要时间的,操之过急改完后没有等待生命周期的更新,就会发现还没改呢就调用resize()
        // 这时updated作用就体现出来了
        ------------------------
        this.myChart.resize()  
    }
  ```
  > 主体: myChart的构建没变,核心逻辑就是再设置完宽度后,立即执行myChart.resize(),发现图标没变
  > 原因: 因为任何数据的改变都会涉及更新阶段(updated),这是异步执行的,但是代码中在更改完成后,直接resize,操之过急了,还没等updated把dom的width给改了,你就resize,数据还是原样的,正如代码中,你可以在中间打印一下width看看变没变
- 一轮修改(==把图标的修改操作放入updated中==)
  ```
   js:
   updated(){
        // 这里的don已经更新完成了,width已经800px了
        console.log("updated",document.getElementById('main').style.width)
        // 这时再更改就可以了
        this.myChart.resize()
    },
  ```
  > 还有个小瑕疵,就是所有的数据更新都会自动执行一次update,比如此vue还有一些状态,你改变了它的值,也会执行updated,那么myChart.resize()会无意义执行一次,这样不好,所以还有更好的方案
- 最终修改:(==使用了新语法nextTick==)
  ```
     handleClick() {
        this.mywidth = '800px'
        // 下面的方法是一个一次性调用的函数(只能用一次,修改多次就多写几个nextTick),周期在updated后,所以不用担心width没有更新,它只关联当前状态mywidth,只有当它改变时才会执行,把resize函数放着里面更好,不再收updated影响了,特事特办,提升性能
        this.$nextTick(()=>{
            console.log("nextTick",document.getElementById('main').style.width)
            this.myChart.resize()
        })
    }
  ```
  > 1.`nextTick(()=>{})`==**是一个一次性调用的函数**==(只能用一次,修改多次就多写几个nextTick),==周期在updated后==,所以不用担心width没有更新
  > 2.==它只关联当前状态mywidth,只有当它改变时才会执行==,把resize函数放着里面更好,**不再收updated影响了**,特事特办,提升性能
  > 3.==不过一次性使用也有局限性==
### 销毁阶段
- 销毁组件操作,组件内部的一切都会被销毁
- 组件销毁: ==beforeUnmount unmounted,老样子,前者是销毁前,几乎没用,后者是销毁后,组件的一切都没了== 
- ==什么时候会销毁?==
  - 比如v-if挂组件上,当结果为false时,就会被销毁
- ==销毁组件的用处==: 在销毁阶段我们也有事情要做,==比如我们在组件内部绑的定时器,这是绑定在windows上的,组件的销毁并不能带走它==,所以需要他特事特办,对定时器解绑,==**即销毁阶段唯一要做的事情就是,销毁那些不会跟随组件一起被销毁的属性,方法等**==
- 案例: (==APP父,Child子,子内部挂载一个定时器==)
- App父(==销毁子组件Child==)
  ```
    <template>
        <div>
            app
        </div>
        <!-- 销毁组件操作,组件内部的一切都会被销毁 -->
        <!-- <button @click="isCreate = !isCreate">delete Child</button> -->
        <Child v-if="isCreate"></Child>
    </template>

    js:
    mounted() {
        console.log("App-mounted")
    }
  ```
- 子Child(==销毁自己的定时器==)
  ```
  js:
    mounted(){
        console.log("Child-mounted")
        // 挂载在windows上的监听窗口大小变化的监听器,即使组件没了,也依然存在,需要特事特办去销毁它
        window.onresize = ()=>{
            console.log("resize")
        }
    },  
    unmounted(){
        console.log("unmounted")
        // 销毁windows挂载的方法
        window.onresize = null
    }
  ```

  > ==重点1==: 父组件通过v-if销毁了子组件,子组件在mounted中定义了定时器,在unmounted中销毁了定时器,如果不销毁,那么定时器不会消失
  > ==重点2==: 多个组件使用同一个window挂载方法,只要其中一个销毁,其他的组件也会跟着销毁掉,例如引入Child和Child2两个组件都有window的onresize,如果销毁Child时把onresize也销毁了,那么Child2中的onresize也会失效
  > ==思考==: 看代码,子和父的mounted都有一段打印,谁会先打印
  > ==答==:孩子的mounted先于父的mounted执行,因为父在执行到mounted阶段时,所有的dom都已经完成配置了,可以访问了,这时Child组件作为在template里面的一份子,早就执行完了dom配置
## swiper与vue
### swiper的基本应用
- 我们本节课学习了基本的swiper应用,==内容全在public/html/058test.html内部了,html文件在静态资源库pubilc==,直接访问: localhost:5173/html.058test.html 即可
- ==本次使用swiper的本地文件,即把代码复制到本地==
- 基本使用:
  - 1.引入swiper的css和js
  - 2.按照模板写html(==特别是结构和class名字,这是基石==)
  - 3.==配置Swiper的对象(new Swiper(...))==,内部有许多属性和功能,按照文档提示写,在官方中,有演示区,我们发现新的分页器样例时,打开新窗口显示,查看源代码,看看多了什么代码,然后可以查询其API,看看作用,复制过来用一下,测试效果
  - 4.最后swiper的html内容也不是写死的,我们可以模拟ajax请求去动态实现一个轮播图,也就是接下来的案例代码
- 案例(综合基本使用的四步)
  ```
    <!-- 引入项目组中的css js文件(swiper) -->
    <link rel="stylesheet" href="/lib/swiper.css">
    <script src="/lib/swiper.js"></script>
    <!-- 1.添加基本的css样式 -->
    <style>
        .swiper {
            width: 600px;
            height: 300px;
        }
    </style>

    <body>
    <!-- 2.class名字和结构需要留着,这是响应css和js的html结构 -->
    <div class="swiper">
        <!-- 轮播几页东西 -->
        <div class="swiper-wrapper">
            <!-- 轮播内容不是写死的,全注释了 -->
            <!-- <div class="swiper-slide">Slide 1</div>
            <div class="swiper-slide">Slide 2</div>
            <div class="swiper-slide">Slide 3</div> -->
        </div>
        <!-- 如果需要分页器 -->
        <div class="swiper-pagination"></div>>
    </div>

    <script>

        function init() {
            var mySwiper = new Swiper('.swiper', {
                loop: true, // 循环模式选项

                // 如果需要分页器
                pagination: {
                    el: '.swiper-pagination',
                },

                // 3.我们发现新的分页器案例时,打开新窗口显示,查看源代码,看看多了什么代码,然后可以查询其API,看看作用,复制过来用一下
                // slidesPerView: 3,
                // spaceBetween: 30,
                // centeredSlides: true,

                // 官方网站中 在API文档(有很多别的方法)/事件/Event/sliceChange(swiper) 如下,可以获取当前页的下标,从0开始,和loop结合有BUG
                on:{
                    slideChange: function () {
                        console.log('改变了,activeIndex为',this.activeIndex);
                    }
                }
            })
        }

         // 4.模拟ajax,请求数据,1.5s后动态更改分页内容
        setTimeout(() => {
            var list = ["111", "222", "333"]
            var newList = list.map(item => `<div class="swiper-slide">${item}</div>`)
            console.log(newList.join(""))

            var owrapper = document.querySelector(".swiper-wrapper")
            owrapper.innerHTML = newList.join("")
            // 异步的,填充完内容后在进行初始化,否则初始化速度会快于填充内容,造成无内容显示
            init()
        }, 1500)

    </script>
  ```
    > 注意: ==(模拟)ajax请求是异步的,所以我们要等待请求完数据后再进行new Swiper渲染==,所以包装进init函数,请求后调用init()
### swiper与vue
- 在我们收藏的Swiper中文网站中,我们有 "==开始使用,Swiper核心/API,Swiper Element/Swiper React/Swiper Vue=="
- ==**开始使用**:== 教你如何在项目中使用swiper,比如在vite中,按照里面文档结合目前的swiper11,可以正常使用
- ==Swiper核心/API==: 单纯讲swiper11的所有API,不会的属性可以去查,当然直接在搜索框里查更快
- ==Swiper 元素(Element)==: 一个新型框架
- ==Swiper React==: swiper与react框架结合
- ==Swiper Vue==: **基于vue的swiper组件,就和我们学的自定义组件一样,人家用底层的swiper封装了一个组件,==下一节swiper组件组装,我们也封装一个自己的简单组件==**
- ==重点在于引入swiper进入vite项目==:(根据"开始使用"文档我们选择导入带有所有模块,一般用多少导入多少,按需导入这里省事)
  ```
    import Swiper from 'swiper/bundle';
    import 'swiper/css/bundle';
  ```
- 其余的一样了,正常使用swiper即可,html进入template,==引入和创建new swiper写进mounted函数(即dom创建完了再swiper渲染),也是为了防止updated重复渲染,还是把swiper拿出了updated,放入mounted里了==,css放style里
- 代码:(==迁移swiper基本应用案例的代码进入vite项目==)
  ```
    <template>
        <!-- class名字和结构需要留着,这是响应css和js的html结构 -->
        <div class="swiper">
            <div class="swiper-wrapper">
                <!-- Slides : 结合vue动态绑定 -->
                <div class="swiper-slide" v-for="data in datalist" :key="data">
                    {{ data }}
                </div>
            </div>
            <div class="swiper-pagination"></div>
        </div>
    </template>

    <script>
        import Swiper from 'swiper/bundle';
        import 'swiper/css/bundle';

        export default {
            data() {
                return {
                    datalist: []
                }
            },
            //dom创建好再给配swiper样式
            mounted() {
                // 模拟ajax
                setTimeout(() => {
                    // 更新datalist后不能马上更新dom,要在updated之后
                    this.datalist = ["111", "222", "333"]
                    this.$nextTick(() => { // 只能用一次,之后再改也不好用了,如果再改一次就在跟一个nextTick
                        var mySwiper = new Swiper('.swiper', {
                            loop: true, // 循环模式选项
                            observer: true, // 解决nextTick一次性问题
                            // observer API官方文档作用摘录: 如果你更改swiper 的样式（隐藏/显示）或修改其子元素（添加/删除幻灯片），Swiper 会更新（重新初始化）并触发 observerUpdate 事件,默认 false ，不开启动态检查器，此时可以使用 update() 方法手动更新。
                            // 按道理这样我们创建swiper可以不必关心datalist的变化了,像放哪都行,但是由于轮播循环底层js代码的问题,如果不这样写,会出BUG,除非你没有循环样式,那样随便
                            // 这个底层js代码,我们之前写过轮播图的js代码,即实现循环需要第一页和最后一页连接,所以必须要有轮播内容初始化,没有初始化何来第一页与最后一页,所以在初始化后,即datalist不为空之后我们new Swiper + 循环loop时才会正常
                            // 不过这个observer也解决了一个问题,那就是nextTick一次性的问题,后续更改swiper样式的变化都交给observer去监听了,不过它还是要写的,因为第一次数据更新,需要常规nextTick去解决,它的周期在updated之后,且会响应一次(只有一次)datalist的变化,调用new Swiper完成数据的初始化(从无到有),杜绝了空datalist造成的new Swiper + 循环loop的BUG

                            pagination: { // 如果需要分页器
                                el: '.swiper-pagination',
                            },
                            // 和循环在一起出BUG
                            // on: {
                            //     slideChange:  function() {
                            //         console.log('改变了,activeIndex为', this.activeIndex);
                            //     }
                            // }
                        })
                    })
                }, 2000)
            },
            updated() { // 为了防止改数据频繁调用updated,我们再次用nextTick,给拿走

            },
        }
    </script>


    <style>
        .swiper {
            width: 600px;
            height: 300px;
        }
    </style>

  ```
    > ==1.重点看下原swiper从html文件进入项目vite文件vue过程中的代码分配工作,看看位置变化==
    > ==2.思考new Swiper的位置为何不在updated里面,上面有答案==
    > ==3.swiper 新API observer与loop的局限,对nextTick的改善,以及有observer的swiper初始new为何还要限制在nextTick内,没有自由身,**均在注释中**==
### swiper组件组装
- 官方基于swiper底层封装了一个组件swiper Vue,那么我们也封装一个简单的,基于swiper的组件myswiper
- 本次封装基于最大化方便使用
  - 组件1 Myswiper 来自 myswiper.vue 起作用是完成swiper的核心创建,以及接受属性完成部分功能的用户自定义
  - 组件2 Myswiperitem 来自 myswiperitem.vue,只是帮你写好了基础的div和class名字
- 代码: App(==父,引入了两个组件==)
  ```
    tem:
    // 组件名字为Myswiper,往里面子父互传,父传子(:)指导swiper组件格式,子传父(@)返回分页器的一些数据,比如现在分页器到第几页了
    <Myswiper v-if="datalist.length" :slides-per-view="3" :space-between="50" :loop="false" @kerwinSildeChange="handleChange">
            // Myswiperitem帮你写好了div和class
            <Myswiperitem v-for="data in datalist" :key="data"> {{ data }} </Myswiperitem>
    </Myswiper>

    js:
    mounted() {
        // 模拟ajax 2s后再给数据
        setTimeout(()=>{
            this.datalist = ["111","222","333","444","555"]
        },2000)
    }
  ```
- Myswiperitem组件(==固定好的div和class==)
  ```
    <template>
        <div class="swiper-slide">
            <slot></slot>
        </div>
    </template>
  ```
- Myswiper(组件核心)
  ```
    tem: 
    // swiper固定的class格式
    <div class="swiper">
        <div class="swiper-wrapper">
            <!-- 插槽: 提高组件的复用性,父App使用组件时直接往里塞数据即可 -->
            <slot></slot>
        </div>
        <!-- 分页器 -->
        <div class="swiper-pagination"></div>
    </div>

    js:
    props: { // 接受父传子的信息,并规定样式
        loop: {
            type: Boolean,
            default: true
        },
        // 带-的属性要么加引号要么驼峰
        slidesPerView: { // 显示几页内容
            type: Number,
            default: 1
        },
        spaceBetween: { // 页间距px
            type: Number,
            default: 0
        }
    },
    mounted() {
        // 在updated中会因为多次初始化出BUG
        var mySwiper = new Swiper('.swiper', {
            // 接受props的值(来自父的自定义值)
            loop: this.loop,
            observer: true
            slidesPerView: this.slidesPerView,
            spaceBetween: this.spaceBetween,

            pagination: { // 如果需要分页器
                el: '.swiper-pagination',
            },
            on: {
                slideChange: ()=>{
                    this.$emit("kerwinSildeChange",mySwiper.activeIndex)
                }
            }
        })
    }

    css: 给分页器设置点css样式,起码有大小
    <style>
        .swiper {
            width: 600px;
            height: 300px;
        }
    </style>
  ``` 
  - ==代码解析:==
  - 问题1: 我们之前遇到的数据还未生成就new Swiper的问题依旧存在,那么我们如何解决?
    - ==首先解决的核心这次不再组件内部了,我们也没有使用nextTick,由此我们有了个新的解决方法,**就是在组件添加v-if语句,检测datalist的长度,如果为空,直接不创建组件,不为空再创建组件,由于new Swiper操作在组件里,所以这一定保证了先有数据后有swiper样式**,同时我们把new swiper放入mounted,因为在updated中,一旦数据更新就会重新执行一遍new Swiper,而多次初始化swiper会造成样式BUG==
  - 问题2: 在@子传父的on方法里面,我们把源代码"on + func"组合改为了"on + 箭头函数组合",并把里面的代码也改了点,==**这里涉及2个this的问题**==
    - 1.第一个是this.\$emit(): 使用\$emit方法时,this指向要求是和mounted同级的,也就是指向这个组件的,但是原方法是function写法,这样this指向的是mySwiper,如此我们把其改为箭头函数即可解决,对于箭头函数的this指向如果不懂可以看看ES6的箭头函数内容(js)
    - 2.问题又来了,第二个this问题,在没改变的function格式下,源代码为this.activeIndex,说明这个activeIndex是属于mySwiper的,但是改为箭头函数后,this不再指向mySwiper,所以写成mySwiper.activeIndex
  - ==总结==: 组件的封装通过父传子(:)指导swiper组件格式,子传父(@)返回分页器的一些数据,比如现在分页器到第几页了,实现了组件的自定义自由性,==而插槽则提高了组件的可复用性,我们接着把猫眼的数据插入插槽来测试数据==
- 猫眼案例:(App)
    ```
    tem:
        <Myswiper v-if="datalist.length" :slides-per-view="3" :space-between="50" :loop="false" @kerwinSildeChange="handleChange">
        <Myswiperitem v-for="data in datalist" :key="data.id"> 
            <!-- {{data.nm}} -->
                <!-- 图片本身大小不同,显示出来大小也会有所不同 -->
            <img :src="data.img" :alt="data.nm" style="width: 100%;">
        </Myswiperitem>
    </Myswiper>

    js:
    mounted() {
        // public/lib的猫眼数据
        // 自己电脑上请求数据,没有跨域,可以不写域名
        axios.get('public/lib/054test.json').then(res=>{
            console.log(res.data.data.hot)
            this.datalist = res.data.data.hot
        })
    }
    ```
  - 总结: 请求猫眼的数据,使用v-for把数据插入插槽,配置好swiper样式,主要显示的图片
## 指令(组合式和选项式相同)
### 指令写法与钩子
- 指令: 自定义的v-XXX,可以获取所附标签的dom节点,并且能获取对节点输入的数据
- 指令需要挂在,分为全局和局部,一下是指令的创建与挂载代码
  ```
    tem:
    // 指令创建
    <div v-kerwin>12341124</div>

    js:
    // 1.局部定义指令,只能在本文件使用
    directives: {
        kerwin: {
            ....
        }
    }
    ----------------------
    // 2.全局挂载指令
    // main.js(vite项目的vue入口):
    var app = createApp(App)
    app.directive("kerwin", {
        ......
    })
    app.mount('#app')
  ```
- ==指令的应用,有两个参数el和binding==
  ```
    tem:
    <div v-kerwin="'red'">asdfdaas</div>
    <div v-kerwin="color">asdfdaas</div>

    js:
    directives: {
        kerwin: {
            // 1.在mounted和updated阶段常用
            mounted(el,binding) { 
                // el: 会获取使用这个自定义指令标签的dom节点
                // binding,内部有许多属性,最有用的是value,会存储每次使用kerwin指令时传入的值,状态同理
                console.log("当前节点插入父节点时调用", el,binding)
                // 因为不同标签的dom节点不同,所以多个带有v-kerwin的标签传入的值虽然不同,但也互不影响,人家针对dom追踪并赋值binding.value
                el.style.background = binding.value
            },
            updated(el,binding){
                el.style.background = binding.value
            }
        }

        -----------------------
        // 2.简写 函数形式,会在mounted和updated阶段自动调用
        kerwin(el,binding){
            el.style.background = binding.value
        }
    }
  ```
  > ==当标签被创建后el会获取其dom节点,binding.value会存储v-XXX输入的值,无论是直接输入的还是状态,都会获取到值==
  > 代码中的v-kerwin="XXX"的作用就是输入XXX是你的背景颜色变为XXX色
### 指令的应用
- ==指令的应用又是解决datalist没数据和new Swiper之间的方案== 
- 代码:
  ```
    <template>
        <!-- class名字和结构需要留着,这是响应css和js的html结构 -->
        <div class="swiper">
            <div class="swiper-wrapper">
                <!-- v-swipe只能传一个参数,包装进对象 -->
                <!-- 把v-swipe封装好了后,挂在全局,这样任何人可以直接使用你的自定义组件,只需要传递对应的参数就可以完美使用了 -->
                <!-- 具有复用性最好的还是组件,也就是官方的那个swiper Vue,看文档学习学习人家的组件如何用 -->
                <div class="swiper-slide" v-for="(data, index) in datalist" :key="data" v-swipe="{
                    index: index,
                    length: datalist.length
                }">
                    {{ data }}
                </div>
            </div>
            <div class="swiper-pagination"></div>
        </div>
    </template>

    <script>
        import Swiper from 'swiper/bundle';
        import 'swiper/css/bundle';

        export default {
            data() {
                return {
                    datalist: []
                }
            },
            directives: {
                swipe: {
                    mounted(el, binding) { // 它会等待所依附的节点dom创建完毕时才会执行,所以此时datalist起码不为空了
                        console.log(el, binding.value);
                        // 但是还有个问题,每个带有v-swipe的标签创建都会调用一次mounted,会多次new Swiper
                        // 在最后一个节点 new Swiper , 防止多次初始化 new Swiper
                        let { index, length } = binding.value
                        if (index === length - 1) {
                            console.log("最后一个节点")
                            var mySwiper = new Swiper('.swiper', {
                                loop: true, // 循环模式选项
                                pagination: { // 如果需要分页器
                                    el: '.swiper-pagination',
                                },
                                // 和循环在一起出BUG
                                on: {
                                    slideChange: function () {
                                        console.log('改变了,activeIndex为', this.activeIndex);
                                    }
                                }
                            })

                        }
                    }
                }
            },
            //dom创建好再给配swiper样式
            mounted() {
                // 模拟ajax 1.5s
                setTimeout(() => {
                    this.datalist = ["111", "222", "333"]
                }, 1500)
            },
        }
    </script>


    <style>
        .swiper {
            width: 600px;
            height: 300px;
        }
    </style>
  ```
  - ==代码重点解析==
  - ==把组件v-swipe挂在创建分页的li上面,li内部就是data数据,创建new Swiper的代码写在指令的里面(即js的directives里面),**只有当datalist有数据时,li才会被创建,这时指令才会生效,li没创建,它里面挂载的v-swipe也就没响应,保证了先有数据后new Swiper**==
  - ==衍生问题==: 每创建出一个li,就会调用一次v-swipe,就会new Swiper一次,多次new Swiper会让样式出现BUG
    - ==解决方案==: 就是让v-swipe识别这是最后一个li,这时new Swiper正好,这时传入数组长度和数组本次遍历的序列index,指令只接受对象,用对象封装传入,从binding.value中结构出来,进行简单计算即可(数组长度-1 = index时为数组的最后一项,也是li的最后一项)
### 过渡效果+案例
- ==vue + css3实现动画效果==,有Transition和TransitionGroup两个,本节先讲Transition,这时个组件,内部写的元素会添加css3的动画效果,需要style的配置
- - ==**进入或离开可以由以下的条件之一触发**==
    1.由 v-if 所触发的切换
    2.由 v-show 所触发的切换
    3.由特殊元素 <component> 切换的动态组件
    4.改变特殊的 key 属性 
- ==本节课案例代码只涉及1和2的过渡==
- 代码:(==方法1 transition==)
  ```
    <template>
        <div>
            <button @click="isShow = !isShow">click</button>
            <Transition>
                <!-- 内置组件transition + 插槽 -->
                <!-- 作用是给内部标签在合适时机添加class和删除class -->
                <div v-show="isShow">123456</div>
            </Transition>
        </div>
    </template>

    <style>
        .v-enter-active,
        .v-leave-active {
            /* 还是css3的语法,这里写过渡样式 */
            transition: all 5s ease;
        }

        .v-enter-from,
        .v-leave-to {
            /* 这里写过渡目标 */
            opacity: 0;
            transform: translateX(100px)
        }

        html,
        body {
            overflow-x: hidden;
        }
    </style>
  ```
  - ==代码解释==: 点击按钮使得Transition组件内部的div消失出现子代css3动画效果,==其中style是固定的,如上代码注释,一部分负责写过渡样式,一部分写过渡目标==
- 代码:(animation)
  ```
    <template>
        <div>
            <button @click="isShow = !isShow">click</button>
            <!-- 命名,防止组件混用css样式 -->
            <!-- 添加appear可以实现第一次的自启动 -->
            <Transition name="kerwin" appear mode="out-in">
                <!-- 内置组件transition + 插槽 -->
                <!-- 作用是给内部标签在合适时机添加class和删除class -->
                <!-- Transition组件只允许内部有一个组件或孩子 -->
                <!-- 但是可以这么写,同一时间段只有一个孩子,v-if elif ... else -->
                <!-- mode = out-in/in-out 意为 先出后进/先进后出 -->
                <div v-if="isShow">123456</div>
                <div v-else>00000</div>
            </Transition>
        </div>
    </template>

    <style>
        /* animation写法 */
        /* 改名了所以把 v 全部改为 kerwin */

        /* 进入 */
        .kerwin-enter-active {
            animation: kerwinanimate 1s;
        }

        /* 离开 */
        .kerwin-leave-active {
            animation: kerwinanimate 1s reverse;
        }

        @keyframes kerwinanimate {

            /* 0%->100%是进场动画 */
            0% {
                transform: translateX(100px);
                opacity: 0;
            }

            100% {
                transform: translateX(0px);
                opacity: 1;
            }
        }

        html,
        body {
            overflow-x: hidden;
        }
    </style>
  ```
  - ==代码介绍==
    - 1.Transition的==新属性name="kerwin" |appear |mode="out-in"==
      - name:==命名的,多个Transition的不同样式不会混淆,**具体体现在style的class命名上**==,看代码,原有的2对class样式变为2个,少了一半,==同时v-XX-XX的'v'是改名处,改为kerwin-XX-XX,**这样对应的class样式服务对应的Transition组件的插槽**==
      - appear: 初始化时,即页面第一次加载时,执行一次动画
      - mode: out-in是先出后进,in-out是先进后出,应对的是组件内多个孩子的进出场问题,不写的话,会同进同处的一小段时间内拥挤堆在一起
    - 2.==Transition是不允许同一时间存在多个孩子的,**但是由v-if/elif/else组成的多个孩子就可以和谐地在Transition组件中,因为它们在同一时间只能有一个孩子显示,这是允许的,同时上面的mode属性就是解决这个v-if/else多个孩子进出场拥挤问题的**==
    - 3.annimation正常写语法没变,==只需注意对应的class是进场还是出场即可==
- 代码3(==最简单的一个,引入animate.css组件,看官网教程即可==)
  ```
    <template>
        <div>
            <button @click="isShow = !isShow">click</button>
            <!-- 固定的属性 进入enter-active-class/离开leave-active-class + 网站复制过来的的样式(注意animate__animated是必需品) -->
            <Transition enter-active-class="animate__animated animate__bounceIn" leave-active-class="animate__animated animate__bounceOut"> 
                <div v-if="isShow">123456</div>
            </Transition>
        </div>
    </template>

    <script>
        // 导入animate.css模块
        import 'animate.css';
    </script>
  ```
  > 当年学css3的时候就见过这个animate.css,只需要把它npm下载到本地,==分为进enter-active-class和出leave-active-class两个class==,看着官网配置对应的class名即可获取对应的样式即可,**官网有详细教程**
### 列表过渡
- ==TransitionGroup组件内同时容纳多个孩子,最典型的就是v-for==
- 代码:(对06增删列表的案例加动画效果)
  ```
    <template>
    <!-- 增加,删减表单案例 -->
    <div>
        <input type="text" v-model="mytext">
        <button @click="handleAdd">add</button>

        <!-- ... group可容纳多个孩子 -->
        <!-- 还可以实例化成ul标签 -->
        <TransitionGroup tag="ul" name="kerwin">
            <!-- 不加key就没有效果,为了给唯一身份,方便样式操作 -->
            <!-- -->
            <!-- 这样子则不允许我们写相同的item添加进列表 -->
            <!-- 当然我们也可以"item + 时间戳"的组合去杜绝重复id -->
            <li v-for="(item, index) in datalist" :key="item">
                {{ item }} <button @click="handleDel(index)">del</button>
            </li>
        </TransitionGroup>


        <div v-show="datalist.length === 0">暂无数据</div>
    </div>
    </template>

    <script>
    export default {
        data() {
            return {
                mytext: "",
                datalist: ["111", "222", "333"],
            }
        },
        methods: {
            handleAdd() {
                // console.log(this.mytext)
                if (this.mytext === "") { // 不写东西就不添加
                    return
                } else {
                    this.datalist.push(this.mytext)
                    this.mytext = "" // add后清空输入框,双向绑定的优势体现出来了
                }
            },

            handleDel(index) {
                // 删除数组的方法 splice Api
                this.datalist.splice(index, 1)
            }
        }
    }


    </script>

    <style>
    /* animation写法 */
    /* 改名了所以把 v 全部改为 kerwin */

    /* 进入 */
    .kerwin-enter-active {
        animation: kerwinanimate 1s;
    }

    /* 离开 */
    .kerwin-leave-active {
        animation: kerwinanimate 1s reverse;
    }

    @keyframes kerwinanimate {

        /* 0%->100%是进场动画 */
        0% {
            transform: translateX(100px);
            opacity: 0;
        }

        100% {
            transform: translateX(0px);
            opacity: 1;
        }
    }

    html,
    body {
        overflow-x: hidden;
    }

    /* 更加平滑,list不是固定的,改名了就为kerwin-move 和 kerwin-leave-active了 */
    /* 时间长短比动画animation设置的长一点会好看,即删除移走后,选项缓慢填补 */
    .kerwin-move{
        transition: all 1.5s ease;
    }
    .kerwin-leave-active {
    position: absolute;
    }
    </style>
  ```
  - ==代码重点解析==
    - 1.==TransitionGroup可以实例化成ul标签,tag属性后面跟着标签名,可以减少一层嵌套==
    - 2.==**不加key就没有效果**,给唯一身份进行样式操作==
    - 3.==key不能是index索引,涉及diff问题,也不能重复,可以用key+时间戳拼接去设置不重复的key值==
    - 4.为何不能是index,解释如下
        ==**看不懂去看kerwin的课064列表过渡,12min左右**==
      - 如果key值为index, 重温习diff算法,按照索引index对比,相同的复用,不同的重写,没有的删除,最后如果你删除了index=2的项,会有index=1复用,index=2没了,原index=3顶上,和未删减的index=2对比,发现变了,222转为333,然后最后index=3顶上了,删减版对比原数据没有index=3了,遵循没有的删除,index=3会被删除,删除的永远是最后一项,而非你点击的第二项,最后结果是index=1不变,index=2的数值由222变333,index=3被删除(而你del的是index=2哦,发现在diff下,index为key真乱啊,所以确保key的唯一性)
    - 5.==更加平滑的动画改进,也是固定写法,也可以被改名,即v-move和v-leave-active的'v',时间长短比动画animation设置的长一点会好看==
### 可复用过渡
- 和我们自己造基于swiper的myswiper组件一样,这次我们基于Transition组件造我们自己的KerwinTransition组件
- 代码(App,父,==导入组件过程略==)
  - ==把动画再次二次封装成动画效果组件 + 插槽==
  - ==组件内核是Transition,所以不要放多个孩子,特指同一时间点==
  ```
    <template>
        <div>
            <button @click="isShow = !isShow">click</button> 
            <!-- 再添加些可以父传子的属性指导 -->
            <!-- ltor = left to right 从左到右的动画 -->
            <!-- rtol = right to left 从右到左的动画 -->
            <KerwinTransition myname="rtol">
                <div v-if="isShow">1234567</div>
            </KerwinTransition>
        </div>
    </template>
  ```

  - 组件KerwinTransition
    - ==给父提供了一个父传子的自定义选择,myname接受父组件信息动态绑定到插槽内的Transition组件name上,从而确定动画位移效果,不同的name对应不同的class名字,在class内部定义不同的css动画==
  ```
    <template>
        <div>
            <Transition :name="myname" appear mode="out-in">
                <slot></slot>
            </Transition>
        </div>
    </template>

    <script>
        export default{
            props:["myname"]
        }
    </script>

    <style>
        /* 进入 */
        /* ltor = left to right 从左到右的动画 */
        /* 同理 rtol = right to left 从右到左的动画 */
        .ltor-enter-active {
            animation: kerwinanimate 1s;
        }

        /* 离开 */
        .ltor-leave-active {
            animation: kerwinanimate 1s reverse;
        }

        @keyframes kerwinanimate {

            /* 0%->100%是进场动画 */
            0% {
                transform: translateX(-100px);
                opacity: 0;
            }

            100% {
                transform: translateX(0px);
                opacity: 1;
            }
        }

        // ----------------------------------

        .rtol-enter-active {
            animation: kerwinanimate2 1s;
        }

        /* 离开 */
        .rtol-leave-active {
            animation: kerwinanimate2 1s reverse;
        }

        @keyframes kerwinanimate2 {

            /* 0%->100%是进场动画 */
            0% {
                transform: translateX(100px);
                opacity: 0;
            }

            100% {
                transform: translateX(0px);
                opacity: 1;
            }
        }

        html,
        body {
            overflow-x: hidden;
        }
    </style>
  ```


## VCA组合式写法
### 初识VCA
- ==组合式写法代码如下:==
  ```
    <template>
        <div>
            componsition Api  
            <!-- 返回出的是一个obj的proxy对象,使用里面的属性需要".XXX" -->
            <div>obj.name : {{obj.name}}</div>
            <div>obj.age : {{obj.age}}</div>
            <button @click=handleClick>click</button>
        </div>
    </template>

    <script>
        // reactive是vue内置模块,需要引入,自动的
        import { reactive } from 'vue';

        // 组合式写法具有更好的可读性,都集中在一起
        export default{
            // 代码都写setup函数内部
            setup(){
                // 状态定义,需要reactive(),他会把参数对象封装为proxy对象,内部只能放复杂类型(对象,数组),而简单数据类型(数字,字符串,布尔)都不行
                // const ES6写法,const是不可变写法,obj不可被赋值,由于obj拿到的只是proxy对象的一个指针,所以内部的属性随便改(不影响指针指向),不违反const要求
                const obj = reactive({
                    name : "kerwin",
                    age : "100"
                })
                // 函数方法
                const handleClick = ()=>{
                    console.log("123")
                    // 方法使用状态,不再是this.XX而是obj.XX,常规思路
                    obj.name="xiaoming"
                    obj.age="200"
                }

                // 需要返回,外面(tempalte)才能使用
                return {
                    obj, // obj : obj 的简写
                    handleClick
                }
            }
        }
    </script>

  ```
  - ==**总结:(规整注释)**== 
  - 1.==代码都写setup函数内部==
  - 2.==所有信息需要返回return{..}==,外面(tempalte)才能使用
  - 3.==状态定义改变了,const obj = reactive({..})==,**reactive()是vue内置模块,需要引入**,
    > 解释reactive的原理:==他会把参数对象封装为proxy对象==,**内部只能放复杂类型(对象,数组),而简单数据类型(数字,字符串,布尔)都不行**
  - 4.==内函数方法使用状态写法改变,**不再是this.XX而是obj.XX,因为你把状态封装为proxy对象赋值给obj了,所以这是很正常的思路,同理的template想要使用状态也要这么写**,不再是选项式直接写的写法了==
  - 5.==在组合式中常用const(ES6写法)==,替换掉在选项式的var(ES5)
    > const ES6写法: ==const是不可变写法,obj不可被赋值==,**由于obj拿到的只是proxy对象的一个指针,所以内部的属性随便改**==(不影响指针指向),不违反const要求==
  

### reactive()案例
- 代码:
  ```
    <template>
        <div>
            <!-- 记得所有的内部状态(mytext,datalist)需要state.XXX -->
            <input type="text" v-model="state.mytext">{{ state.mytext }}
            <button @click="handleAdd">add</button>
            <ul>
                <li v-for="(data, index) in state.datalist" :key="data">
                    {{ data }}
                    <button @click="handleDel(index)">Del</button>
                </li>
            </ul>
        </div>
    </template>
    <!-- 写老案例06增删li列表的案例 -->
    <script>
        import { reactive } from 'vue';
        export default {
            setup() {
                // reactive()作为vue的内置方法,可以写多个
                const state = reactive({
                    datalist: ["111", "222", "333"],
                    mytext: ""
                })

                // 都记得要state.XXX
                const handleAdd = () => {
                    state.datalist.push(state.mytext)
                    state.mytext = ""
                }

                const handleDel = (index) => {
                    state.datalist.splice(index, 1)
                }

                // 记得方法状态都要return出去
                return {
                    state,
                    handleAdd,
                    handleDel
                }

                // 总结: template和js内部使用状态都需要"state.XXX"
            }
        }
    </script>
  ```
    > 总结: ==写老案例06增删li列表的案例,思路十分的简单,注意几点,习惯组合式的写法,记得返回值,记得reactive定义状态的方式,**记得想要调用状态时需要state.XX**==
### ref()的应用
- reactive只能封装复杂数据类型(对象,数组),对简单数据类型的单独封装不支持,由此引出ref
- ref: 创建一个包装对象(proxy),同样需要引入,==复杂数据和简单数据都可以包装,不过他会自动封装一层value的对象==
   `const myname = ref("kerwin") // 会包装为{ value : "kerwin"}`
- 代码:(==把reactive的案例改为ref式==)
  ```
    <template>
        <div>
            <!-- 在tem中,vue会自动帮你补全,所以不用写myname.value,直接写即可,和选项式写法一样 -->
            myname : {{myname}}
            <button @click="handleClick">click</button>
        </div>
    </template>

    <script>
        // ref在父子关系就见过
        // VCA中在之前的基础上,又增加新能力,创建一个包装对象(proxy),复杂数据和简单数据都可以包装
        // 它会自动封装一层value的对象,如下 

        import { ref } from 'vue'; // ref需要导入,自动化

        export default{
            setup(){
                // 字符串,数字,布尔....都自动value二次包装
                const myname = ref("kerwin") // 会包装为{ value : "kerwin"},所以访问需要 .value访问

                const handleClick = ()=>{
                    // 打印发现是一个大对象RefImpl
                    console.log(myname)
                    // 在js中,必须.value才能生效
                    myname.value = "xiaoming"
                }
                return {
                    myname,
                    handleClick
                }

            }
        }
    </script>
  ```
    - ==总结:==
    - 1.由于vue自动封装的value,==在js内部使用状态需要加".value",**但是tempalte内部使用状态,vue会自动帮你加上,所以和选项式一样了,直接写即可**==
      > 注意: 在js内部直接打印状态,是一个对象RefImpl,这就是ref封装好返回给你的对象,查看属性value的值就是我们想要的状态值
    - 2.ref把reactive的**对象封装转化为2个ref单个封装(记得同步返回return的内容)**,==对mytext封装空字符串(简单数据类型),对datalist封装数组(复杂数据类型)==
### ref的老用法
- ==ref早在我们学习父与子的时候作为父强权ref-$ref中用过,**这个能力并没有丢失,只是组合式和选项式的使用方式变化了**==
- 为何组合式和选项式使用ref方法不同?
  - ==因为在组合式中的this已经没有指向了,你无法通过this获取dom节点==
- 代码:(新用法)
  ```
    <template>
        <div>
            <!-- 使用下ref传统用法 -->
            myname : {{ myname }}
            <!-- ref="myinput"相当于把组合式创建的myinput状态放进去了,之后myinput会自动获取这个标签的dom节点 -->
            <input type="text" ref="myinput">
            <button @click="handleClick">click</button>
        </div>
    </template>

    <script>
        import { ref } from 'vue';
        export default {
            setup() {

                const myname = ref("kerwin")
                // 这样写,开始不绑定东西,用于未来获取节点
                const myinput = ref(null)

                const handleClick = () => {
                    myname.value = "xiaoming"
                    // setup中this已经失效所以原来选项式的用法不可用
                    // console.log("this:",this)

                    // ref(null)绑定好后再次打印查看
                    // console.log(myinput)
                    // 遵循.value规则,获得dom节点
                    // console.log(myinput.value)
                    // 第一个value是ref本身东西数据获取,第二个value是获取input节点的value值
                    console.log(myinput.value.value)
                }

                return {
                    myname,
                    myinput,
                    handleClick
                }

            }
        }
    </script>
  ```
  - 方法:
  - 定义好一个**ref + null**的状态myinput : `const myinput = ref(null)`,==开始不绑定东西,用于未来获取节点==
  - 在标签上挂ref: `<input type="text" ref="myinput">`,==ref="myinput"相当于把组合式创建的myinput状态放进去了,这个myinput是一个状态不是字符串,之后myinput会自动把这个标签封装进去==
  - 打印ref获取的dom节点(不再使用this):`console.log(myinput.value)`, ==**遵循.value规则**,直接获得dom节点,然后随意操作即可==

### ref()与reactive()的区别
- ==封装能力==
  - reactive: 复杂数据类型
  - ref: 复杂简单数据类型都可以
- ==状态在js和template的使用方法==
  - reactive: template和js内部使用状态都需要"state.XX"
  - ref: template写法和选项式一样,直接写即可; 但是在js内部使用需要+.value

### toRef和toRefs
- ==toRef()==: 把state中的某一个状态单独转化为ref形式
- ==toRefs()==: 把所有state的转化为ref封装在一起
- ==**关于reactive响应式数据的问题**==
  - ==在reactive格式下的状态,**如果想要响应式地接应tempalte,return的数据必须是state**==,如上面的增删列表案例`return { state }`
  - ==如果想要贪图省事,比如不想要通过state.mytext去获取数据,如下
    `return { mytext : state.mytext }`,会发现响应式失效,**这是因为此时的mytext已经是固定写死的数据了**==,你往外返回的是死数据
  - 原因: ==单独的state,返回出去的是一个指向state内存的地址,当我们改变mytext的值,**它作为内存state的内部数据改变不影响state的地址,所以能响应式布局**==,**而`mytext:state.mytext`相当于你已经从内存中取了当时的mytext的值,这是值而非地址,所以是死数据**,==即使后来mytext变了,也无法响应式地传递新的mytext的值==
  - ==所以reactive传递返回数据时要认真思考,按照之前的模板传递准没错,**涉及地址传递和值传递搞不清楚,会造成无法响应式布局页面**==
- 由此引申出,既然reactive返回值无法动手脚,我直接把reactive转化为ref形式的数据不就可以了吗
  - ==toRef函数(需要导入)==
  - `mytext : toRef(state,"mytext")`,意为把state中的mytext状态单独转化为ref形式
  - ==toRefs函数(需要导入)==
  - `let obj = toRefs(state)`,把所有state的转化为ref封装在一起,使用它有个简便方法,就是使用展开运算符,直接拆分对象返回出去,如下
    `return { ...toRefs(state) }`
  - 结构赋值(...obj): 就是把对象的key/value对拆开,常用于数组的合并
  `var obj1 = {a:1,b:2}  var obj2 = {c:3}  ==> var obj3 = {...obj1,...obj2} = {a:1,b:2,c:3}`
  >
- ==另外,ref风格可以转为reactive风格,如下==
  ```
    const location = ref("dalian")
    const state = reactive({
        name : "kerwin",
        age : "100",
        // ref可以作为属性直接被封装进reactive
        location // 简写 location(名) : location(状态值)
    })

  ```
- 在template使用方面,入乡随俗
   ```
    <!-- 对于ref状态的使用,只要进入reactive也就入乡随俗了 -->
    <div>location(state): {{state.location}}</div>
   ```
- 在事件处理函数内部的使用(例如点击事件),十分包容
   ```
    const handleClick = ()=>{
        state.name = "xiaoming"
        // 那么对于事件函数,如何去改ref型数据的值呢? 测试
        // state.location = "beijing" // 遵循reactive
        location.value = "beijing" // 遵循ref
        // 结果是都行,随意使用
    }
   ```
### 组合式写法规范与升级(hooks)
- 组合式写法规范性如下(大的项目文件都是如此写法,使得代码更加规整,如果和图片左边一样的写法,那和选项式比没啥区别,照样乱)
  [![pABQDBt.jpg](https://s21.ax1x.com/2024/10/30/pABQDBt.jpg)](https://imgse.com/i/pABQDBt)
- ==复用逻辑-自定义hooks==: **把代码逻辑封装进模块module,这个文件内部有许多的逻辑代码(即模块module)组合而成,==而逻辑代码module模块本身在文件内部也具有复用性,并且别人可以引用你的模块使用==**
- **本节主要是写逻辑代码module**,而不是把每个module又做成组件,那样组件太多了冗余,==我们的组件最好是集大成者的大合集==
- ==**模块命名潜规则,加'use'前缀**==
>
- ==模糊搜索案例组合式写法重构==
- 初始写法,帮助理解,即不写模块,写func
  ```
    <template>
        <input type="text" v-model="mytext">
        <ul>
            <li v-for="data in computedList" :key="data">
                {{ data }}
            </li>
        </ul>
    </template>

    <script>

        import { reactive,computed,ref } from 'vue';

        // 先在一个文件里写帮助理解,然后再写到模块里
        // 不成文的规定,自定义的hooks一般加use前缀
        function useSearch(state){
            const mytext = ref("")
            const computedList = computed(()=>{
                return state.datalist.filter(item=>item.includes(mytext.value))
            })

            return {
                mytext,
                computedList
            }
        }


        export default {
            setup() {
                const state = reactive({
                    datalist: []
                })

                // 模拟ajax请求数据,这是用户写的,无法封装进逻辑
                setTimeout(()=>{
                    state.datalist = ["aaa", "aab", "abc", "bbc", "bac", "cab", "ccc", "caa"]
                },2000)

                // 搜索逻辑全部交给函数处理了
                // Search方法也是响应式的,上面的setTimeout是异步,所以直接会执行Search函数,一开始没有数据,当时数据请求到之后,会实时更新!
                // const {mytext,computedList} = UseSearch(state)

                return {
                    // mytext,
                    // computedList

                    // 甚至不用你解构赋值,我把你返回的对象直接展开运算了
                    ...useSearch(state)
                }
            }
        }

    </script>
  ```
  - ==**我们的核心功能函数(也是今后要进入组件的部分),就是useSearch函数,这个逻辑代码帮我们解决了模糊搜索的所有问题**,用户要做的就是根据自己的情况请求不同的数据datalist,放入这个函数中,剩下的什么都不用管==
  - **写模糊搜索函数记得return必要的值**
  - ==vue支持异步情况下的模块响应==,这使得我们不必考虑异步的时,具体在注释中: setTimeout是异步,所以直接会执行Search函数,虽然一开始没有数据,但是当数据请求到之后,会实时更新!
- 写法2,封装一下
- useSearch.js (==按照ES6的模块化语法即可==)
    ```
        // 引入vue方法
        import { computed,ref } from 'vue';

        // 处理
        function UseSearch(state){
            const mytext = ref("")
            const computedList = computed(()=>{
                return state.datalist.filter(item=>item.includes(mytext.value))
            })

            return {
                mytext,
                computedList
            }
        }

        // 导出
        export default UseSearch
    ```
- 主文件App(==引入模块,直接使用即可==)
    ```
    js:
    // 导入模块
    import useSearch from './search';

    export default {
        setup() {
            const state = reactive({
                datalist: []
            })

            // 模拟ajax请求数据,这是用户写的,无法封装进逻辑
            // 如果别的用户想用你这个模糊搜索逻辑,只需要引入你的模块,请求数据即可,剩下的已经写好了
            setTimeout(() => {
                state.datalist = ["aaa", "aab", "abc", "bbc", "bac", "cab", "ccc", "caa"]
            }, 2000)

            return {
                ...useSearch(state)
            }
        }
    }
    ```
- 主文件: ==我们要做的就和图片右边的写法一样了,**引入模块,使用模块传递数据,返回模块**三步走==
- ==模块内部需要引入vue方法,返回计算过的值,**最后导出函数(ES6)**==
>==**注意:你会发现我们在模块内部定义的const mytext = ref(""),这说明了模块和主文件是一体的,mytext的应用是在App.vue里面,而定义在模块js文件里面,所以这些状态的定义都放在模块里面即可,主文件可以更加简洁,同时记住,模块可以响应式地,不受异步影响地接受数据改变页面**== 
>
- ==**针对放入函数的参数为何是state而非state.datalist的讨论**,还是涉及到地址和值对于响应式布局的影响(第一次讨论此问题在toRef和toRefs的章节)==
  - 这时因为,==初始state.datalist = []和后来异步请求数据后,赋值的数组,不是一个地址了(**复杂数据给状态的是一个地址**)==,而在数据来之前,==已经把空数组地址写入search函数了,这也相当于写死了==,把空数组的地址永远作为参数放入模块,而无法接受datalist改变后的值,从而无法响应式布局
  - ==**state作为最外层**,内部数据datalist数据改变,其地址也不受影响,**指向的内存内部数据变化了而已,但是开门的钥匙没变,保证模块能顺着钥匙找到state,进而找到变化的datalist**,所以能响应式==
- ==也可以转化为ref写法,这样模块传值就无需多虑了==
- App(主文件)
  ```
    <!-- 制作模块 -->
    <template>
        <input type="text" v-model="mytext">
        <ul>
            <li v-for="data in computedList" :key="data">
                {{ data }}
            </li>
        </ul>
    </template>

    <script>

        import { ref } from 'vue';
        // 导入模块
        import useSearch from './search2';

        export default {
            setup() {
                // ref写法
                const datalist = ref([])

                // 模拟ajax请求数据,这是用户写的,无法封装进逻辑
                // 如果别的用户想用你这个模糊搜索逻辑,只需要引入你的模块,请求数据即可,剩下的已经写好了
                setTimeout(() => {
                    datalist.value = ["aaa", "aab", "abc", "bbc", "bac", "cab", "ccc", "caa"]
                }, 2000)

                return {
                    ...useSearch(datalist)
                }
            }
        }

    </script>
  ```
- 模块Sreach2.js :
  ```
    // 引入vue方法
    import { computed,ref } from 'vue';

    // 处理
    function UseSearch(datalist){
        const mytext = ref("")
        const computedList = computed(()=>{
            return datalist.value.filter(item=>item.includes(mytext.value))
        })

        return {
            mytext,
            computedList
        }
    }

    // 导出
    export default UseSearch

  ```
### computed函数
- **==组合式万物皆函数,通过引入各式各样的函数,复现选项式的种种功能==**
- 老案例,计算属性把字符串转化为首位字母大写
  ```
    <template>
        <div>
            <div>obj.myname: {{obj.myname}}</div>
            <div>compuName: {{compuName}}</div>
        </div>
    </template>

    <script>
        // 万物皆函数了,引进computed函数
        import { reactive,computed } from 'vue';
        // 由于状态不在data中定义,所以computed的this访问不到状态了,也要重写方法
        export default{
            setup(){
                const obj = reactive({
                    myname:"kerwin"
                })

                // 计算属性(自动化) 首字母大写
                const compuName = computed(()=>{
                    return obj.myname.substring(0,1).toUpperCase() + obj.myname.substring(1)   
                })
                // 写法2
                // const compuName = computed(()=> obj.myname.substring(0,1).toUpperCase() + obj.myname.substring(1))

                return {
                    obj,
                    compuName
                }
            }
        }
    </script>
  ```
  > 1.计算函数是自动化的,和计算属性一样
  > 2.计算函数有两种写法,看代码即可
  > 3.需要有变量承接计算函数的返回值,再return出去
  > 4.原计算属性需要借助this去实现数据获取于返回,但是我们从学习方法时就知道,this在组合式中不好使了,所以涉及this操作的全部重构
- 模糊搜索案例+计算函数重构
  ```
    <!-- 模糊搜索案例组合式写法重构 -->
    <template>
        <input type="text" v-model="mytext">
        <ul>
            <li v-for="data in computedList" :key="data">
                {{ data }}
            </li>
        </ul>
    </template>

    <script>

    import { reactive,toRefs,computed } from 'vue';

    export default {
        setup() {
            const state = reactive({
                mytext: "",
                datalist: ["aaa", "aab", "abc", "bbc", "bac", "cab", "ccc", "caa"]
            })

            const computedList = computed(()=>{
                // 记住filter是返回新数组,对原数组没影响,所以不会出现"越改越少"的现象(这个是模糊搜索案例的难点)
                // includes空字符代表全部符合
                return state.datalist.filter(item=>item.includes(state.mytext))
            })

            return {
                // 都转化为ref型状态,在tem中可以直接写原名
                ...toRefs(state),
                computedList
            }
        }
    }

    </script>
  ```
  > 1.==和模块化规范语法几乎没区别,只是把原模块search.js内的功能函数赋值进计算函数==,**同时让页面按照筛选好的计算函数返回值去构造页面,即`v-for="data in computedList"`**
  > 2.这里数组的filter方法返回值是筛选后的新数组,对原数组没影响,所以不会出现"越改越少"的现象(这个是模糊搜索案例的难点)
### watch函数
- watch: ==解决计算属性无法使用异步的问题,需引入==
- 改造下模糊搜索的案例,改为watch监听input,发现输入框变化后,进行ajax请求数据,然后显示
- ==ref + watch(会更简单,watch的3中3中写法)==
  ```
    <template>
        <div>
            <input type="text" v-model="state.mytext">

            <select v-model="state.select">
                <option value="111">111</option>
                <option value="222">222</option>
                <option value="333">333</option>
            </select>
        </div>
    </template>

    js:
    // ---监听watch配合ref会更加方便
    const mytext = ref("")
    const select = ref("222") // 初始select选择222

    // 写法1: 自带2个参数,新值和旧值
    watch(mytext,(newValue,oldValue)=>{  
        console.log("ajax请求",newValue,oldValue)
    })

    // 写法2: 监视每次触发后,返回mytext.value
    watch(()=>mytext.value,(newValue,oldValue)=>{ 
        console.log("ajax请求",newValue,oldValue)
    })

    // 写法3: 同时监听多个值,任意一个改变就触发,会封装成对象打印出来
    watch([mytext,select],(newValue,oldValue)=>{ 
        console.log("ajax请求",newValue,oldValue)
    })

    // 补充: 立即触发immediate ; 深度监听deep,监听对象,无论对象多深的层级都会监听到,不建议使用,影响性能
    watch([mytext,select],(newValue,oldValue)=>{ 
        console.log("ajax请求",newValue,oldValue)
    },{immediate:true})

  ```
    > watch监听可以分为监听1个,多个值,单独监听一个值有两个写法,监听属性还有immediate和deep等属性值
- reactive与watch函数匹配
  ```
    // 2.reactive配合监听写法
    const state = reactive({
        mytext : "",
        select : "333"
    })
    
    // 注意: 监听无效,这是一个写死的常量""
    // watch(state.mytext) 

    // 1.这种写法有个弊端,state任何一个数据改变动员会发起ajax,我们就指定只监听state的mytext
    // watch(state,()=>{
    //     console.log("ajax")
    // })

    // 2.箭头函数的监听写法
    watch(()=>state.mytext,(newValue,oldValue)=>{
        console.log("ajax",newValue,oldValue)
    })

  ```
  > ==监听reactive时注意,不要直接写内部的状态,形如`watch(state.mytext)`,这监听的是一个死对象==,**所以借助箭头函数可以对指定的状态进行监听**,从而不必对整个state监听了
- 关于watch函数箭头函数监听的知识
  - 这种箭头函数的形式在这里可以理解为一个 “取值函数” 或者说 “get 函数”。它的主要作用是当 watch 机制去检查是否有值发生变化时，会调用这个函数来获取当前时刻要监听的那个具体的值
  - 以 watch(() => state.mytext, () => { console.log("ajax") }) 为例，() => state.mytext 就是这个 “get 函数”。每次 watch 进行依赖收集或者检查值是否变化时，都会执行这个函数来拿到 state.mytext 的最新值，以便和之前的值进行对比，从而确定是否触发后续的回调函数(也就是监听到了变化)
  如果 state 是一个通过 reactive 函数创建的响应式对象，当 state 内部的属性（这里是 mytext）发生变化时，Vue 的响应式系统会重新执行相关的 “get 函数”来获取新的值，并与之前的值进行对比，若不同则触发 watch 对应的回调操作。

### VCA案例
- json-server: ==**是一个需要npm的第三方工具,可以结合json文件模拟地址,在前后端分离开发中,后端暂时没有,前端需要测试数据时,利用json文件模拟后端数据**,同时可以通过浏览器,ajax网络请求,在本机请求到这些json内的数据,并且可以正常地对json文件内的对象属性进行访问==
- ==大部分介绍用法在csdn收藏文章里(其他栏),基本用法==,在json文件夹下,使用`json-server --watch <file>`,file是你的json文件名,--watch是监听指令,文件内部由东西变化可以监听到

- ==**案例(初始,简单的模糊搜索+ajax模拟)**==
- ==ajax模拟,即通过启动json--server来模拟后端,前端发送axios请求数据,进而完成模糊搜索的功能==
    ```
    tem:
    <!-- 选项框 -->
    <div>
        <select name="" id="" v-model="select">
            <option value="kerwin">kerwin</option>
            <option value="tiechui">tiechui</option>
            <option value="gangdan">gangdan</option>
        </select>
    </div>
    <!-- 显示模糊搜索结果内容 -->
    <div>
        <ul>
            <li v-for="item in list" :key="item.id">
                {{item.content}}
            </li>
        </ul>
    </div>

    js:
    import { ref, watch } from 'vue'
    import axios from 'axios'
    export default {
        setup() {
            const select = ref("kerwin")
            const list = ref([])
            // 使用async+await
            watch(select, async(value) => {
                let {data} = await axios.get(`http://localhost:3000/users?name=${value}`)
                console.log(data)
                list.value = data
            }, { immediate: true })

            return {
                select,
                list
            }
        }
    }

    ```
    > 重点: ==看axios的get请求==,前面的域名啥的是json--server服务器启动时给你的基本地址,后面的`users?name=${value}`,users是找你的json文件(一般是这个文件最外层的对象名),再后面是按照get语法"?key=value",根据name去请求值,value就是select+optinons选出的值,axios内部是ES6写法`` + ${}
- 组合式写法的集大成者(再引入新功能,**先select出内容,再在input框内对select内容进行模糊搜搜**,==引入2个js逻辑模块==)
- App(==主文件,内部很简洁==)
    ```
    <div>
        <!-- 筛选 -->
        <select name="" id="" v-model="select">
            <option value="kerwin">kerwin</option>
            <option value="tiechui">tiechui</option>
            <option value="gangdan">gangdan</option>
        </select>
        <!-- 模糊搜索 -->
        <input type="text" v-model="mytext">
        <ul>
            <li v-for="item in computedList" :key="item.id">
                {{ item.content }}
            </li>
        </ul>
    </div>

    js:
    import useList from './select';
    import useSearch from './search';
    export default {
        setup() {
            // 十分简洁的组合式代码
            const { select, list } = useList()
            const { mytext, computedList } = useSearch(list)

            return {
                select,
                list,
                mytext,
                computedList
            }
        }
    }
    ```
    > 1.两个模块的作用,第一个useList(),内部会自动获取select选出的值,进行ajax请求数据,进行第一次筛选,返回出筛选的数组list
    > 2.第二个useSearch(list),内部需要数组数据,把一筛的list传进去,结合input + .include(...)进行二筛得到computedList
    > 3.==两个模块内部定义的select和mytext通过解构拿出来,然后return出去,是可以响应式地呼应App的tempalte的==
    > 4.==二筛后的数组computedList最终v-for打印出来==
- select.js(不写了,代码和上面的案例中的js区一摸一样)
- search.js(==之前的模块,但是由于参数的内部解构复杂了,是一个对象数组,所以内部稍微改了一点==)
    ```
        // 引入vue方法
        import { computed,ref } from 'vue';

        // 处理
        function useSearch(datalist){
            const mytext = ref("")
            const computedList = computed(()=>{
                // 修改一点 item.content.XXX
                return datalist.value.filter(item=>item.content.includes(mytext.value))
            })

            return {
                mytext,
                computedList
            }
        }

        // 导出
        export default useSearch
    ```


### watchEffect函数
- watchEffect 
  ```
    // watchEffect
    // 立即执行,不懒惰
    // 只接受一个参数,回调函数,自动检测内部代码,内部代码有依赖并被更改,就会执行一次监听
    // 不需要传递多个参数,只需要一个回调函数,会自动感知代码依赖
    // 不能获取之前的数据,只能获取当前值
    // 对于一些异步操作特别适合
  ```

- watch:
  ```
    // watch
    // 懒惰,需要immediate才会立即执行
    // 接收多个参数,但是不会自动检测内部代码依赖,参数是谁监听谁
    // 可以获取之前的数据和现在的数据

  ```
- 把watch的代码改为watchEffect
  ```
    // watch(select, async (value) => {
    //     let { data } = await axios.get(`http://localhost:3000/users?name=${value}`)
    //     console.log(data)
    //     list.value = data
    // }, { immediate: true })

    watchEffect(async () => {
        // 直接监听select.value
        let { data } = await axios.get(`http://localhost:3000/users?name=${select.value}`)
        console.log(data)
        list.value = data
    })
  ```
  > 参数变为1个,自动检测内部变量,所以不用写形参,直接内部写要监听的状态

### VCA的props和emit
- props没有变,emit变为函数了
- props在选项式需要this辅助,组合式没有this,所以改为在setup传递参数
- ==props的使用==
  ```
    js:
    props: {
        title: String,
        left: {
            type: Boolean,
            default: true
        }
    }

    // 把所有父信息封装进对象
    setup(props){ // 第一个参数
        props.title = ...
    }

    // 也可以解构去写(推荐)
    setup({title,left}){
        title = ....
    }
  ```
- ==emit函数用法==
  ```
    // 第二个参数是一个工具包,名字随便写,内部封装了emit的方法,还有attrs,slot等方法
    setup(props,kerwin){
        kerwin.emit("...",....)
    }

    // 推荐解构方法
    setup({title,left},{emit}){
        emit("...",....)
    }

  ```
  > 除此之外,其余的没变,父子互传的:和@照旧写
- ==补充==:**父子强权系列的方法"ref parent root"在组合式中没有啥用,由于中间人问题,所以provide和inject才是主流**
- ref(==父强权,父组件==)
  ```
    tem:
    // @leftClickd: 子传父的钥匙
    // myNav: 父获取子的实例对象
    <Navbar title="首页" :left="true" @leftClick="handleLeft" ref="myNav"></Navbar>

    js:
    setup(){
        // 定义时为null
        const myNav = ref(null)

         // 接受子传父的信息
         // handleLeft由子的emit触发
        const handleLeft = (value)=>{
            console.log("子传父",value)
            // 通过myNav可以操控子内部状态
            console.log("ref获取子组件实例对象",myNav)
        }
    }
  ```
- parent root(==子组件的父组件和根组件==)
  ```

  js:
    setup(){
        // this.parent/root ,子组件获取父组件和根组件,没有this无法使用,但是组合式有个新函数getCurrentInstance,可以获取子组件的实例对象,相当于this
        const _this = getCurrentInstance()

        const handleClick = () => {
            // console.log(kerwin)
            //把计算函数的计算值返回给父
            kerwin.emit("leftClick",computedTitle.value)
            // 只有一个父,所以是相同的
            console.log("拿到父组件和根组件的对象",_this.parent,_this.root)
        }
    }
  ```
  > ref: 定义一个null状态,在标签ref="状态"
  > parent root: 还是需要this,==唯一的小重点,新函数getCurrentInstance(),获取当前的实例对象,和this一样==
### VCA中的provide和inject
- 组合式相对比选项式的升级:
  - 选项式当时学习provide和inject时,父组件公开了信息,所有的后代组件可以使用,但是单个的后代组件无法影响到其他后代组件和父组件,特指无法影响到父组件,这样子组件在处理父组件公开的数据后,也无法响应式地更改父组件的页面,**所以当时很危险地把父组件的实例对象封装在app公开出去了,这很不安全,所有后代组件都能改父组件的信息,就会很混乱**
  - ==但是组合式中的provide和inject完全解决了所有问题,可以响应式,所有的父子通信,父子强权,中间人问题,统统解决==
- ==provide公开: App==
    ```
        js:
        setup(){
            const which = ref("List")
            const show = ref(true)
            // provide 公开which,名为which,具备响应式
            provide("which",which)
            provide("show",show)

            return {
                which,
                show
            }
        }
    ```
    > provide("名字",公开状态),==具备响应式==
- ==inject注入公开信息使用== (后代组件)
    ```
    const which = inject("which")
    const handleClick = ()=>{
        // 让父组件的which改为Detail
        which.value = "Detail"
    }
    ```
    > inject: ==直接按着名字注入公开信息,直接改就行,会响应式到组件App==
- ==案例(模拟导航栏隐藏 + 跨级通信),简单使用这2个新方法,可以看看075的案例解释==

### VCA的生命周期
- 所有的生命周期都转化为函数形式了,如下图
  [![pABO9j1.jpg](https://s21.ax1x.com/2024/10/31/pABO9j1.jpg)](https://imgse.com/i/pABO9j1)
- 如下(==基本顺序没变,**nextTick也变为函数了,需要引入**==)
    ```
        onBeforeMount(() => {
            // ref reactive
            console.log("dom创建之前")
        })

        onMounted(() => {
            console.log("dom创建之后,订阅,ajax,new swiper,echarts初始化")
        })

        onBeforeUpdate(() => {
            console.log("更新之前")
        })

        onUpdated(() => {
            console.log("更新之后,任意状态更新都会调用,这是swiper和echarts都不能写在这的直接原因")
        })

        const handleClick = () => {
            num.value++
            // 一次性的,响应上面的值,周期在updated之后,且也是函数,需要引进
            // nextTick现阶段了解他是个函数,之后我们在深入了解它
            nextTick(() => {
                console.log("nextTick")
            })
        }
    ```
- 销毁函数(==销毁孩子的定时器==)
    ```
    setup() {
        // const不行,他不能被赋值,let var可以
        let clearId

        onMounted(()=>{
            clearId = setInterval(() => {
                console.log("1111")
            }, 1000)
        })

        onBeforeUnmount(() => {
            console.log("销毁之前")
        })

        onUnmounted(() => {
            console.log("销毁之后")
            clearInterval(clearId)
        })
    }
    ```
    > 也转化函数,但是销毁的思路差不多,使用clearInterval函数清除
## setup语法糖(独成一体)
- 不再写setup函数了,语法糖即`<script setup> ... </script>`
- 1.状态的定义和普通常量的定义,不需要return,外部tem直接用
  ```
        // 1.普通变量定义(写死的)
        let msg = "msg-123" // const不能被赋值,这种定义的是常量,无法响应时更改
        // 2.ref reactive定义的状态
        let msgRef = ref("ref-123")
        let msgRea = reactive({
            name: "kerwin",
            age: "100"
        })

    ---------------------
    测试: tem
    msg: {{msg}} 
    msgRef: {{msgRef}}
    msgRea.name: {{msgRea.name}}
    msgRea.age: {{msgRea.age}}

  ```
- 2.曾经的toRefs()的转化,不用return,拿出来解构就行了
    `const { name, age } = { ...toRefs(msgRea) } // reactive -> ref`
    测试: `name: {{name.value}} age: {{age.value}}`
- 3.计算函数没有变化,也是不用return,拿出去直接用
    `const comKerwin = computed(() => name.value + "-12345")`
    测试: `comKerwin: {{comKerwin}}`
- 4.引入组件,只需要import,无需挂载components:{},直接在tempalte里面用
    `import Child from './Child.vue'` 
    测试: `<Child></Child>`
- 5.父子通信,这是改动最大的地方,因为setup()无法传递参数了,props和emit无从获取,==解决的方式是引入两个新的函数defineProps()和defineEmits()==,**注意:子组件照常引入即可**
  - 父传子: title || 子传父:(自定义事件) fromChild
    ```
        tem:
        <Child title="父kerwin" @left="fromChild"></Child>
        js:
        const fromChild = (value)=>{
            console.log("来自子组件的问候",value)
        }
    ```
  - 子组件(**重点,那2个新函数都在那里面**)
    ```
    <template>
        <div>
            <!-- 5 父子通信 -->
            我是Child组件-来自父的爱(加工版): {{compuTitle}}
            我是Child组件-来自父的爱(未加工版): {{ title }} 
            给父组件发消息: <button @click="handleClick">发送</button>
        </div>
    </template>

    <script setup>

    // 5.1 父传子之props
    import { computed } from 'vue';
    // 5.1.1 这样接受父组件的值,是为了子组件二次加工数据,记得props.XX
    const props = defineProps({
        title:{
            type: String,
            default : "父组件没有给你数据"
        }
    })
    const compuTitle = computed(()=> props.title + "(加工后的)")

    // 5.1.2 不想加工直接写,如下去写,并且在tem中也直接用即可
    defineProps({
        title: {
            type: String,
            default: "父组件没有给你数据"
        }
    })

    // 5.2 子传父之emit
    const emit = defineEmits(["left"]) // 存入父给子的"钥匙",父的自定义事件可能有多个,所以用数组封装,想给哪个自定义事件发消息就使用哪个"钥匙"
    const handleClick = () => {
        emit("left","我是子组件给父组件的信息")
    }

    </script>
    ```
    > 总结: props有两个写法(==加工是借助计算函数==),emit稍微变化,其余看代码即可,注释与逻辑很清晰
- 6.指令,全局指令不变,在main.js正常挂载,但是局部组件变量,无需directive挂载,如下
  ```
    tem:
    <div v-kerwin>指令应用处</div>

    js:
    const vKerwin = (el)=>{
        console.log(el)
        el.style.backgroundColor = "yellow"
    } 
  ```
  > 命名有规则,使用驼峰写法,驼峰处对应着'-',如果直接原样写,不考虑v-XX系列,那么就是个普通函数vKerwin vKerwinDetail
  > 例如: vKerwin -> v-kerwin ; vKerinDetail -> v-kerwin-detail 
- 7.动态组件 :is="which" which可以直接放Child(引入的子组件),内部写三目或者函数都可以(一会用个老案例075改造),动态组件在template里面
  - App:
    ```
    <template>
        <div>
            <Navbar v-show="show"></Navbar>

            <!-- 动态组件, List/Detail 改为三目,true为List,false为Detail -->
            <component :is="which ? List : Detail"></component>
        </div>
    </template>

    <script setup>
        import Navbar from './Navbar.vue';
        import List from './List.vue';
        import Detail from './Detail.vue';
        import { provide, ref } from 'vue';

        // which = true 选择List
        const which = ref(true)
        const show = ref(true)
        // provide 公开which,名为which,具备响应式
        provide("which", which)
        provide("show", show)
    </script>
    ```
  - List:
    ```
    <template>
        <div>
            <ul>
                <li v-for="data in datalist" :key="data" @click="handleClick">
                    {{ data }}
                </li>
            </ul>
        </div>
    </template>

    <script setup>
        import { ref, inject } from 'vue';

        const datalist = ref(["aaa", "bbb", "ccc", "ddd", "eee"])
        // 根据公开的名字,注入公开的信息which的值
        const which = inject("which")
        const handleClick = () => {
            // 让父组件的which改为false,三目运算结果为Detail
            which.value = false
        }
    </script>
    ```
    - Detail:
    ```
    <template>
        <div>
            detail <button @click="handleClick">返回</button>
        </div>
    </template>

    <script setup>
        // Detail刚加载完,执行show代码,涉及组合式的生命周期
        import { inject, onMounted } from 'vue';
        // mounted也变成函数,页面加载完成,自动执行回调函数
        const show = inject("show")
        const which = inject("which")

        onMounted(() => {
            show.value = false
        })

        const handleClick = () => {
            show.value = true
            // 动态组件的三目true为List
            which.value = true
        }
    </script>
    ```
    > 其实核心逻辑也没啥,就是App父组件动态组件绑定的:which公开出去,使用三目控制which是true或false,从而使其变为List组件或Detail组件
    > 而List和Detail组件则获取公开的which信息,然后通过点击事件给其赋true或false的布尔值,控制动态组件的变化
- 8. provide 和 inject没有变化 ,在动态组件改造文件夹内部改造的案例就是这个075,内部有它们,可以看看
  
## 路由
### 学前必看之路由对象结构
- 一个路由对象的基本解构如下:
    ```js
        const newRoute = {
            path: string, // 路由路径，例如 '/about'
            name: string, // 路由名称，例如 'about'，可选
            component: Component, // 对应的组件，可以是一个Vue组件
            children: [RouteRecordRaw], // 子路由数组，可选
            redirect: string | Location | Function, // 重定向路径或函数，可选
            alias: string | string[], // 路由别名，可选
            meta: object // 自定义的元数据，例如权限信息,登录许可等，可选
        };
    ```
> ==内部的所有属性都会在笔记中体现,这是个预告==
### 路由的基本使用
- vue Router是vue.js的官方路由,直接npm下载
- 路由的用处: ==特别是在移动端(手机),使用于单页面应用==
  - ==单页面应用==:只有一个页面,切换页面是隐藏和显示不同的组件,还可以可以做切换动画,同时切换页面时,地址会改变,实现路径和组件的映射效果,实际上一直都只有一个页面,只是里面的组件不停切换,使得页面发生改变
  - ==多页面应用==: 多个页面跳转,直接跳转,就拿html文件来说,一个页面就是一个新的html页面,切换时如果网速慢,是没有切换动画的,会卡住
- ==**使用路由**==
  - ==路由的文件架构==: 在路由文件夹中有views和router两个文件夹,router里有index.js,最外面是根组件App.vue(和这些文件夹并列)
  同理还有并列的main.js
  - ==router文件夹的index.js==:这是配置路由的中心,index这个名字是默认的,系统会在router自动去找index.js,相当于可以少写一层地址
  - ==1.index.js配置(**router文件夹的第一个文件**)==:
    - 1.引入2个函数: `import { createWebHashHistory, createRouter } from 'vue-router'` , ==第一个是web的hash地址函数,第二个是创建路由的函数==
    - 2.创建路由:(==固定写2个参数==)
        ```
        const router = createRouter({
            history: createWebHashHistory(), // hash模式web路由地址格式如:  #/film #/center
            routes, // routes时配置的中心,简写模式,routes:routes
        })
        ```
    - 3.在创建路由代码的上面配置路由信息route(**==关键:给之后的组件配置地址,地址自定义去写,一般是文件名==**)
        ```
        const routes = [
            {
                path:"/films", // 路径自动映射 #/films
                name:"Films", // 路由名
                component:Films, // 对应Film组件
            },    
            {
                path:"/cinemas",
                name:"Cinemas",
                component:Cinemas
            },
            {
                path:"/center",
                name:"Center",
                component:Center
            },
        ]
        ```
    - 4.创建组件(==routes内的每一个对象,配以一个组件,**组件写在views文件夹内部**==)
    - 在文件夹router创建Films.vue, Cinemas.vue, Center.vue三个文件,==然后引入index.js文件,**注意,这个引入的变量名要和routes内部配置的component一致**==
        ```
            import Films from '../views/Films.vue'
            import Cinemas from '../views/Cinemas.vue'
            import Center from '../views/Center.vue'
        ```
    - 5.==所有工作配置完成,把创建的路由router公开出去(**别公开错了,公开成routes这个配置项**)==
    ES6: `export default router`
- ==2.在main.js文件中挂载==:
    - 1.**引入路由:** 
    `import router from './2-VueRouter/router'`
    ==index.js的命名优势==: 不写/index.js也行,系统会自动在这个文件夹内部寻找index文件,当然如果你创建时名字不是index,那么就必须写
    - 2.**注册路由插件(固定的,用use)**
        ```
            var app = createApp(App)
            app.use(router) // 固定的,注册路由插件
            app.mount('#app')
        ```
- ==3.根组件App的配置==
  - ==固定的router-view: 作用是让你的路由生效,即在全局都可以通过路由地址正常访问你的组件了,同时根组件加载路由组件,使用插槽,路由中插槽改变为下面的标签了,这也是后续组件动态显示的位置,写几个就显示几个,和原始的slot一样==
    ```
    <template>
        <div>
            <!-- 全局注册了路由,固定的 -->
            <router-view></router-view>
        </div>
    </template>
    ```
- 4.==测试==
- ==默认5173的地址后会加/#/==
- 访问组件直接按照当时path地址即可,例如访问Films组件,地址 .../#/films , 同理其他的 .../#/cinemas .../#/center,然后对应的组件内容会显示在页面

### 路由的重定向和别名
- 别名: (==给一个组件起第二个名字,两个名字都可以用==)
  ```
    {
        path:"/center",
        alias: "/wode", // 别名: 多一个地址选择
        name:"Center",
        component:Center
    }
  ```
- 重定向:(==根据一个固定的地址定向一个固定的组件==)
- ==下面代码是解决一个警告的,就是针对'/'地址(初始无地址的5173/#/)没有指向的组件问题,可以直接给地址'/'定向一个组件==
    ```
    {
        path:"/", 
        redirect:"/films" // 写法1:根据路径找
        // 写法2:根据路由名找,就是routes里面定义的name
        // redirect :{
        //     name:"Films"  
        // }
    },
    ```
    > 这代表,默认地址是Films组件,默认初始页面就是电影页面
- 同时可以配置404(Not Found)页面:
    ```
    {
        path:"/:pathMatch(.*)*", // 404页面,路径都不匹配
        name:"NotFound",
        component:NotFound
    }
    ```
    > 对于所有乱输地址的都显示NotFound组件的页面

### 声明式导航
- 开始逐步实现一个单页面应用的构造,首先完成底部栏,我们在App.vue内部写一个Tabbar组件,用来响应式地控制上面三个vue组件(Films,Cinemas,Center)的显示,==注意Tabbar是App的组件,他在components文件夹内部,而那三个路由组件是在views视图文件夹内部的==
- 原理: Tabbar控制三个组件的显示,组件显示的区域被限制在`<router-view></router-view>`标签内部,
- 效果图: 
    [![pAwGkd0.png](https://s21.ax1x.com/2024/10/25/pAwGkd0.png)](https://imgse.com/i/pAwGkd0)
- App.vue(基本页面结构)
  ```
    <template>
        <div>
            <!-- 根组件加载路由组件,使用插槽,路由世界插槽改变了 -->
            <!-- 全局注册了路由,固定的 -->
            <router-view></router-view>
            <!-- 底层导航栏组件 -->
            <Tabbar></Tabbar>
        </div>
    </template>

    <script>
        import Tabbar from './components/Tabbar.vue';
        export default{
            components: {
                Tabbar
            }
        }
    </script>


    <!-- 对所有组件生效 -->
    <style>
        *{
            margin: 0;
            padding: 0;
        }
        ul{
            list-style: none;
        }
    </style>
  ```
  > 额外给全局配置了一些基本的css
  - Tabbar组件代码:(==**关键,点击对应的导航,显示对应的组件**==)
    ```
        <!-- 下面的标签router-link在main.js全局组件中的app.use(route)已经注册了,根据地址path显示对应组件 to="path" -->
        <ul>
            <li>
                <router-link to="/films" active-class="kerwin-active">电影</router-link>
            </li>
            <li>
                <router-link to="/cinemas" active-class="kerwin-active">影院</router-link>
            </li>
            <li>
                <router-link to="/center" active-class="kerwin-active">我的</router-link>
            </li>
        </ul>

        <style>
            .kerwin-active { // 点击导航栏变为红色
                color: red;
            }
        </style>
    ```
    - 代码解释: 
    - **router-link**: ==通常渲染为带有正确链接的a标签,参数to="path"==,之后标签会自动给a标签添加path地址,使之点击即可跳转到对应的组件页面
    - ==缺点:a标签的样式不好看,虽然我们可以去掉其样式,但是我们有个更好的自定义标签的方式,即可以让其具有跳转功能,又能自定义自己想要的标签,比如li div标签等==
    - **active-class**: 点击对应的标签显示相关css,vue已经配置了自动增删的class名router-link-active,你也可以改名,active-class="..." ,本代码就把点击显示的css样式的class名改为kerwin-active
  - 改进版(自定义 + 新的scss的style样式)
    ```
        <ul>
            <router-link custom to="/films" v-slot="{ isActive, navigate }">
                <li :class="isActive ? 'kerwin-active' : ''" @click="navigate">电影</li>
            </router-link>
            <router-link custom to="/cinemas" v-slot="{ isActive, navigate }">
                <li :class="isActive ? 'kerwin-active' : ''" @click="navigate">影院</li>
            </router-link>
            <router-link custom to="/center" v-slot="{ isActive, navigate }">
                <li :class="isActive ? 'kerwin-active' : ''" @click="navigate">我的</li>
            </router-link>
        </ul>
    ```
    - ==vue提供自定义的一个组件custom去完成此功能,内容插槽进去,**绑定的自定义标签是li**==
    - **以下涉及的相关详细知识在054作用域插槽**
    - ==从custom组件中通过v-slot拿出来两个东西**isActive,navigate**(**固定写就行,知道这两个东西的作用**)==
      - ==isActive==: slot内部的一个属性,当标签被点击时,它会被激活(值变为true),常应用于三目运算(也可以是函数,但是麻烦点)
      - ==例子如下:== 如果标签被选中,那么这个li标签isActive就为true,根据三目运算的语法,样式锁定为你自定义的kerwin-active,如果点击的别的标签,isActive就为false,显示为'',即无css样式
      - ==navgate==: 点击事件固定为navgate,是组件内的固定方法,可以帮你跳转到相关页面,绑定到点击事件@click上即可,也固定写就行
    - 新的css样式写法(==**kerwin 200集的js最后几集讲了这个语法**==)
    ```
        <style scoped lang="scss">
            //lang即language = scss/less,代表使用相关的css语法 
            // scss需要模块 sass  npm i sass
            // css嵌套语法模块,使得css之间的关系更加显而易见
            .tabbar {
                position: fixed;
                bottom: 0px;
                width: 100%;
                height: 50px;
                line-height: 50px;
                text-align: center;

                ul {
                    display: flex;

                    li {
                        flex: 1;
                    }
                }
            }

            .kerwin-active {
                color: red;
            }
        </style>
    ```
    > ==总结就是css嵌套语法模块,使得css之间的关系更加显而易见==
- ==**总结**==: 实现的效果就是,打开App页面,点击Tabbar底层导航栏,实现上面内容的切换(组件的轮流显示)
- ==效果图:==[![pAD1LqA.png](https://s21.ax1x.com/2024/10/31/pAD1LqA.png)](https://imgse.com/i/pAD1LqA)

### 嵌套路由(二级路由)
- 我们想要在Films页面再写一个嵌套路由,分为"正在热映/即将上映"两个孩子路由,点击相关的标签可以显示相关内容,不过这两个路由组件是在Films内部的
- 效果图:[![pAD3AZn.png](https://s21.ax1x.com/2024/10/31/pAD3AZn.png)](https://imgse.com/i/pAD3AZn)
- index.js(==路由配置文件,只关注Films路由组件的配置==)
    ```
    // films的孩子
    import Nowplaying from '../views/films/Nowplaying.vue'
    import comingSoon from '../views/films/comingSoon.vue'

    const routes = [
        ....
        {
            path:"/films", // 路径自动映射 #/films
            name:"Films", // 路由名
            component:Films, // 对应Film组件
            // 嵌套路由
            children:[
                {
                    path:"/films/Nowplaying",
                    component:Nowplaying
                },
                {
                    // path:"/films/comingSoon",
                    // 写法2: 他会自动找到父地址,然后组合在一起,不要加/
                    path:"comingSoon",
                    component:comingSoon
                },
                {
                    // 如果想要显示孩子内容,有个方法,就是写重定向(这里我们做了个默认显示,即跳转到films页面默认显示"正在热映"孩子页面)
                    // 在path:"/"的寻找路由时,使用的路径寻找法,而不是名字寻找法
                    // 名字寻找法会卡死在外层父/films,不会进入孩子,路径寻找法,进入/films后会自动在进入孩子,发现进入/films的重定向,又进去了Nowplaying
                    path:"/films",
                    redirect:"/films/Nowplaying"
                }
            ]
        },
        ....
    ]
    ```
    - 1.==创建孩子组件文件==:
    创建Films组件路由的孩子组件,一般我们会在views文件夹内部在创建一个名为films的文件夹,内部装它的两个孩子Nowplaying和comingSoon,这样不容易搞混父子关系
    - 2.==引入孩子组件,并对Films组件进行配置:==
    语法就是children:[...],内部写孩子的地址path和component,和外面的写法一样,==并且配置component有2个写法==
    - 3.==做默认显示,即跳转到films页面默认显示"正在热映"孩子页面:==
    ==写重定向: 重定向寻找vue组件有2个方法,一个是path路径寻找法,一个是名字寻找法,选择第一种==,名字寻找法会卡死在外层父/films,不会进入孩子,路径寻找法,进入/films后会自动在进入孩子,发现进入/films的重定向,又进去了Nowplaying页面

- Films.vue组件内部写对应的html标签,实现点击+跳转到对应的孩子组件(==核心还是上节课的自定义标签==)
    ```
         <ul class="header">
            <!-- 定制化的好处,我们不想让li标签加红色下划线,而是想让字体宽度单独加,那么就再封装一个span标签,然后把css样式加到span标签上即可 -->
            <router-link custom to="/films/Nowplaying" v-slot="{ isActive, navigate }">
                <li @click="navigate"><span :class="isActive ? 'kerwin-active' : ''">正在热映</span></li>
            </router-link>
            <router-link custom to="/films/comingSoon" v-slot="{ isActive, navigate }">
                <li @click="navigate"><span :class="isActive ? 'kerwin-active' : ''">即将上映</span></li>
            </router-link>
         </ul>

        <!-- 留好孩子将来显示的位置 -->
        <router-view></router-view>
    ```
    > ==定制化的好处: 可以把css样式加到任意想加的标签上,就比如上面代码加到了内层span上面==
### 编程式导航(选项式写法)
- 我们继续制作"正在热映"页面,在正在热映页面中,列出一个列表,显示正在热映的电影,如图[![pADsHtU.png](https://s21.ax1x.com/2024/11/01/pADsHtU.png)](https://imgse.com/i/pADsHtU)
- ==显示"正在热映"电影列表,电影列表为Detail路由组件==
- 先使用**声明式导航**完成这个功能(==相对比编程式导航麻烦一些==)
- 声明式导航: ==跳转到detail路由组件,**需要携带id信息,让详情页面知道你点击的列表哪个内容,从而显示对应的详情页面,也就是说这个Detail路由组件将来要是再精进开发,就要根据不同的id,显示不同电影的详细信息**==
- 先看NowPlaying(正在热映组件)的代码
  ```
    tem:
    <!-- 在卖座网站,会把filmId作为id传给details路由组件,使用动态状态绑定和字符串标签拼接,例如: /#/detail/6666(filmId) -->
    <router-link custom :to="'/detail/'+item.filmId" v-slot="{ navigate }" v-for="item in datalist" :key="item.filmId">
        <li @click="navigate">{{item.name}}</li>
    </router-link>

    js:
    // 老样子,使用json文件模拟后端数据
    let res = await axios('/lib/082test.json')
    this.datalist = res.data.data.films
  ```
  > 利用声明式导航的自定义标签写法,自定义了li标签,再利用v-for把所有的电影列出来,==其中给每个li赋值id(后端正好有,为filmId),:to属性动态绑定,需要加id直接使用'+'拼接字符串即可,看看注释,**这个filmId就是我们要传递给Detail路由组件的id信息**==,实现点击电影直接跳转到电影详情页面,最后还去掉了css样式的方法isActive
- ==Detail路由如何接受这个带有参数数据的地址请求,在index.js的注册中需要做更改==
    ```
    { 
        :myid是一个占位符(随意起名),后面写任意数据都可以匹配到detail页面
        path:'/detail/:myid',
        name: "Detail",
        component:Detail
    }
    ```
    > ==:myid是一个占位符(随意起名),后面写任意数据都可以匹配到detail页面,这样我们请求的path就不会进入404 NotFound路由组件了,**/detail/地址后面可以加一组任意的数据,这个区域正好放置id**,由此我们实现里携带id数据正常访问Detail路由组件==
    > 1.==没有:myid占位符== : 浏览器请求path /#/detail/5325 --> NotFound.vue (专门负责输入路径错误的路由)
    > 2.==有:myid占位符== : 请求path /#/detail/5325 --> detail路由
    > **注意: 一个占位符只负责一次乱写,如果再 '/XX' ,就需要再加一个占位符在:myid后面** 
    ==**注意此时还没提如何获取这些id,并利用这些id对Detail组件进行后端请求数据,下面会有**==
- ==接下来介绍一个新的写法,**编程式导航,对比声明式导航具有更好的封装,更少的参数**,如下==
    ```
    <ul>
        <li v-for="item in datalist" :key="item.filmId" @click="handleClick(item.filmId)">
            {{item.name}}
        </li>
    </ul>

    js:
    methods:{
        handleClick(id){
            // 写法1: 路径(/detail/) + 参数(id)写法
            this.$router.push('/detail/' + id) // 或ES6模板字符串 `/detail/${id}`

            // 写法2: 路径(/detail/) + 参数(id)的对象写法
            this.$router.push({
                name: "Detail", // detail路由在index.js起的名字name
                params:{
                    myid : id // 携带参数 myid是index设置的占位符,后面的id是形参
                }
            })

            // 写法3: query传参 '路径+query' (.detail?id=1234) 
            this.$router.push({
                path:"/detail",
                query:{
                    myid:id // detail?myid=1234 需要在index.js改改路由配置,因为?...写法不属于myid的占位符位置
                }
            })
        }
    }
    ```
    > tem部分只需要正常的使用v-for把电影名列出来(li标签),然后把具体的携带数据请求放入点击事件中去写,记得提前把filmId传进去
    - ==函数部分有3个写法==
    - 新方法:`this.$router.push()`,==这是一个封装好的函数,**也是携带数据配置路由路径的关键**==
      - ==写法1==: **字符串拼接或ES6模板字符串**
      - ==写法2==: 对象写法,2个参数,一个是detail路由组件设置时定义的name,一个时params内部配置占位符myid的值
        > ==写法1和写法2的最终路由体现均为 /#/detail/1234(filmId)的正常格式,所以其index.js注册的detail路由组件配置无需变化==
      - ==写法3==: 2个参数,第一个参数,不再以name为导向,而是以路径path为导向配置,第二个参数改名为query,内部同理配置myid的值
        > ==**注意:此时配置的携带参数路径已经和写法1,2有所不同了,最终显示在网页上的路径由/#/detail/1234--->/#/detail?myid=1234,所以相应的index.js注册detail的写法也应改变**==
    - ==方法3的index.js新的注册方式:==
        ```
        // query 写法3
        { 
            path:'/detail', // 正常path
            name: "Detail",
            component:Detail
        }
        ```
    - 知识点图片总结:[![pADgd4f.jpg](https://s21.ax1x.com/2024/11/01/pADgd4f.jpg)](https://imgse.com/i/pADgd4f)
- ==阶段总结:以上我们解决了声明式导航和编程式导航如何携带参数进行路由请求,声明式导航直接`to=字符串拼接`,而编程式导航由三个方法,各有千秋,第三个尤为特殊,不同于前面所有的方法,由此引申出的index.js内部的detail路由组件的配置也要响应携带数据的写法,也对应着由2个注册的方法,**接下来介绍detail路由组件如何获取路径中的id(filmId)信息,进而通过ajax请求不同的数据**== 
  - ==接下来只讨论编程式导航的写法,毕竟声明式导航不适合构建这个功能==
  - 针对导航式的方法1和2,写法如下:
    ```
        console.log(this.$route)
        console.log(this.$route.params)
        console.log("接受上一个页面传来的参数id,带着id请求后端数据,再渲染页面,id为", this.$route.params.myid)
    ```
    > this.\$route可以只显示当前页面的路由,只打印this.\$route可以发现内部由params和query2个属性,由此我们可以在这两个属性内部获取id,你使用哪一个方法,就在对应的属性里面获取id
  - 方法3 query法的id获取
    ```
        console.log(this.$route) // 看这个对象内部就有params和query两个属性
        console.log(this.$route.query)
        console.log("带着id请求后端数据,再渲染页面,id为",this.$route.query.myid)
    ```
- **==大总结: 至此,所有的内容完毕,从携带数据配置路径path(Nowplaying.vue的配置),到detail路由能够正确接受这些路径(index.js的detail路由注册),到最后的detail路由能够接受到传递过来的id(detail.vue的配置)三步走战略完成==**
### 同组件跳转问题
- 承接上一节的内容继续,首先先学习下面相关知识点,如下
- ==我们在detail组件中设置一个回退按钮,实现一个功能,我们看完电影详情页面后,点击返回,又跳转回"正在热映"的电影列表页面==
  ```
    tem:
     <button @click="handleBack">返回</button>
    js:
    handleBack() {
        // 你可以push回去,但是这样重复压栈重复的数据
        // 可以直接用back()方法
        // this.$router.back()

        // 回退1
        this.$router.go(-1)

        // 前进1
        // this.$router.go(1)
        // this.$router.forward()
    }

  ```
  - ==back() go() forward()可以使用的原理:==
    - 之前跳转页面时,this.$router.push()方法会向history栈添加一个新的记录,所以,当用户点击浏览器后退按钮时,会回到之前的URL,
    > vue提供了的这三个方法,和js的原生的用法一样,看注释如上
- **引出案例和问题**: ==我们想要在电影详情页面(detail)页面设置一个区块,为"猜你喜欢",里面又是一个电影列表,如果点击其中一个电影,又会向detail重新发起新的请求,使得页面由现在的电影介绍变为你刚点击的那个电影介绍,相当于在detail页面内部切换了一部新的电影详情==
- 大致效果图:[![pADgZu9.png](https://s21.ax1x.com/2024/11/01/pADgZu9.png)](https://imgse.com/i/pADgZu9)
- ==问题==: 我们发现点击后并没有新的页面出现
- ==原因==: 难点: 点击猜你喜欢,跳转到/detail/1234,问题是执行跳转后,地址栏确实更新了,由于还是在detail组件内,所以detail组件只会在updated()函数中更新下path,而当执行methods时,mounted()已经执行完了,组件也没销毁和重建,这意味着mounted()函数不会再重复执行了,那么mounted()内部ajax请求数据也不会按照新的myid重复请求新的后端数据,最后的结果是点击了猜你喜欢的电影后,页面根本没变,
- ==解决==: 我们需要监听下$route.params的变化,一旦发现变化,再一次执行ajax请求后端的数据,并且携带更新后的myid请求新的数据渲染新电影页面
- 代码:
    ```
        tem:
        <h4>猜你喜欢-详情页面再跳另一个详情页面</h4>
        <ul>
            <li @click="handleClick">电影1</li>
        </ul>

        js:
        methods:{
            handleClick() {
            // 给猜你喜欢的电影push新的地址
            // 直接往固定地址处跳转
            this.$router.push('/detail/1234')
            }
        },
        watch:{
            // 监听"$route.params"的信息,解决问题重新执行新一次的ajax请求
            "$route.params" : function() {
                console.log("接受猜你喜欢传来的参数id,带着id请求后端数据,再渲染页面,id为", this.$route.params.myid)
            }
        }
    ```
### VAC--动态添加路由addRouter()和删除路由removeRouter()
- ==用于动态添加路由。在某些情况下，应用可能需要根据用户权限、业务逻辑或者运行时的配置来添加新的路由规则。==
- **kerwin开发的后台管理系统EleDemo**
  - 假设正在开发一个后台管理系统，不同的用户角色（如管理员、普通用户）有不同的权限。管理员可以访问系统设置页面，而普通用户没有这个权限。当用户登录成功并且被识别为管理员时，可以动态添加系统设置相关的路由。
- 具体语法:
- addRouter():
  - ==可以直接添加写好的路由,无论是变量代替还是直接写addRoute()里面==
  ```js
    const router = createRouter({
        history: createWebHistory(),
        routes: []
    });

    // 普通的路由
    const aboutRoute = {
        path: '/about',
        component: AboutComponent
    };

    router.addRoute(aboutRoute);
  ``` 
  > 这是常规的,创建了一个路由(createRouter),其中routes是空的; 然后配置了一个路由对象aboutRoute; 最后直接给路由对象添加进入这个路由的routes内部,这是最朴素的添加方式
  - ==**给一个已经存在的路由添加子路由(这是kerwin项目的)**==
  - ==语法==: addRoute(ParentRoute,ChildRoute); 第一个参数是父路由,第二个参数是子路由,把子路由添加到父路由下面; 注意这个父路由必须存在
  - 应用: (==截取部分项目代码==)
    ```js

        import { useRouter } from 'vue-router'

        // useRouter也是vue-Router的一个重要方法;别忘了它和useRoute()之间的辨析
        const router = useRouter()

        routes = [
            {
                path:"/index",
                name:"Home",
                component:Home
            },
            {
                path:"/user-manage/list",
                name:"UserList",
                component:UserList
            },
            {
                path:"/right-manage/rolelist",
                name:"RoleList",
                component:RoleList
            },
                ......
        ]

        // checkPermission是检查item是否可以被动态添加到Mainbox路由下
        routes.forEach(item => {
            checkPermission(item) && router.addRoute('Mainbox', item)
        })
    ```
    > 简单的权限登录之动态路由添加,routes是全部的路由信息,不同的用户角色登录可以访问的路由不同,所以使用checkPermission函数先校验这个item路由是否合格,如果合格才会走后面的代码,把这个路由添加到Mainbox路由下(变为Mainbox路由的孩子路由)
    > ==不要忽略useRouter()==,这里和前面的第一个例子不同,第一个例子实打实创建了一个路由(createRouter),所以才可以使用的路由router的addRoute()方法; 但是这里使用了useRouter(),用另一种方式使用了相同效果
- ==removeRoute()方法==
  - ==同步kerwin的EleDemo,他在那个项目中用于删除Mainbox和他的子路由==
  - ==语法==: removeRoute方法用于从当前的路由配置中删除一个路由。它接受一个路由对象或者路由名称（如果路由有名称的话）作为参数。==简单说就是可以直接把路由对象放进去,或者把路由对象的名字属性name放进去==
  - 案例: 删除Mainbox路由(其孩子路由会被一并删除);
    ```js

        import { useRouter } from 'vue-router'
        const router = useRouter()

        // 先删除Mainbox路由和其孩子路由
        router.removeRoute("Mainbox")
        .....
        // 重新添加Mainbox路由
        router.addRouter({
            path:'/mainbox',
            name: "Mainbox",
            component: Mainbox
        })
        // 重新根据用户权限为Mainbox路由添加新的孩子路由
        ....
        routes.forEach(item => {
            checkPermission(item) && router.addRoute('Mainbox', item)
        })
        ....
    ```
    > 这里清除Mainbox和其孩子路由就是为了彻底删除用户的路由登录权限
### 路由获取特殊信息query/params
- 对于params，在文章详情页路由定义为/article/:id，通过params可以在组件中获取文章 ID，如`this.\$route.params.id`，用于获取对应的文章内容。
- 对于query，在商品列表页，URL 可能是/products?category=electronics&price - range=100 - 500，在组件中可以通过`this.\$route.query`获取这些查询参数(==会以key-value键值对的形式封装入对象之中==)，用于过滤商品列表。
- ==在kerwin的EleDemo项目中,其实并没有在路由层面使用这些动态路由,而是在后端配置(nodejs+express)中,使用到了动态路由:id,使用过req.params获取这个:id动态路由的==
### 路由模式
- 在index.js文件中的路由函数配置进行变化,即==createWebHashHistory --> createWebHistory,**这个模式和普通的地址一样了,无#,只有 /.../.../** */==
- 但是有个问题,浏览器会把你的路由地址当作真正的服务器地址,然后向后端写的服务器里面去请求这个地址,肯定是找不到的,所以会404 Not Found
- ==解决:== 要解决这个问题，你需要做的就是在你的服务器(告诉后端,服务器是后端写的)上添加一个简单的回退路由。如果 URL 不匹配任何静态资源，它应提供与你的应用程序中的 index.html 相同的页面.
- ==解释==: 当我们前端编译好代码后,会打包bulid给后端,告诉后端,如果没有匹配到任何资源,后端就把我提供的index.html渲染在页面上,而这个文件内部的vue路由会接管这些路由地址,服务器的地址搜索权限下放全权交给index.html内部的vue路由处理,提醒下后端即可,这是他们要处理的问题
- ==注意:== vite服务器已经把这个问题消化了,和上面的方法一样,所以在vite中开启的服务器中不会出现这个错误 
- ==总结: 这是后端的事情,但是作为前端你需要知道,只有这样功能才能正常执行==

### 全局路由的拦截(直到VCA与路由全是选项式)
- 路由拦截的应用场景: 在网页点开一个网站,在没有登录的情况下,点击"我的",页面自动跳出一个登陆界面要你登录,这个场景就需要路由的拦截,试想,如果每个区块都需要登录才能查看,你在这些个路由的每一个都添加一个跳转到登录路由的$router.push(),很臃肿重复,所以设置路由拦截,并限定条件,不符合的路由跳转统一跳到XX处
- ==**全局拦截的文件和位置: router路由文件夹index.js的内部,在const router = createRouter({})和export default router之间**==
- Vue Router官网的代码介绍(关于登录):
  ```
    router.beforeEach((to, from, next) => {
        if (to.name !== 'Login' && !isAuthenticated) next({ name: 'Login' })
        else next()
    })
  ```
  - ==**注意: 在所有拦截操作之前,记得把Login路由创建,并在index.js文件中引入和注册**==
  - beforeEach函数: 意为着"在每一次路由跳转前执行一次回调函数"
  - 3个参数: 
    - 1. to,跳转目标组件(目的地)
    - 2. from,从哪里跳(出发地)
    - 3. next() 通过,该条到哪里就哪里
  - if解释: 当前组件跳转目的地不是登录页面且未被授权,则跳转到登录页面,否则(else),你就正常跳即可
    - to.name就是定义路由的name属性,也可以是to.path,后面就接路由定义的路径path即可
    - isAuthenticated根据自己的功能定义,授权代表着什么全看功能,比如登录中,授权可以意味着"登录状态",未被授权意味着"未登录状态"
    - next({name: ""}): 也是name指向型,和to.name一样,同理可以path
- isAuthenticated赋予意义: ==判断是否登录,查看本地是否存储密码token==
    ```
    router.beforeEach(async (to, from, next) => {
        let isAuthenticated = await localStorage.getItem("token")
        if (to.name !== 'Login' && !isAuthenticated) next({ name: 'Login' })
        else next()
    })
    ```
    ==beforeEach内部可以异步ajax,经典的async + await配合axios请求数据==
    > 注意: 上面的页面是针对所有的页面都进行if判断是否跳转到登录页面
- ==部分页面跳转==
  - 写法1: 涉及一个属性,to.fullPath,通过打印to,我们发现这个对象中的fullPath是目标组件的path地址,==下面的就是只针对路由地址为center的页面进行拦截==
    ```
    router.beforeEach(async (to, from, next) => {
        let isAuthenticated = await localStorage.getItem("token")
        if (to.name !== 'Login' && !isAuthenticated && to.fullPath === '/center') next({ name: 'Login' })
        else next()
    })
    ```
  - 写法2: ==上面的写法太臃肿了,部分页面如果是好几个,全部堆在if里不好看,推荐下面的写法==
    ```
    const routes = [
        ....
        {
            path: "/center",
            name: "Center",
            // 定义meta属性
            meta: {
                // 这个名字可以随便起,潜规则是requiredAuth
                requiredAuth: true
            }
        },
        ......
    ]

    const router = createRouter({...})

    router.beforeEach(async (to, from, next) => {
        let isAuthenticated = await localStorage.getItem("token")
        // 每次路由跳转都对路由注册的meta进行检测
        if (to.name !== 'Login' && !isAuthenticated && to.meta.requiredAuth) next({ name: 'Login' })
        else next()
    })

    export default router
    ```
    > 实现逻辑:针对某些页面的优雅写法,还是center组件,看看center组件的注册,==添加新的对象meta,只有center组件的meta.requiredAuth是true,可以进入跳转登录页面的逻辑,其他的组件都是undefined(false),就会跳转到else的逻辑中==,**给需要授权的路径添加==meta属性(固定的)==,requiredAuth的命名是潜规则,可随意起**
- afterEach: 了解,意为"路由跳转之后",它对于分析、更改页面标题、声明页面等辅助功能以及许多其他事情都很有用
    ```
    // 来自Vue Router官网
    router.afterEach((to, from) => {
        // sendToAnalytics(to.fullPath)
        // 比如收集用户的点击量,分析电影的受喜爱程度,然后分析排片量
        console.log("提交后端用户行为信息,在每一次跳转页面之后")
    })
    ```
### 组件内的守卫(局部拦截)
- 组件内的局部拦截,想在那个路由组件内拦截就写哪里,==有beforeRouteEnter(进入组件之前),beforeRouteUpdate(组件更新之前)和beforeRouteLeave(离开组件之前)三个函数==
- ==**本节以下所有代码都是选项式写法,书写位置都在script-export default内部(js区)**==
> 
- ==**beforeRouteUpdate(组件更新之前)**== : 可以替换"猜你喜欢"功能的watch函数,在Detail.vue中,把watch部分注释,替换如下
  ```
    beforeRouteUpdate(to,from){
        console.log("更新之前的this,id没变哦,id为",this.$route.params.myid)
        // to 为目标组件,在里面可以访问到我们想要跳转到的页面id
        console.log("beforeRouteUpdate,id为",to.params.myid)
        // ajax携带id请求数据....
    }
  ```
  > 注意点: 这时更新前的函数内部,所以直接this.\$route访问的还是没修改的,所以要借助to参数,看注释,通过to(目的地)访问要跳转页面的id,之后进行ajax操作即可
- ==**有beforeRouteEnter(进入组件之前)**==: 在center.vue路由组件内部,设置一个局部的登录拦截逻辑如下:
    ```
    async beforeRouteEnter(to,from,next){
        let isAuthenticated = await localStorage.getItem("token")
        // 有密码,被授权,正常跳转
        if(isAuthenticated){
            next()
        }else{
            next({name:"Login"})
        }
    }
    ```
    > 进入center组件前,检查本地存储中有没有"token"的密码存储,有就正常进,没有就跳到登录页面
- ==**beforeRouteLeave(组件离开之前)**== : 比如有时候你离开登录面时,弹出一个提示框,问你确定离开吗?或提醒你记住密码等,如下:
    ```
    beforeRouteLeave(){
        const answer = window.confirm("你确定要离开吗?")
        // window.confirm("") 确认框通常用于验证是否接受用户操作,当你点击"确认",确认框返回 true,如果点击"取消",确认框返回false。
        // window.confirm() 方法可以不带上window对象，直接使用confirm()方法。
        // 如果answer为true,那么就离开,如果为false,就留在本页面
        if(!answer) return false
    }
    ```
    > 此代码应用了window的原生方法confirm,推荐自己做个好看的组件
### 路由懒加载
- 和组件的懒加载一样,对于有些路由的加载不需要第一次进入页面就全部加载出来,等到点击到时,再加载
- 在路由注册的index.js文件中(==看代码即可==)
  ```
    const routes = [
        ......
        {
            path: "/cinemas",
            name: "Cinemas",
            // 087懒加载语法
            component: ()=> import("../views/Cinemas.vue")
        },
        {
            path: "/center",
            alias: "/wode", // 别名: 多一个地址选择
            name: "Center",
            component: ()=> import("../views/Center.vue"),
        }
        ......
    ]
  ```
### VCA与路由
- 我们把所有的代码均改为VAC格式了,放入了bak(VAC)文件中
- 具体修改介绍: 
  - router/index.js: 属于js文件,和vue的组合式写法没有关系
  - components/Tabbar.vue: 内部没有script标签,无需修改
  - views/ NotFound + Films + Cinemas,都没有script标签
  - views/films/comingSoon,内部也没有script标签
- ==重点修改地views/Detail.vue:==
  - ==**1.区分好useRoute和useRouter函数**==
  - ==事先引入==: `import { useRoute, useRouter } from 'vue-router';`
  - 1.`const route = useRoute()`
    - **useRoute()**: 返回路由器实例。**相当于在模板中使用 this.$route** (==返回的当前的路由对象,在那个路由内部用,就可以获取哪个路由的实例对象,进而获取这个路由的信息==)
    - ==**$route**: 是用来获取路由信息的==,route是路由信息对象,里面主要包含路由的一些基本信息,==包含当前的路径,参数,query对象等。(包括name、meta、path、hash、query、params、fullPath、matched、redirectedFrom)==
  - 获取当前路由的params信息: 
    - (选项式) `this.$route.params`
    - (VCA组合式) `route.params`
    > ==总结: this.$route -> route (记住route是useRoute()函数返回的变量,代表当前路由对象,通过它可以获取当前路由的诸多信息,通过.即可)==
  - 2.`const router = useRouter()`
  - **useRouter()**: 返回路由器实例。**相当于在模板中使用 this.$router**
  - ==\$router==: 是用来操作路由的,\$router对象是全局路由的实例，是router构造方法的实例,包含了一些路由的跳转方法，钩子函数等,例如 .push() .go() .forward() .back() .replace()替换页面等
  - 例子: 回退(返回上一页):
    - (选项式) `this.$router.go(-1)`
    - (组合式) `router.go(-1)`
- 2.==局部定义的生命周期函数变化 views/Center.vue==
  - ==生命周期一样,路由的生命周期钩子函数也被**封装成函数了,需要引入**==
  - 具体变化: ==beforeRouteUpdate -> onBeforeRouteUpdate== 
    ```
    import { onBeforeRouteUpdate} from 'vue-router';

    onBeforeRouteUpdate((to,from) => {
        console.log("更新之前的this,id没变哦,id为", route.params.myid)
        console.log("beforeRouteUpdate,id为", to.params.myid)
    })
    ```
  - 2.beforeRouteLeave -> onBeforeRouteLeave
    ```
    onBeforeRouteLeave(() => {
        const answer = window.confirm("你确定要离开吗?")
        if (!answer) return false
    })
    ```
- 3.==注意特殊地,**beforeRouteEnter()没有组合式写法**==
    - 解决方法: 
      - 方法1: ==全局守卫代替局部守卫去拦截(index.js),没变==
      - 方法2(不推荐): 选项式+组合式写法(不推荐),一个文件只能由一个script标签和一个带setup的script标签
        ```
        <!-- 组合式 -->
        <script setup>
            import { onBeforeRouteLeave } from 'vue-router';

            // VCA的路由组件进入钩子函数(特殊,在组合式中没了)
            // 方法1: 全局守卫代替局部守卫去拦截(index.js),没变
            // 方法2: 选项式+组合式写法(不推荐),一个文件只能由一个script标签和一个带setup的script标签

            // VCA的路由组件离开钩子函数
            onBeforeRouteLeave(() => {
                const answer = window.confirm("你确定要离开吗?")
                if (!answer) return false
            })
        </script>

        <!-- 选项式 -->
        <script>
            export default {
                // 进入组件前钩子函数(组件的生命周期),也可以使用async await
                async beforeRouteEnter(to, from, next) {
                    let isAuthenticated = await localStorage.getItem("token")
                    // 有密码,被授权,正常跳转
                    if (isAuthenticated) {
                        next()
                    } else {
                        next({ name: "Login" })
                    }
                }
            }
        </script>
        ```
    - ==也可以和并,只写一个script标签,而setup封装起来,如下==
        ```
        <script>
            import { onBeforeRouteLeave } from 'vue-router';
            export default {
                setup() { // setup组合式区域,仅限此处
                    onBeforeRouteLeave(() => {
                        const answer = window.confirm("你确定要离开吗?")
                        if (!answer) return false
                    })
                },
                async beforeRouteEnter(to, from, next) {
                    let isAuthenticated = await localStorage.getItem("token")
                    // 有密码,被授权,正常跳转
                    if (isAuthenticated) {
                        next()
                    } else {
                        next({ name: "Login" })
                    }
                }
            }
        </script>
        ```
- 4.剩下的修改,除了上面讲到的,还有函数方法,状态定义等VCA写法更更新,具体在views/Nowplaying.vue内部
## Vuex
### Vuex的引入
- 什么时候使用vuex?(针对需要共享的组件 provide inject)
  - 1.页面多个共享状态(provide+inject) -- 非父子通信
  - 2.缓存异步数据(把从后端请求的数据缓存下来,有需求直接用,不用再次请求),减少后端服务访问
  - ==vuex需要通过npm下载,其中解决了一个vuex不能识别的问题,就是创建一个ts文件,已在"其他"收藏栏中收藏==
- 结构文件: 在src下面创建了个3-vuex的文件夹,专门用来测试vuex,其中再在里面新建文件夹store,创建index.js文件
- ==创建vuex路由**并导出**==(在store-index.js文件)
  ```
    import { createStore } from 'vuex'

    const store = createStore({
        state(){
            return{
                isTabbarShow:true
            }
        }
    })
    // 导出供main.js文件注册
    export default store

  ```
  > ==这个store就是脱离App之外的全局状态共享文件,App及内部的组件都可以访问到全局store并修改,并且是响应式的,所有其他组件都可以收到修改后的结果,这个return内部的状态是可公开可修改可访问的==
- ==在main.js中,对vuex进行引入,注册==
  ```
    import { createApp } from 'vue'
    import router from './3-vuex/router'
    import App from './3-vuex/App.vue'
    import store from './3-vuex/store' // 自动去找index.js的文件(如果你这么命名就这样即可)

    var app = createApp(App)

    app.use(router) // 固定的,注册路由插件
    app.use(store) // 注册vuex插件 089
    app.mount('#app')

  ```
- store里面的状态isTabbarShow的挂载(App.vue):
  ```
    tem:
    <!-- 底层导航栏组件,在components文件夹内部 -->
    <!-- 089 + 一个来自store(vuex)的状态 -->
    <Tabbar v-show="$store.state.isTabbarShow"></Tabbar>
  ```
  > ==使用\$store指向的不是store的文件名字,而是const store = createStore({...})的实例对象,然后选择内部的state以及isTabbarShow状态==
- 控制isTabbarShow状态的变化,通过点击事件函数直接修改(==不安全的,下一节开始上保险措施==)
  ```
    //也可以在mounted写,但是我们更早点,在页面加载前就执行
    beforeMount() {
        // 控制store的isTabbarShow
        // 即进入detail页面就隐藏底部的导航
        // 写法1: 方法不安全,这样会乱改
        this.$store.state.isTabbarShow = false 
    },
    // 离开detail页面时再显示
    beforeUnmount() {
        this.$store.state.isTabbarShow = true
    },

  ```
### Vuex-Mutation
- 上一节的代码,不安全,所有的组件都可以乱改,所以添加安全机制,==监控器,Mutation,唯一修改状态的位置,可以监控是谁修改的修改的,何时修改的,存在页面内存中,刷新页面就没了,vue的调试工具可以看vuex情况(但是插件不太好用)==
- ==Mutation的使用方法如下:(在store/index.js)==
  ```
    const store = createStore({
        state(){
            return{
                isTabbarShow:true
            }
        },
        mutations:{
            showTabbar(state){
                state.isTabbarShow = true
            },
            hideTabbar(state){
                state.isTabbarShow = false
            }
        }
    })
  ```
- 使用mutation里面的函数,改进版,Detail.vue
    ```
    beforeMount() {
        // 固定的写法: commit(意为'提交')("mutations内的方法")
        this.$store.commit("hideTabbar")
    },
    // 离开detail页面时再显示
    beforeUnmount() {
        this.$store.commit("showTabbar")
    }
    ```
    > 看注释: ==固定的写法: commit(意为'提交')("mutations内的方法")==
- 如果需要操作的函数太多了也不好,所以还可以携带参数,写法3的改进
- store-index.js
    ```
        mutations里面:
        // 删除showTabbar和hideTabbar函数
        // 写法3: paylood接受一个传参,多个参数就封装对象
        // 只创建一个函数,接受传参来确定isTabbarShow的值,这样子2个函数精简为了一个,由此类推,可以应用在别的方面上减少函数创建
        changeTabbar(state,paylood){
            state.isTabbarShow = paylood
        }
    ```
- ==最后的最后,有些公司为了更好的对监控器命名,在store下面创建一个type.js文件,专门存名字==,如下
  ```
    // 多人开发,有时会整理一个文件,总结所有的监视器名字
    // 防止重名等问题,也便于后期维护,接受工作
    // 在index.js中导入

    // detail页面
    // 这样修改也方便,只要改后面的值,前面所有使用CHANGE_TABBAR的名的mutations就都同步改了
    const CHANGE_TABBAR = "changeTabbar" // 书写格式

    // cinema页面
    // .....

    // ....页面

    export {CHANGE_TABBAR}
  ```
- ==在index.js引入type.js==
    ```
    import {CHANGE_TABBAR} from './type.js'

    mutations里面:
    // ES6写法 [key] = value ,即[CHANGE_TABBAR] = changeTabbar
    [CHANGE_TABBAR](state,paylood){
        state.isTabbarShow = paylood
    }
    ```
> 这样子处理,在多人开发时,可以具有更好的可维护性,并且不会与其他开发者命名重名
### Vuex-Action
- ==vuex的mutation只能监控同步函数,对于异步函数需要使用action解决,action即可以同步也可以异步,不过主要是异步==
- ==action的优点==: 可以对异步数据缓存,减少服务器压力,只有在刷新页面时才会删除缓存数据
- **案例须知**: 我们修改了在index.js内部请求数据的内容(变为/lib/092test.json),请求了一些电影院的数据,==而我们要做的是在进入cinema页面时判断是否需要请求数据,如果之前请求了且没刷新页面,数据会被缓存下来,则不需要请求,如果没有数据,则需要在store的action内部进行异步请求(axios)==
>
- ==cinema.vue==
    ```
    tem: 
        <li v-for="data in $store.state.cinemaList" :key="data.filmId">
            {{data.name}}
        </li>

    js:
    mounted() {
        // if 判断store中的影院数据.length === 0 -> 请求数据(index.js的action请求)
        if (this.$store.state.cinemaList.length === 0) {
            // 不过不要在这里axios,会使数据请求和vuex业务分离,要让vuex控制axios请求
            // 找到store/index.js/actions{...}内的函数getCinemaList,也可以传参,如下固定方法
            this.$store.dispatch("getCinemaList", "参数演示")
        } else {
            // 不刷新就不会清空缓存,可以减少请求ajax的次数
            // vuex自动处理了,不需要else,这里只是演示一下
            console.log("缓存")
        }
    }
    ```
- ==index.js(**action负责异步请求电影数据**)==
    ```
    const store = createStore({
        state() {
            return {
                isTabbarShow: true,
                // 缓存影院数据
                cinemaList: []
            }
        },
        mutations: {
            // state是默认参数,代表state(){}
            // paylood就是正常传参,这里传递的是来自action的axios响应数据
            changeCinemaList(state, paylood) {
                // 给store的状态cinemaList赋值,供Cinemas.vue页面使用
                state.cinemaList = paylood
            }
        },

        actions: {
            // store就是createStore创建的vuex对象
            // paylood是传参(这里是测试来自Cinema.vue的参数)
            // 请求数据 async+await+axios组合
            async getCinemaList(store, paylood) { 
                // 异步工作,还可以缓存请求的数据
                // console.log("actions-ajax参数: ",paylood)
                let res = await axios("/lib/092test.json")
                // 提交给mutations的changeCinemaList,传的参数是请求的响应数据
                store.commit("changeCinemaList", res.data.data.cinemas)
            }
        },
        .......
    })
    ```
- - vuex的流程图: [![pAsEZG9.jpg](https://s21.ax1x.com/2024/11/05/pAsEZG9.jpg)](https://imgse.com/i/pAsEZG9)
> ==复述思维逻辑:==
> 1.在cinema.vue,tem完成基础的'v-for + li'的html界面,其中v-for的参考数据来自store的cinemaList
> 2.在cinema.vue中,一旦进入页面,mounted就会执行一个if逻辑去查看store里状态cinemaList是否为空,如果为空,那么就就请求数据axios,不过请求数据不再此vue文件中,而是在index.js文件中的action内部,使用dispatch调用action内的getCinemaList函数,去它专门负责异步数据的请求,在action的异步数据请求结束后,在提交数据传参给mutation进行store状态cinemaList的赋值工作
> 3.最后cinema.vue的v-for,按着来自store的cinemaList把数据渲染到页面上
- ==精简上面的逻辑(结合图片)==:
    **vue组件cinema** ==--dispatch-->== **action的getCinemaList函数** ==--commit-->== **mutation的changeCinemaList函数** ==--赋值-->== **state的cinemaList** ==--render(渲染)-->== **cinema.vue**
### Vuex-Getter
- ==getters相当于store里面的计算属性,它可以让store接管本属于组件的计算属性功能==
- **案例须知**: 我们做了个select筛选功能,对请求数据的eTicketFlag(0/1)属性进行筛选分类显示不同类别的电影院数据,进而在下面的li渲染相关的数据
- ==传统的计算属性方法==
  - ==cinema.vue==
      ```
        tem:
          <select v-model="type">
              <!-- 注意: 我们要的最终数据要求是Number型,而非String型 -->
              <option :value="1">App购票</option>
              <option :value="0">前台兑换</option>
          </select>

          <ul>
              <!-- 1.传统的,直接使用计算属性,与store无关 -->
              <!-- 使用store的cinemaList数据,并用计算属性进行select筛选 -->
              <li v-for="data in filterCinemaList" :key="data.filmId">
                  {{data.name}}
              </li>
          </ul>


        js:
            // 传统方式计算属性
            computed:{
                filterCinemaList(){
                    // 按照eTicketFlag筛选,每个数据都有eTicketFlag属性,只有0和1两个值
                    return this.$store.state.cinemaList.filter(item=>item.eTicketFlag === this.type)
                }
            }
    ```
- ==非传统方式,即使用getters接管vue组件的计算属性==
  - ==cinema.vue==
    ```
    tem:
          <select v-model="type">
              <!-- 注意: 我们要的最终数据要求是Number型,而非String型 -->
              <option :value="1">App购票</option>
              <option :value="0">前台兑换</option>
          </select>

        <!-- 2.让store接管,使用getter下的计算属性函数filterCinemaList,并把type参数传递进去 -->
        <!-- 细看v-for: $store.getters.filterCinemaList为getters第一个返回的箭头函数,此时再加括号调用函数传参type -->
        <!-- 正好给那个箭头函数传参调用了,箭头函数执行完毕后,返回筛选后的数组给v-for做循环 -->
        <!-- 对比直接在cinemas.vue文件中使用计算属性的区别是: 在本地用计算属性,可以直接得到筛选好的数组,而getters方法,会先得到一个箭头函数(第一次return),再给箭头函数传递参数,然后才能的到筛选好的数组(第二次return),这也是为了弥补计算属性不能传递参数的曲线实现方法 -->
        <li v-for="data in $store.getters.filterCinemaList(type)" :key="data.filmId">
            {{ data.name }}
        </li>
    ```
  - ==index.js(getters处理,与action,mutation,state并列的)== 
    ```
        // getters: store里面的计算属性
        // getter支持传参,在数据查询非常有用,写法有点绕
        getters: {
            // 形参state可以获取store内部的state属性
            filterCinemaList(state) { 
                // 计算属性不支持传递参数,所以我们嵌套个函数在外面,把type参数传递给函数
                // 具体行为: 首先计算属性会返回这个箭头函数,这个箭头函数内部再返回真正的值,其中多套一层函数就是为了传参
                // 具体运作: 看cinemas.vue的li处的注释
                return (type) => {
                    return state.cinemaList.filter(item => item.eTicketFlag === type )
                }
            }
        }
    ```
    > ==计算属性不允许传参,但是这里面多用了一层嵌套函数去给计算属性传参,认真看注释==

### Vuex-辅助函数
- ==**mutation和action进入方法函数栏, state和getters进入计算属性栏**,这是语法糖,目的是简化(this).$store.XX在组件中出现,而是直接转为相关的函数,具体有4个,为**mapState,mapGetters,mapActions和mapMutations**==
- 所有语法糖的作用是映射原本在index.js的内容到此组件,使得组件使用它们不必在特意指向store($store)
- ==App.vue **以mapState为例子**==
    ```
    <div>
        <router-view></router-view>
        <!-- 093 下面的v-show,跟着一长串不够优雅,所以要利用计算属性/mapState去解决它 -->
         <!-- 原本: $store.state.isTabbarShow -->
        <Tabbar v-show="isTabbarShow"></Tabbar>
    </div>


    computed:{
        // 下面的这个方法就是上面传统写法的封装,里面数组支持写多个
        // 把store中想要状态写里面进行改装,最后ES6结构赋值进计算属性内部
         ...mapState(['isTabbarShow']),
        // 后面就写一些组件内部的自定义的计算属性即可
         aaa(){
             return 1
         }
    }
    ```
    > 内部相当于把index.js的state(){...}部分映射过来,mapState的内部是数组,可以写多个,此组件想要映射哪个组件就写哪个,这个语法糖会把代码封装进对象,我们展开对象(ES6)融入computed,之后再后面写本组件的其他自定义计算属性即可
- ==cinema.vue(**mapActions,mapGetters**)==
  ```
    computed:{
        ...mapState(['cinemaList']),
        // gettters映射
        ...mapGetters(['filterCinemaList']),
    },
    methods:{
        // 同理会把actions内部的getCinemaList函数映射到本文件中
        ...mapActions(['getCinemaList']),
    }
  ```
  - 对于action的发送: `this.$store.dispatch("getCinemaList", "参数演示` 变为 ` this.getCinemaList('参数演示')`,==不需要dispatch了,已经映射进来了==
  - 对于store内部计算属性的使用: `v-for="$store.getters.filterCinemaList(type)"`变为`v-for="data in filterCinemaList(type)`,也是减少$store.getters这个长长的前缀
- ==Detail.vue(**mapMutation**)==
  ```
    methods: {
        // 针对 this.$store.commit("changeTabbar", true) 向mutation内部提交写法也有语法糖
        // 同理需引入,同理ES6展开使用,内部写CHANGE_TABBAR变量也行(需引入),写"changeTabbar"也行

        ...mapMutations(["changeTabbar"]),

        // mapMutations相当于把index.js的mutations内部的函数func映射过来
        // 语法糖展开就如下面
        // changeTabbar(payLoad) {
        //     this.$store.commit('addAge', payLoad)
        // }
    }
  ```
  > ==**这个更详细地表现了mutation如何映射过来的,看注释**==
    - 对于mutation内部函数的使用由原来的`this.$store.commit("changeTabbar", false)`变为`this.changeTabbar(false)`,==和action使用一样,删除了commit,不再需要提交,已经映射到本组件了,所以"this.XX"直接用即可==


### Vuex-Module
- ==模块化是为了管理和分工较多的store内容,每个子模块都有自己的state,mutation,action,getters==
- 具体模块化的代码如下
- 主index.js
  ```
        import { createStore } from 'vuex'
        // 引入模块
        import TabbarModule from './module/TabbarModule.js'
        import CinemaModule from './module/CinemaModule.js'

        const store = createStore({
            // 使用模块
            modules:{
                // 简写方式
                TabbarModule,
                CinemaModule
            }
        })

        export default store
  ```
    > 我们在store文件夹内创建新的文件夹module,在内部放入2个子模块TabbarModule.js和CinemaModule.js,内部分别管理Tabbar和Cinema各自的store内容,之后引入,放在一起,看注释代码即可
- ==这么单独截取模块化后会出现问题,代码在this的过程中会多嵌套一层模块的名字==,比如
  - **如果我们不用mapXX语法糖**,==正常访问isTabbarShow状态由`this.$store.state.isTabbarShow`变为`this.$store.state.TabbarModule.isTabbarShow`==,这个是无法改变的,只能这么写
  - 但是我们使用的提交方案: 例如 向mutation提交的`this.$store.commit("changeTabbar", false)`和 向action提交的`this.$store.dispatch("getCinemaList", "参数演示)`==**不会受影响,正常运行**==
  - ==**如果我们用了mapXX语法糖**==,所有语法糖失灵,因为语法糖是去index.js文件中去寻找相关内容,现在已经打包给子组件了,它找不到,就需要新的知识,==命名空间namespaced,在子模块打开这个属性,true==
- ==**注意:下面的2个子模块内是对象的配置,并不需要createStore({...})**==
- TabbarModule.js
  ```
    import { CHANGE_TABBAR } from '../type.js' // type.js的路径改改
    // 作为一个对象,之后导出去
    const TabbarModule = {
        // 开启命名空间: 正常使用辅助函数的必要
        namespaced: true,
        state() {
            return {
                isTabbarShow: true,
            }
        },
        mutations: {
            [CHANGE_TABBAR](state, paylood) {
                state.isTabbarShow = paylood
            },
        }
    }

    export default TabbarModule
  ```
- CinemaModule.js
    ```
        import axios from 'axios'
        // 作为一个对象,之后导出去
        const CinemaModule = {
            // 开启命名空间: 正常使用辅助函数的必要
            namespaced: true,
            state() {
                return {
                    cinemaList: []
                }
            },
            mutations: {
                changeCinemaList(state, paylood) {
                    state.cinemaList = paylood
                }
            },
            actions: {
                async getCinemaList(store, paylood) {
                    let res = await axios("/lib/092test.json")
                    store.commit("changeCinemaList", res.data.data.cinemas)
                }
            },
            getters: {
                filterCinemaList(state) {
                    return (type) => {
                        return state.cinemaList.filter(item => item.eTicketFlag === type)
                    }
                }
            }
        }

        export default CinemaModule
    ```
- 第二部: ==给所有的mapXX指定好是来自哪个子模块的==,参考名字就是index.js的module:{...}内部,具体如下
- ==App.vue==
  ```
    computed:{
        // 为了正常使用辅助函数,我们在子模块加了命名空间后,在vue中使用辅助函数,需要在前面另加一个命名,这个名字和模块在index.js挂载的名字一样 
        // 它会去TabbarModule模块中去找isTabbarShow
        ...mapState('TabbarModule',['isTabbarShow']),
    }
  ```
- 同理其他的 ==cinema.vue==
  ```
    computed:{
        // 下面辅助函数全部添加命名空间
        ...mapState('CinemaModule',['cinemaList']),
        ...mapGetters('CinemaModule',['filterCinemaList'])
    },
    methods:{
        ...mapActions('CinemaModule',['getCinemaList']),
    }
  ```
- Detail.vue
  ```
    methods: {
        // 模块下正常使用辅助函数:
        ...mapMutations('TabbarModule',["changeTabbar"]),
    }
  ```
    > ==如上操作后,所有的语法糖正常使用,**使用语法糖可以规避(this.)$store.XXModule.XX必须嵌套一层模块名的问题**==
    - 额外的: ==如果定义的了语法糖mapXX还要使用commit和dispatch就需要特别指出模块名字了==,如`this.$store.commit("TabbarModule/changeTabbar", false)`和`this.$store.dispatch("CinemaModule/getCinemaList", "参数演示)`
### Vuex + VCA
- ==事先声明: 作者在发现Vuex在VCA的局限性后,索性重写了个pinia的状态管理库,主要适配方向就是vue3的VCA写法,之后会学,而且是作者推荐的,有点像vite和vue-cli的感觉,vuex迟早变为弃子== 
- ==**已经放入bak(VCA)文件夹内部,以下所有的代码作为VCA的写法,均在script+setup语法糖内**==
- ==useStore()方法的引入: (**替代选项式中的this**==)
  - App.vue
    ```
      tem:
      <div>
          VCA + Vuex
          <router-view></router-view>
          <!-- 获取状态: 模块化写法无法避免的多套一层模块名 -->
          <!-- 不再使用this -->
          <Tabbar v-show="store.state.TabbarModule.isTabbarShow"></Tabbar>
      </div>

      js:
      // 引入useStore方法
      import { useStore} from 'vuex/dist/vuex.cjs.js';
      // 创建对象store
      const store = useStore() // =this.$store
    ```
     > ==useStore()方法的主要作用就是帮助此vue文件获取store对象,从而不必使用this.$store去单独指向store对象,直接就可以store.XX了,**不过如果你的store进行了模块化处理,别忘了多套一层模块的名字,否则vue它找不到模块内部的状态等信息**==
- **拓展**: ==在语法糖setup中,我们不能使用mapXX系列语法糖了,这取决于其内核源代码隐含this,在组合式中,this是无意义的,但是我们可以通过bind的指向来改变其this指向去使用它,**注意:笔记这里的重点不在于如何在语法糖setup中使用mapXX系列,而是在于补全一个关于bind的知识漏洞,更加深刻地认识bind,以及对象这个复杂类型数据,相关的代码数据均会同步到js笔记的bind知识点区**==
  - 首先我们看下mapState的源码:
    ```
      const state = mapState("TabbarModule", ["isTabbarShow"])
      console.log(state.isTabbarShow) 

      --------------源码如下(控制台输出)----------------
      ƒ mappedState() {
      var state = this.$store.state;
      var getters = this.$store.getters;
      if (namespace) {
      var module2 = getModuleByNamespace(this.$store, "mapState"…

    ```
  - (==js/bind知识点的查漏补缺==)插入一个知识点,bing(Obj),将this指向一个新的对象,对象是复杂类型,拥有地址,这样this指向这个地址后,就可以通过this.属性访问对象里面的值了,下面是一个简单的例子
    ```
      let obj = {
          name: 'Example Object',
          showName: function() {
              console.log(this.name);
          }
      };

      let newFunction = obj.showName.bind({ name: 'New Object' });
      newFunction(); // 输出：New Object
    ```
    > ==在这个例子中，obj.showName是一个方法，原本它内部的this指向obj。但是通过bind方法将其绑定到一个新的对象上，新对象中有一个name属性。当调用新的函数newFunction时，它会以新绑定的对象作为this，输出新对象的name属性值==
  - 我们的当务之急是把源码中的this.$store(undefined)给转化为真正的store实例对象,对代码进行如下操作
    ```
      // 但是我们利用js的bind修改指向一个新的对象,这个对象只有一个属性名为$store,他的值为store,this已经指向这个新对象了,所以这个this.$store实际就是obj.$store(假设这个对象我们起名为obj),那么它就等于这个store,所以综上来看,最终源码中的this.$store等同于store(这个store就是通过useStore获取的真正store对象)
      state.isTabbarShow = state.isTabbarShow.bind({ $store: store })
      // 经过指向更改后,计算属性函数内部传入一个回调函数state.isTabbarShow(store的state本身就需要返回),返回isTabbarShow的值
      const isTabbarShow = computed(state.isTabbarShow)
    ```
  - 最后我们在tem内部可以直接使用isTabbarShow
    ```
      <!-- 计算属性+更改bind指向 使用map语法糖 -->
      <Tabbar v-show="isTabbarShow"></Tabbar>
    ```
- 其他VCA的改变,例如在Detail.vue中,我们进出电影详情页面需要隐藏和显示底边栏,所以需要在给mutation的changeTabbar提交布尔参数去控制isTabbarShow,==**但是由于store已经模块化了,所以需要点改动,下面的state和getters的获取,commit和dispatch的提交,这四个重点关注,其中commit和dispatch的方法是统一的,state的获取也比较符合常识,唯独getters内部函数的获取(store的计算属性)有点新颖**==
- Detail.vue(==只显示关键信息,生命周期的VCA写法不再赘述,store上面刚讲了也略==)
  ```
    // 实现功能: 进入Detail组件页面不渲染Tabbar栏,出去后再渲染回来
    // 在页面加载之前,不显示Tabbar栏
    onBeforeMount(()=>{
        // 由于我们定义了在子模块命名空间namespaced,这时候使用commit就需要另外指出模块的名字
        store.commit("TabbarModule/changeTabbar",false) 
    })
    // 当组件销毁前,显示Tabbar栏
    onBeforeUnmount(()=>{
        store.commit("TabbarModule/changeTabbar",true)
    })
  ```
- cinema.vue(==处理筛选数据和请求异步数据的地方==)
- Action请求异步数据,==dispatch和上面的commit的命名一样==,需要另加模块名,如下:
  ```
    // 指挥store请求数据
    onMounted(() => {
        // 同理和App.vue获取isTabbarShow一样,需要多套一层模块名
        if (store.state.CinemaModule.cinemaList.length === 0) {
            store.dispatch("CinemaModule/getCinemaList",'参数演示')
        } else {
            console.log("缓存")
        }
    })
  ```
- 筛选数据我们需要获取store内部的getters函数数据,==**经过打印测试,我们发现getters的获取方式和状态的获取方式略有不同**==
  ```
    // 测试store.getters到底是什么 
    console.log(store.getters)
    // 经测试,要getters内部的filterCinemaList函数,需要如下格式访问
    console.log(store.getters['CinemaModule/filterCinemaList'])
  ```
- 最终,tem中调用getters中filterCinemaList函数,并进行传参
  ```
    <ul>
        <!-- 经过mounted打印测试,发现命名空间下的state和getters访问有所不同 -->
        <!-- 切记不要写成state状态获取格式: store.getters.CinemaModule.filterCinemaList(type) -->
        <li v-for="data in store.getters['CinemaModule/filterCinemaList'](type)" :key="data.filmId">
            {{ data.name }}
        </li>
    </ul>
  ```
  > (==此内容以补充进vuex-Module中==): **如果我们store模块化的同时,还要使用commit和dispatch的话,就必须在==第一个参数最前面另写好模块名==(js文件内部的定义的对象名)**,然后再写模块内具体的内容
### vuex与持久性化插件
- vuex-持久化插件(==pinia也有类似插件==),下载 `npm i vuex-persistedstate`,==来自github,vue支持你自己写组件,这是人家写的一个组件==
- 作用: 有时候为了刷新页面时保留一些数据,比如侧边栏,我们打开了,刷新后,侧边栏又关闭了,这就需要插件帮助,记录你上次的操作,在刷新页面后仍然不变,插件会把对应的信息记录在localStorage中,这样即使你关闭网页再回来也依旧保留一些你上次留下的个性化操作
- 具体用法(也可参照文档)
  ```
    const store = createStore({
        plugins: [createPersistedState({
            // 限定存储那些信息
            // reducer: (state)=>state.TabbarModule.isTabbarShow

            // 写法2:
            reducer : (state) => {
                return {
                    isTabbarShow: state.TabbarModule.isTabbarShow
                }
            }
        })],
        // 使用模块
        modules:{
            // 简写方式
            TabbarModule,
            CinemaModule
        }
    })
  ```
  > 记录了Tabbar组件isTabbarShow的布尔值,同步进入localstorage,key值为vuex,对应的value就有isTabbarShow的布尔值记录
## pinia
### optionStore的创建
- ==vuex更贴合选项式,而pinia更贴合vue3的组合式写法,pinia是作者的新工具库,要比vuex更加强大,是未来的趋势,是作者向'vue3+组合式写法'的引导,**注意:pinia与vuex实际上没有任何联系**==
- pinia同样支持选项式(option)和组合式(VCA)两个写法,==优先学习选项式写法(由于后期学组合式写法,所以选项式写法封装进bak(optionStore)文件夹里了)==,首先pinia支持多个store开发的,不再像之前的vuex,只有一个js文件统一规划,所以首先在store文件夹中,创建2个js文件CinemaStore.js和TabbarStore.js,==相对比vuex需要模块化,pinia直接可以创建单js文件,不需要引入模块等繁杂动作,**同时记住,所有的访问都不需要多余嵌套模块名了,比如状态state的访问,action函数的调用**==
  >
- ==CinemaStore.js==
  ```
    import {defineStore} from 'pinia'
    import axios from 'axios'

    const useCinemaStore = defineStore("cinema",()=>{
        state:()=>{
            return{
                cinemaList: []
            }
        },
        actions: {
            // 由箭头函数造成的意外写法
            // getCinemaList: async () => {
            //     let res = await axios("/lib/092test.json")
            //     // 可以直接获取到状态,无需像vuex一样,先提交给mutation,再由mutation提交给state修改,直接一步到位this.XX(state)
            //     console.log(this) // this由于箭头函数的原因,指向父级作用域window上了,直接undefined了
            //     this.cinemaList = res.data.data.cinemas
            //     // console.log(cinemaList) // undefined
            // }

            // 不再支持传递store了
            async getCinemaList(){
                let res = await axios("/lib/092test.json")
                // 可以直接获取到状态,无需像vuex一样,先提交给mutation,再由mutation提交给state修改,直接一步到位this.XX(state)
                console.log(this) // this ES5谁调用这个函数指向谁
                // 学习setupStore后(组合式),就不必为this担忧了
                this.cinemaList = res.data.data.cinemas
            },
        },
        // "筛选0/1 + select"功能
        // store中的计算属性
        getters:{
            // 支持传递状态state,还是嵌套一层函数用于传参
            filterCinemaList(state){
                return (type)=>{
                    return state.cinemaList.filter(item=>item.eTicketFlag === type)
                }
            }
        }

    })

    // 导出
    export default useCinemaStore

  ```
  - ==代码解析:==
    - defineStore: 这是创建pinia下store的关键函数,对于变量的命名潜规则是加'use'前缀,具体参数第一个为这个store的名字,几乎不怎么用,但是不要重复.第二个参数是对象,内部配置状态state,action,getters等
    - 格式: `const useXXX = defineStore("name",{...})`
    - {..}对象配置: 内部就是选项式写法,几乎没变
    - ==需要注意的点==:
      - action内部的函数别写成箭头函数,this的指向很重要
      - getters仍是多嵌套一层return用于传参
  > 
- ==同理TabbarStore.js==
  ```
        import {defineStore} from 'pinia'

        const useTabbarStore = defineStore("tabbar",{
            // option Store
            // state:()=>{
            //     return {
            //         isTabbarShow: true
            //     }
            // }

            // ES6简写,只有一句话的情况下省略return,不过只返回对象的写法有所不同,因为编译器无法区分函数和对象的{},所以要包在()内部,如下
            state:()=>({
                isTabbarShow: true
            }),
            // getters,actions
            actions:{ // pinia没有mutation
                change(value){
                    this.isTabbarShow = value
                }
            }
        })

        // 记得导出
        export default useTabbarStore
  ```
  > ==讲了一个state的简写,涉及js的ES6的语法常识==
- main.js(==**挂载pinia的地方**==)
  ```
    import { createApp } from 'vue'
    import { createPinia } from 'pinia'

    const pinia = createPinia()
    var app = createApp(App)

    app.use(router) // 固定的,注册路由插件
    app.use(pinia) // 注册pinia
    app.mount('#app')
  ```
  > 三步走: 引入pinia工具,创建pinia对象,注册pinia对象
### State
- ==初步使用(**App.vue**),我们创建pinia使用的是选项式,但是我们所有的vue中使用的是组合式setup语法糖==
  ```
    <template>
        pinia
        <div>
            <router-view></router-view>

            <!-- 不同于vuex的模块化,pinia不需要套一层模块名,状态isTabbarShow直接在store里面了 -->
            <Tabbar v-show="store.isTabbarShow"></Tabbar>
        </div>
    </template>


    <script setup>
        import { storeToRefs } from 'pinia';
        import Tabbar from './components/Tabbar.vue'; // 引入Tabbar路由组件不需要注册
        import useTabbarStore from './store/TabbarStore';

        // 调用TabbarStore.js的导出函数useTabbarStore,获取其创建的store对象(pinia)
        const store = useTabbarStore()
        // console.log(store)
        // 注意: 生成的store的对象是一个reactive包装的对象,解构出来可以访问到其值,但是没有响应式了(基础知识)
        // 非要解构必须转为ref形式,pinia提供了storeToRefs(需引入)
        // const {isTabbarShow} = storeToRefs(store)
    </script>
  ```
    > 1.==需要isTabbarShow的值,去store文件夹中找含有此状态值的js文件,然后引入并调用方法,**即可获取了那个js文件创建的pinia下的store对象,然后在此vue文件内部可以通过`.`去调用那个js文件内部配置**==,如状态,函数方法,计算属性等信息了
    > ==**注意:** 访问状态直接通过store.isTabbarShow即可访问,不再需要vuex多嵌套一层模块,十分方便,即Tabbar组件可以直接获取TabbarStore.js==
    > 2.==**延伸,看注释**==,有些人想用解构的方法去直接获取状态值,但是由于生成的store的对象是一个reactive包装的对象,不支持响应式,所以pinia提供了storeToRefs方法,帮你转为ref型对象再解构就可以了
- 在Detail.vue(电影详情页面),进出是控制底边栏的隐藏与显示,我们就是用pinia的方式去直接控制isTabbarShow的值,如下
  ```
    // 引入pinia的store
    import useTabbarStore from '../store/TabbarStore';
    
    // 创建前,进入详情页隐藏底边栏Tabbar
    onBeforeMount(() => {
        store.isTabbarShow = false
    })
    // 销毁前,离开详情页显示底边栏Tabbar
    onBeforeUnmount(() => {
        store.isTabbarShow = true
    })
  ```
  > 在获取TabbarStore.js内部的store对象后,直接通过`.`去更改对象内部state的isTabbarShow的值,简单粗暴,符合常理
- 拓展延伸2个小知识: ==\$patch({})和\$reset()==
  ```
    onBeforeMount(() => {
        store.$patch({
            isTabbarShow:false
        })
    })
    onBeforeUnmount(() => {
        store.$patch({
            isTabbarShow:true
        })
    })
  ```
  > state补丁api,会把下面的对象作为补丁和TabbarStore.js中state合并,同名的,后来的覆盖先来的,所以也能实现相同的效果
  > 此方法适合一次修改多个状态,对象内写多个对象就行了
- $reset(): 重置: 使状态state变为原来的值
  ```
    onBeforeMount(() => {
        store.isTabbarShow = false
    })
    onBeforeUnmount(() => {
        store.$reset() // 原来isTabbarShow初始化为true,现在变回去
    })
  ```
### Action
- ==引子==:在vuex中我们异步调取数据必须先去action再去mutation,最后才能改变state,其中mutation是冗余的一个步骤,==所以在pinia中删除了mutation,直接由action接管所有的同步异步处理==,并且可以直接对state进行更改,这也就意味着commit和dispatch都会被删除,前者是因为mutation没了,action向mutation提交数据的方法commit也就跟着没了,后者是,==以后想要调取aciton的方法,也可以向获取状态一样,直接`.`就行,只需要引入对应js文件(store),去获取其内部的action方法即可==
- 接下来学习如何使用action内部的方法(==Cinemas.vue==)
  ```
    js: script+setup
    import useCinemaStore from '../store/CinemaStore';

    onMounted(() => {
        if (store.cinemaList.length === 0) {
            // 请求数据
            // 直接调用CinemaStore.js的action方法getCinemaList
            store.getCinemaList() 
        } else {
            console.log("缓存")
        }
    })
  ```
> 获取到CinemaStore.js创建的store后,==其内部的状态cinemaList和action函数方法getCinemaList,直接通过`.`调用即可==

- 同理Detail.vue内部的isTabbarShow状态的改变,也可以由TabbarStore.js内部的action的change函数代理,所以如下
  ```
    import useTabbarStore from '../store/TabbarStore';

    // 创建前,进入详情页隐藏底边栏Tabbar
    onBeforeMount(() => {
        // action解决,直接store.XX即可,无需嵌套模块名
        store.change(false)
    })
    // 销毁前,离开详情页显示底边栏Tabbar
    onBeforeUnmount(() => {
        store.change(true)
    })
  ```
### Getter
- ==getter就是store里面的计算属性,拿取也是十分方便==
- Cinemas.vue
  ```
    tem:
        <ul>
            <!-- 直接调用CinemaStore.js的状态cinemaList即可 -->
            <!-- 拿取计算属性也是十分简便,直接.即可 -->
            <li v-for="data in store.filterCinemaList(type)" :key="data.filmId">
                {{ data.name }}
            </li>
        </ul>

    js:
    import useCinemaStore from '../store/CinemaStore';
  ```
    > 调用方法变简单了,其余没变
### setupStore(VAC)
- 组合式写store文件,在 Setup Store 中：
    ==ref() 就是 state 属性==
    ==computed() 就是 getters==
    ==function() 就是 actions==
- CinemaStore.js
  ```
        import {defineStore} from 'pinia'
        import axios from 'axios'
        import { ref,computed } from 'vue'

        const useCinemaStore = defineStore("cinema",()=>{
            // 内部就是Vue组合式的写法

            // = state
            const cinemaList = ref([])

            // = Action
            const getCinemaList = async()=>{
                let res = await axios("/lib/092test.json")
                cinemaList.value = res.data.data.cinemas
            }

            // computed() 就是 getters
            // 依旧是箭头函数返回一个箭头函数(type)=>{...},而返回的箭头函数需要调用并传递阐述才能在内部返回真正筛选好的值
            // 这个地方的写法稍微注意一下,箭头函数ES6单语句直接返回,省略了一个return
            const filterCinemaList = computed(()=>
                (type)=>{
                    // 记得+value
                    return cinemaList.value.filter(item=>item.eTicketFlag === type)
                }
            )

            return { // cinema.vue无需更改
                cinemaList,
                getCinemaList,
                filterCinemaList
            }

        })

        // 导出
        export default useCinemaStore
  ```
- TabbarStore.js
  ```
        import { defineStore } from 'pinia'
        import {ref} from 'vue'

        const useTabbarStore = defineStore("tabbar", () => {
            // ref包装 = state
            const isTabbarShow = ref(true)
            // 函数 = Action
            const change = (value)=>{
                isTabbarShow.value = value
            }

            return{ // 你必须在 setup store 中返回 state 的所有属性
                isTabbarShow, // 相关App.vue对于isTabbarShow的使用全都不用改
                change
            }
        })

        // 记得导出
        export default useTabbarStore
  ```
  > 记得除了导出,还要return组合式中定义的状态,函数,计算属性
### 使用Store
- ==使用pinia定义的store==
  ```
    <script setup>
        import { useCounterStore } from '@/stores/counter'
        // 可以在组件中的任意位置访问 `store` 变量 ✨
        const store = useCounterStore()
    </script>
  ```
  > 注意: ==引入后使用需要**加()**,不要忘记!!!!==
- 一旦 store 被实例化，你可以直接访问在 store 的 state、getters 和 actions 中定义的任何属性。
- store 是一个用 reactive 包装的对象，这意味着不需要在 getters 后面写 .value。就像 setup 中的 props 一样，==我们不能对它进行解构==
- ==useCounterStore.js==
    ```js
    export const useCounterStore = defineStore('counter', () => {
        const count = ref(0)
        const doubleCount = computed(() => count.value * 2)
        function increment() {
            count.value++
        }

        return { count, doubleCount, increment }
    })
    ```
- ==Vue引用useCounterStore.js==
- ==**因为一旦对其结构其属性值就会固定写死,不具备响应性**==
  ```vue
       <script setup>
            import { useCounterStore } from '/stores/useCounterStore.js'
            import { computed } from 'vue'

            const store = useCounterStore()
            // ❌ 这将不起作用，因为它破坏了响应性
            // 这就和直接解构 `props` 一样
            const { name, doubleCount } = store
            // name  将始终是 "Eduardo"
            // doubleCount  将始终是 0
            setTimeout(() => {
            store.increment()
            }, 1000)
            // ✅ 这样写是响应式的
            // 💡 当然你也可以直接使用 `store.doubleCount`
            const doubleValue = computed(() => store.doubleCount)
        </script> 
  ```
  > 具体不能结构,==需要先store(随意起名)获取整个useCounterStore返回的值,然后通过store.xxx去使用里面定义的状态==,注意我们需要响应式的数据是状态,即useCounterStore.js内部使用reactive和ref定义的响应式数据,对于action(函数类型),我们不需要响应式,正常解构使用即可
  > ==在kerwin的elementDeom中center升级战略--个人页面的响应式显示头像和个人资料的时候,就用到了这个知识点==
### 组件外使用pinia
- 单页面应用(==kerwin项目的是第二个路由守卫的示例==)
- ==解释均来自官网==
- 如果你不做任何 SSR(服务器端渲染)，在用 app.use(pinia) 安装 pinia 插件后，对 useStore() 的任何调用都会正常执行：
  ```js
    import { useUserStore } from '@/stores/user'
    import { createPinia } from 'pinia'
    import { createApp } from 'vue'
    import App from './App.vue'

    // ❌  失败，因为它是在创建 pinia 之前被调用的
    const userStore = useUserStore()

    const pinia = createPinia()
    const app = createApp(App)
    app.use(pinia)

    // ✅ 成功，因为 pinia 实例现在激活了
    const userStore = useUserStore()
  ```
  > 为确保 pinia 实例被激活，最简单的方法就是将 useStore() 的调用放在 pinia 安装后才会执行的函数中。
- 让我们来看看这个在 Vue Router 的导航守卫中使用 store 的例子。
  ```js
    import { createRouter } from 'vue-router'
    const router = createRouter({
    // ...
    })

    // ❌ 由于引入顺序的问题，这将失败
    // XXX const store = useStore()
    
    // router.beforeEach((to, from, next) => {
    // 我们想要在这里使用 store
    // if (store.isLoggedIn) next()
    // else next('/login')
    // })

    router.beforeEach((to) => {
    // ✅ 这样做是可行的，因为路由器是在其被安装之后开始导航的，
    // 而此时 Pinia 也已经被安装。
    const store = useStore()

    if (to.meta.requiresAuth && !store.isLoggedIn) return '/login'
    })
  ```
    > 把pinia的使用写在路由导航内即可
### pinia持久化组件
- 和vuex的持久化插件一样,保存一些store信息,防止页面刷新就重置,保存在本地中localStorage
- 如何使用pinia组件(==kerwin的eleDemo路由权限配置==)
- 1.下载(可以从npmjs网站搜文档): `npm i pinia-plugin-persistedstate`
    在main.js配置一下(npmjs官方搜索这个插件的文档用法)
    ```js
      // 只显示插件配置的部分代码 
      import piniaPluginPersistedstate from 'pinia-plugin-persistedstate'

      const pinia = createPinia()
      pinia.use(piniaPluginPersistedstate)

      createApp(App)
      .use(pinia)
      .mount('#app')
    ```
- 2.使用,创建一个store的js文件
  存储用户登录信息,pinia持久化管理,创建新store文件useUserStore.js
  ```js
        // pinia动态路由状态管理
        import { defineStore } from 'pinia'
        import { ref } from 'vue'

        export const useUserStore = defineStore("user",()=>{
            const user = ref({}) 
            function changeUser(value){
                user.value = value
            }
            return {
                user,
                changeUser
            }
        },{
            // 使用持久化插件,对此store进行持久化处理,刷新不重置(存在localStore中)
            persist:true
        })
    ```
- 3.在Login.vue中进行测试,首先设置2个按钮,分别为登录管理员和登录教师功能
    之后changeUser会把信息赋值给useUserStore.js的状态user,然后我们就能从本地存储的useUserStore(key),看到user存储的内容了
   ```
        tem:  Login
        <button @click="handleLogin1">登录管理员</button>
        <button @click="handleLogin2">登录教师</button>

        js:

        import { useUserStore } from '../store/useUserStore';
        // 获取changeUser函数
        const { changeUser } = useUserStore()   

        // 往pinia的useUserStore中传入数据,并把useUserStore使用pinia持久化管理
        const handleLogin1 = () => {
            changeUser({
                "id": 1,
                "username": "admin",
                "password": "123",
                "role": {
                    "roleName": "管理员",
                    "roleType": 1,
                    "rights": [
                        "/index",
                        "/user-manage",
                        "/user-manage/list",
                        "/right-manage",
                        "/right-manage/rolelist",
                        "/right-manage/rightlist",
                        "/tag-manage",
                        "/tag-manage/list",
                        "/interview-manage",
                        "/interview-manage/companylist",
                        "/interview-manage/companydata",
                        "/student-manage",
                        "/student-manage/studentlist",
                        "/student-manage/gradelist"
                    ]
                }
            })
            router.push('/') // 自动跳根路径,之后转到/index
        }

        const handleLogin2 = () => {
            changeUser({
                "id": 2,
                "username": "kerwin",
                "password": "123",
                "role": {
                    "roleName": "讲师",
                    "roleType": 2,
                    "rights": [
                        "/index",
                        "/interview-manage",
                        "/interview-manage/companylist",
                        "/interview-manage/companydata",
                        "/student-manage",
                        "/student-manage/studentlist",
                        "/student-manage/gradelist"
                    ]
                }
            })
            router.push('/')
        }
  ```
  - 效果图:
    [![pAI5Ou8.png](https://s21.ax1x.com/2024/12/02/pAI5Ou8.png)](https://imgse.com/i/pAI5Ou8)

## Vant(移动端)
### Vant的引入
- vue3的vant下载: `npm i vant`,==是一个组件库,内部有许多组件模板==
- ==全局挂载vant的Button组件(**子组件可以直接使用,根据文档,标签为`<v-button>`**)==
- ==**main.js**== (==**注意: 即使后面局部引入vant组件,这个css的样式还是要在全局中统一引入!!!!**==)
  ```
    // 1. 引入你需要的组件
    import { Button } from 'vant';
    // 2. 引入vant组件样式(样式就在全局,不要动了!!!)
    import 'vant/lib/index.css';

    const pinia = createPinia()
    var app = createApp(App)

    app.use(router) // 固定的,注册路由插件
    // app.use(store) // 注册vuex插件 089
    app.use(Button) // 注册vant的Button组件
    app.use(pinia) // 注册pinia
    app.mount('#app')
  ```
  > 步骤: 引入组件Button和组件css样式,最后进行use(XX)注册组件
- ==局部挂载vant + 非语法糖(谁用就在谁哪里引入)==
  - center.vue中
    ```
      <template>
          <div>
              center
              <!-- 102 vant 非语法糖/语法糖改名-->
              <van-button type="primary">主要按钮</van-button>
              <van-button type="success">成功按钮</van-button>
              <van-button type="default">默认按钮</van-button>
              <van-button type="danger">危险按钮</van-button>
              <van-button type="warning">警告按钮</van-button>
          </div>
      </template>

      js:非语法糖
      import { Button } from 'vant'; // 局部引入组件
      export default {
          // 组件注册
          components:{
              // 组件名注册,例如:
              // "mybutton" : Button  那就是<mybutton>...</mybutton>
              // 在ES6中[]内部才是js区域,这样才能当作变量使用它 [XX(js)]: XX
              [Button.name]: Button, // Button.name = van-button,方便使用组件,命名一一对应好了
          }
      }
    ```
    > 步骤: 引入组件,在components中注册即可
- ==局部挂载vant + 语法糖==
  - ==**setup写法只需要导入无需注册,但是我们可以看下setup封装是如何给我们注册的**==
    ```
      js: setup语法糖,仅引入组件这一段代码
          import { Button } from 'vant';

      ---------对语法糖拆解如下------------------
      js:
      // 它会这样子给你引入并注册
      <script> 
          import { Button } from 'vant';
          export default{
              components:{
                  Button: Button // 同名注册的
              }
          }
      </script>
    ```
    > ==上面详细解释了**setup的语法糖注册策略是同名注册**,也就是说使用Button组件,**我们需要把标签`<van-button>`改为`<Button>`才能正常使用**==
  - ==vant 语法糖 + ES6改名{A as B},**即对引入的名字进行重命名操作,带-的用驼峰**==
    ```
      tem:
      <template>
          <div>
              center
              <!-- 102 vant 语法糖 + ES6改名-->
              <van-button type="primary">主要按钮</van-button>
              <van-button type="success">成功按钮</van-button>
              <van-button type="default">默认按钮</van-button>
              <van-button type="danger">危险按钮</van-button>
              <van-button type="warning">警告按钮</van-button>
          </div>
      </template>

      js:
        <!-- 102 vant setup语法糖区域 -->
        <script setup>
            // 用ES6给引入的组件名进行重命名,带-的用驼峰
            import { Button as vanButton } from 'vant';
        </script>
    ```
    > 步骤: 引入组件并改名,改为传统标签名

### vant-swiper(轮播图)
- 简单的完成Films.vue组件的大轮播图,==直接借用vant-swiper组件(**学会看文档,不过vant的文档有地方可能有些偏差**)==
- 代码:
  ```
    tem:
        <!-- 104 大轮播,由vant-swiper组件完成 -->
        <van-swipe class="my-swipe" :autoplay="3000" indicator-color="white">
            <van-swipe-item v-for="data in loopList" :key="data.id">
                <img :src="data.imgUrl" alt="" style="width:100%; height:300px ;">
            </van-swipe-item>
        </van-swipe>
    
    js: setup语法糖
        import { Swipe as vanSwipe, SwipeItem as vanSwipeItem } from 'vant';
        import { ref } from 'vue';

        const loopList = ref([
            {
                "id" : 1,
                "imgUrl":"https://pic.maizuo.com/usr/movie/02e5b8507b28a6417eb2712643f3b246.jpg",
                "title" : "毒液：最后一舞"
            },
            {
                "id" : 2,
                "imgUrl":"https://pic.maizuo.com/usr/movie/f361418dccb983e2fc29dff53f74a69c.jpg",
                "title" : "焚城"
            },
            {
                "id" : 3,
                "imgUrl":"https://pic.maizuo.com/usr/movie/0c11bf47ea6f4aa021a49d82df2acbcf.jpg",
                "title" : "哈利·波特与火焰杯"
            },
            {
                "id" : 4,
                "imgUrl":"https://pic.maizuo.com/usr/movie/30d87e276c59d8fe9b73ef7a57035bc0.jpg",
                "title" : "乔妍的心事"
            },

        ])
  ```
    > 直接利用组件,插入相关图片,完成最简单的循环轮播图
### vant-list(.deep())
- 下拉列表的组件实现的效果就是瀑布流通讯录,刷新电影数据,拉到底部后再次网络请求加长列表,直到刷完
- ==**文档说明(重点,认识组件的功能)**==: List 组件通过loading和finished两个变量控制加载状态，当组件滚动到底部时，会触发 load 事件并将 loading 设置成 true,此时可以发起异步操作并更新数据，数据更新完毕后，将 loading 设置成 false 即可。若数据已全部加载完毕，则直接将 finished 设置成 true 即可。
- 代码:
  ```
    tem: 
        <van-list v-model:loading="loading" :finished="finished" finished-text="没有更多了" @load="onLoad"
            :immediate-check="false" offset="10">
            <van-cell v-for="item in datalist" :key="item.filmId" @click="handleClick(item.filmId)">
                <img :src="item.poster" alt="" style="width: 100px; float: left;">
                <div>{{ item.name }} 页数: {{pageNum}}</div>
            </van-cell>
        </van-list>

    js: setup
    // 105 文档引入的组件少了一个Cell,记得重命名
    import { List as vanList, Cell as vanCell } from 'vant';
    const loading = ref(false)
    const finished = ref(false)

    // 检测是否到达底部的函数
    const onLoad = async () => {
        console.log("到底了")
    }

    // 重点在style的样式更改
    <style lang="scss" scoped>
        :deep(.van-cell__value) {
            text-align: left;
        }
    </style>
  ```
- **==重点:在组件作者未预留"接口"(通过往组件传递信息进而控制组件的实现效果)的情况下,控制组件的css样式==**
- 问题: 我们想要让电影的名字在页面的左边,而组件的内部设置是在右边,如图
- ==现实中的效果==: 
  [![pAyPCgP.png](https://s21.ax1x.com/2024/11/06/pAyPCgP.png)](https://imgse.com/i/pAyPCgP)
- ==理想中的效果==:
  [![pAyPPjf.png](https://s21.ax1x.com/2024/11/06/pAyPPjf.png)](https://imgse.com/i/pAyPPjf)
- 首先我们发现组件并没有设置文字左右样式的选项,==通过**检查工具**,发现在**class为van-cell__value的div的style属性中的text-align为right**,我们需要给它改为left==
- 如图:
  [![pAyP93t.png](https://s21.ax1x.com/2024/11/06/pAyP93t.png)](https://imgse.com/i/pAyP93t)
  [![pAyCxNd.png](https://s21.ax1x.com/2024/11/06/pAyCxNd.png)](https://imgse.com/i/pAyCxNd)
> ==上面的代码是v-cell组件展开后的效果==
- ==**直接进行样式style的覆盖行不通,因为scoped的原因,所有html标签会加一个自定义属性(图中的data-v-XXX)**==,只有这样组件才能有自己单独的css样式,并且不会影响别的组件.
- 我们使用别人的组件,==只有根组件(<v-cell>...<\v-cell>>)会打上和我们组件一样的标识(scpoed给的),**根组件内部的孩子是没有标识的,但是van-cell__value(div)正是其内部的孩子,他是没有标识的**==
- ==这样造成的问题是style/css是带标识的标识(scoped),而相关的div-class=van-cell__value却不带标识,导致双方class名对应不上无法添加css样式==
- [![pAyCz4A.png](https://s21.ax1x.com/2024/11/06/pAyCz4A.png)](https://imgse.com/i/pAyCz4A)
> ==你看这样的css样式是带有data-v-XX,而div标签van-cell__value没有这个自定义属性,所以css添加了个寂寞==
- 我们可以删除scoped属性,但是那样不安全,会对全局影响;而且由于组件不是我们写的,所以我们无法进入组件源码去修改css样式
- ==**解决(重点):**== ==**vue给我们提供了一个:deep()的方法**==,scoped添加的标识是在html标签上加一个自定义属性,这个属性自带一串不重复的数字和字母组合,以防止失误给别的标签加上css样式,==deep的操作是在style中,使用css的属性选择器:"[data-v-XXXX] .van-cell__value"去锁定相关标签,即先找带标识(自定义属性)的父标签,然后再找到其后代中有class为van-cell__value的html标签添加css样式==
- 这样子css的样式变为这样:
  [![pAyPp9I.png](https://s21.ax1x.com/2024/11/06/pAyPp9I.png)](https://imgse.com/i/pAyPp9I)
> 这里面有个css知识(属性选择器),相关知识在css笔记由,如果忘记了回去看看 
- ==**拓展(重点)**==:".a :deep(.b){...} ---> .a[data-v-XXX] .b",==限制了自定义属性的标签类型==,比如a为span标签,即有".span[data-v-XXX] .b",意为只在span标签中找带有自定义属性data-v-XXX的合规标签,你即使有div带相同的data-v-xxx也不在筛选范围内
### vant-list 下拉懒加载
- ==**由于卖座网站更新了,所以无法实时更新请求数据,原来能用的时候是通过传递url中改变pageNum的信息去请求新页面的数据**==
- ==所以这里重构了代码(伪代码),运行不了,和原Nowplaying.vue文件的代码不同,先用伪代码去介绍思路==
- Nowplaying.vue
    ```
        tem:
            <div>
            <!-- van-cell -->
            <!-- 禁用初始化时立即进行滚动位置检查,还没有数据初始化就检测会导致组件认为数据已经滚动完了(执行Load函数),不过不代表这个没用,有别的请求数据逻辑可能也需要这个属性 -->
            <!-- 调试下offset(看文档):滚动条与底部距离小于 offset 时触发 load 事件 , 尽量别设置为0,容易出bug -->
            <van-list v-model:loading="loading" :finished="finished" finished-text="没有更多了" @load="onLoad"
                :immediate-check="false" offset="10">
                <van-cell v-for="item in datalist" :key="item.filmId" @click="handleClick(item.filmId)">
                    <img :src="item.poster" alt="" style="width: 100px; float: left;">
                    <div>{{ item.name }} 页数: {{pageNum}}</div>
                </van-cell>
            </van-list>
        </div>
    ```
  > ==为了使下拉列表更完美的显示,我们按照文档给van-cell的组件添加了写属性指导,看看注释==
- ==js setup区==
    ```
        import { List as vanList, Cell as vanCell } from 'vant';
        const loading = ref(false)
        const finished = ref(false)
        const pageNum = ref(1) // 页数
        const total = ref(0) // 数据个数

        const onLoad = async () => {
        console.log("到底了")

        // 判断数据是否被请求完毕(先跳过,往后看)
        if(datalist.value.length === total.value){
            finished.value = true // 结束请求,之后不再执行Load函数了
            return // 跳出Load函数
        }

        pageNum.value ++ // 页数更新,请求新的一页的数据
        // 像后端发送网络请求,利用模板字符串和${},把变量pageNum动态添加到地址内部,每次给后端的pageNum值都不一样,请求不同页的数据
        let res = await axios(`https://m.maizuo.com/gateway?cityId=110100&${pageNum.value}&pageSize=10&type=1&k=8063337`)
        // 记住,一定是追加数据,而非覆盖,这里用展开运算符,把数组拆开合并,和当时的对象合并一样
        datalist.value = [...datalist.value,...res.data.data.films]
        // 记得组件的注意事项: 每次请求完新的数据后要把loading重新设置为false(触发load事件会自动把loading设置成true),否则下次无法请求数据了
        loading.value = false

        // 假如后端会给你total属性,代表总数据个数,而数组长度代表现如今的数据个数
        // 需要在axios前进行一个if逻辑判断了,如果现有数据列表datalist和total总数一样了,即证明数据已经被请求完了,跳出Load函数并对finished设置为true
        total.value = res.data.data.total // 获取后端的total值

    }
    ```

### indexBar组件1--Navbar
- 本节课分两步完成"列表的索引分类显示和快速定位",indexBar是vant的组件专门负责列表的索引,我们使用这个组件逐步完善功能,==**第一节用的是Navbar组件和电影院的数据处理两部分,还没到indexBar组件的部分**==
- Navbar组件使用后的效果图:(==看顶部导航栏,经典左中右布局==)
  [![pAy1QYt.png](https://s21.ax1x.com/2024/11/07/pAy1QYt.png)](https://imgse.com/i/pAy1QYt)
- ==**惊天失误: 卖座的数据是可以请求的,之前写错了,其实是地址小写的x变为大写的X即可**==
- 组件的引入和使用(看看文档)==cinema.vue==
  ```
    tem:
    <!-- 107 Navbar组件 -->
    <van-nav-bar title="影院">
        <template #left>
            <!-- 额外加一个向下指示标 -->
           <div @click="handleCity">{{cityStore.cityName}}<van-icon name="arrow-down" color="black"/></div>
        </template>
        <template #right>
            <!-- 关于icon的属性设置可参考文档,这里修改了颜色 -->
            <van-icon name="search" size="18" color="black"/>
        </template>
    </van-nav-bar>

    js: setup
    import { NavBar as vanNavBar, Icon as vanIcon } from 'vant';

  ```
  - 首先文档有漏洞: 文档又少引入了van-icon的组件,用于显示右侧的搜索标志(==看报错警告也能发现!!!!==)
  - 使用了Navbar组件,在vant网站正好和indexBar挨着,==其中我们使用了"左 中 右"导航经典布局==,其中对左布局又加了个小图标组件(Icon),其余的组件改变了颜色,均来自文档的指导进行简单修改
  > ==稍微介绍Navbar组件的代码==: 最外面的`van-nav-bar`的title是导航中间的文字,内部tem#left和#right是导航左右两边的东西,左边是显示城市的,其中`{{cityStore.cityName}}`先别管,那是城市的动态显示,外加icon小图标组件和一个点击事件,右侧就是搜索的组件样式,没有深入添加功能
- **==第二步: 我们实现点击导航左部分城市,进入城市页面,这就是索引indexBar的领域了,不过首先要解决的是我们还没有写城市页面的路由组件,所以我们在views文件夹创建city.vue路由组件==**
- 先完成cinema.vue组件的跳转功能:
  ```
    tem: 
    // 我们在导航左边(#left)添加了点击事件@click="handleCity",摘录代码如下:
    <template #left>
            <!-- 额外加一个向下指示标 -->
           <div @click="handleCity">{{cityStore.cityName}}<van-icon name="arrow-down" color="black"/></div>
    </template>

    js:
    // 需要复习路由的相关知识
    import {useRouter} from 'vue-router'
    
    const router = useRouter() 
    const handleCity = ()=>{ 
        router.push('/city') // 跳到city.vue页面
    }
  ```
  > 这个点击事件作用就是帮助我们跳转到city.vue页面
- ==在制作city.vue之前,莫要忘记router需要注册==,你的'/city'地址是需要注册的,==回到router文件夹的index.js中==
  ```
    const routes = [
        .....
        {
            // 107 注册City路由组件
            path:'/city',
            name:'City',
            component: City
        },
        .....
    ]
  ```
- ==制作city.vue(在views文件夹内)==
- ==本节内容先讲解处理电影数据的问题,**在这里也出了重大失误,猫眼的数据是可以请求的**==
    ```
    js: setup
    import axios from 'axios'
    import { onMounted, ref } from 'vue';

    const datalist = ref([])

    onMounted(async () => {
        let res = await axios({
            url: "https://m.maizuo.com/gateway?k=8499442",
            headers: { // x大写
                "X-client-info": '{"a":"3000","ch":"1002","v":"5.2.1","e":"1700392515260648680292353","bc":"110100"}',
                "X-host": 'mall.film-ticket.city.list'
            }
        })
        // console.log(res.data.data.cities)
        // 将筛选后的数据赋值给状态datalist
        datalist.value = filterCity(res.data.data.cities)
    })
    ```
    > 初步的请求数据后,对数据进行整理筛选,==首先数据是300多个乱序城市名数组,我们要把数据按A B C ... Z的26英文字母分类,每个字母对应的list数组内部是城市集合,依据拼音分类,例如"北京"在B栏==
- ==筛选前的数据:==
    [![pAy3Ehq.png](https://s21.ax1x.com/2024/11/07/pAy3Ehq.png)](https://imgse.com/i/pAy3Ehq)
- ==筛选后的数据:==
    [![pAy3njU.png](https://s21.ax1x.com/2024/11/07/pAy3njU.png)](https://imgse.com/i/pAy3njU)
- ==方法1:纯js筛选==(filterCity函数)
  ```
    const filterCity = (cities) =>{
        var letterArr = []
        // ASCII码 A(65)-Z(90)
        for(let i=65;i<91;i++){
            // js的知识 String.fromCharCode() ASCII-->字符
            letterArr.push(String.fromCharCode(i))
        }
        // console.log(letterArr)
        // 单个过滤测试 例子A
        // console.log(cities.filter(item=>item.pinyin.substring(0,1).toUpperCase()==='A'))

        // 分类并放入数组,数组是对象数组,每个字母对应一个对象,type为首字母,list内放所有的数据
        let newCities = []
        for(let i=0; i<letterArr.length;i++){
            newCities.push({
                type: letterArr[i],
                list: cities.filter(item=>item.pinyin.substring(0,1).toUpperCase()=== letterArr[i])
            })
        }
        // 过滤数据,有的首字母没有一个城市匹配,list长度为0的都会被过滤出去
        newCities = newCities.filter(item => item.list.length)
        // console.log(newCities)
        // 把数据返回出去
        return newCities 
    }
  ```
  - 第一步: 26个英文字母的数组,我们使用的是ASCII转字母,最后for循环把它放入letterArr数组
  - 第二步: 筛选并重构数组,创建新数组newCities空数组,再用for循环,往newCities内部push对象,每个对象是type和list两个属性,type是首字母A B C...Z,list是根据拼音筛选对应的城市,其中做法是"截取第一个拼音字母" + "大写" = letterArr[i] (A~Z)
  - 第三步: 过滤无效数据,比如O开头的城市一个都没有,所以对应的list为空,所以我们在请求数据的时候应该提前过滤那些没用的数据,使用filter即可,这样最后显示的数组中就没有O这一项了
  - 第四步: 返回数据,这是个函数,内部的数据是局部的,需要外部状态承接结果数据
> 
- ==方法2: lodash js库==(filterCity函数)
  ```
    // 引入lodash
    import _ from 'lodash'

    const filterCity = (cities) => {
        // 把cities的数据整理顺序
        // sort排序,正序item1-item2,倒序item2-item1,item1和2是ASCII码,需要charCodeAt()把字符传为ASCII码
        cities.sort((item1, item2) => {
            return item1.pinyin.substring(0, 1).toUpperCase().charCodeAt() - item2.pinyin.substring(0, 1).toUpperCase().charCodeAt()
        })
        // 分组 库--lodash,js升级版,内部有许多方法
        // 这里用的groupBy, 需要下载 npm i --save lodash
        // 第一个参数是数据,第二个参数是按照什么分类(箭头函数),返回值是一个全新的数组
        let groupObj = _.groupBy(cities, item => item.pinyin.substring(0, 1).toUpperCase())
        // 筛选后的数组是对象数组,每个item内部结构也是对象,为 '首字母(key): [{...},{...},{...}](城市/value)'
        // 分组会自动筛去空数据城市数据
        // console.log(groupObj)
        // Object.keys() 取对象的所有key
        // i的值顺序与初始数据有很大关系,我们对初始数据进行首字母排序
        let newCities = []
        for (let i in groupObj) {
            // console.log(i)
            newCities.push({
                type: i, // key
                list: groupObj[i] // value
            })
        }
        console.log(newCities)
        // 把数据返回出去
        return newCities
    }
  ```
  - 第一步: 下载并引入lodash库
  - 第二步: 首先对所有的数据进行排序(简单按照A-Z排序),这是因为lodash库的方法的小问题,如果没有排序,最后呈现的效果字母顺序会有点乱,使用js原生方法sort对300条城市数据的首字母进行排序,回忆sort的知识,按照ASCII排序,正序排列,看注释即可
  - 第三步: 使用lodash库的_.groupBy工具(==看文档学用法==),第一参数写数据,第二参数写排序规则(回调函数)**==其实看文档没看懂,真正内核没会==**
  - 第四步: lodash库的_.groupBy工具已经帮你排好了数据,但是真正的样式与我们所需要的不同,如下
    [![pAyY7o4.png](https://s21.ax1x.com/2024/11/07/pAyY7o4.png)](https://imgse.com/i/pAyY7o4)
  - 第五步: 创建newCities空数组,把groupObj每一项的key和其对应的value放入type和list中,提取的key的语法(for a in Obj),最后效果还是一样的,==而且这个方法会自动过滤点list为0的无效数据==
  - 第六步: 返回数据
  > 本节笔记总结:
  > 1.介绍了业务逻辑和效果图片,然后使用Navbar(vant)组件,整改后,梳理跳转逻辑,进而发现需要创建新的路由视图City.vue
  > 2.对路由Router进行注册,然后创建City.vue,并请求网络数据,重点是处理了卖座的后台数据,还没真正使用indexBar组件
### indexBar组件2
- 进一步完善city.vue的页面,上一节课我们已经获取并整理好了卖座的电影后台数据,接下来正式进入indexBar组件的使用,利用获取的卖座数据和组件渲染出一个城市通讯录
- ==indexBar样板如下图:==
  [![pAy1MFI.png](https://s21.ax1x.com/2024/11/07/pAy1MFI.png)](https://imgse.com/i/pAy1MFI)
> 
- ==经过数据渲染之后:==
  [![pAy1uTA.png](https://s21.ax1x.com/2024/11/07/pAy1uTA.png)](https://imgse.com/i/pAy1uTA)
- City.vue代码
  ```
    tem:
    <div>
        <!-- 由计算属性去完成索引标indexList的更新 -->
        <van-index-bar :index-list="indexList">
            <div v-for="item in datalist" :key="item.type">
                <van-index-anchor :index="item.type" />
                <!-- 小重点: 双v-for嵌套,和"for i {for j}",里面的遍历data和外面的item不能重名 -->
                <!-- item外层负责: 首字母type的遍历; data内层负责: 对这个字母list的进行遍历 -->
                <van-cell :title="data.name" v-for="data in item.list" :key="data.cityId" @click="handleChange(data)" />
            </div>
        </van-index-bar>
    </div>

    js:
    // 引入indexBar相关组件,文档有少了van-cell
    import { IndexBar as vanIndexBar, IndexAnchor as vanIndexAnchor, Cell as vanCell } from 'vant';
    // 计算属性,筛选首字母,这个组件不够智能,需要你自己把对应的索引传给组件(组件会死板地把26英文字母放在侧边栏)
    const indexList = computed(() => datalist.value.map(item => item.type)) // 获取筛选后的所有字母索引
  ```
  > 代码解析: 引入了三个组件
  > 第一个van-index-bar负责通讯录最右侧一列的英文字母,点击可以跳转到对应的位置,相当于通讯录的"目录";
  > 第二个组件van-index-anchor负责A B C .. Z的索引,主要是获取索引的名字,这里写的是26个大写英文字母;
  > 第三个组件van-cell负责每个通讯录内的城市名字,比如A内有什么内容
  > ==以上的代码已经动态处理过了,vant的网站有写死的代码介绍,可以更直观的了解到每个组件具体干什么==

- ==**1.小重点: vue双v-for循环**==:
    其实和我们学习C语言的双循环一样,嵌套的,一个负责外层,一个负责内层,这里负责外层的v-for是div,获取的是datalist的单项数据item,单个的item结构为
    ```
    item:
        {
            type: ...
            list: [...]
        }
    ```
    ==使用这个外层循环的是van-index-anchor组件==,它负责索引的动态绑定,根据文档,对参数index动态绑定item的type,即为`:index="item.type"`
    ==使用内层循环的是van-cell==,它负责每个分类的城市渲染,所以它的v-for落脚点是item的list数据,它要遍历list内的每一个数据,渲染当前分类的所有城市,既有`v-for="data in item.list"`,并动态绑定城市的名字`:title="data.name`
    ==外层的item和内层data就相当于C语言的i和j,所以不要重名==
    ```
        for(int i=xxx ){
            for(int j=xxx ){
                .....
            }
        }

    ``` 
- 2.==索引van-index-bar动态绑定indexList计算属性==
   筛选首字母,这个组件不够智能,组件会死板地把26英文字母放在侧边栏,所以需要你自己把删减后的新索引传给组件(之前请求数据的时候我们已经过滤了例如O开头这种无效数据了,所以索引已经少于26个字母了,如果没有给组件传递新索引值,会导致组件默认26个字母索引,而你提供给组件的数据分类却少于26个,会出bug的,具体体现在目录与内容出现偏差)
>    
- ==**接下来下处理新功能:点击对应城市后我们跳转回cinema页面**==
    - 左上角的城市变为我们所选择的城市
    - 显示的电影院也是这个选择城市的电影院,相当于动态请求了我们所点击城市的city数据
- ==**第一步**==: 在city页面记录点击的city名字和id,并传入新piniaStore文件cityStore,==这个cityStore.js专门负责处理city路由组件的相关数据==
- store文件夹内创建cityStore.js文件,代码如下
  ```
    import { defineStore } from 'pinia'
    import {ref} from 'vue'

    const useCityStore = defineStore("city", () => {
        // ref包装 = state
        const cityName = ref("北京")
        const cityId = ref(110100)
        // 函数 = Action
        // change会传入新的城市名name和城市的id
        const change = (name,id)=>{
            cityName.value = name
            cityId.value = id
            // console.log( cityName.value, cityId.value )
        }

        return{ 
            cityName, 
            cityId,
            change
        }
    })

    // 记得导出
    export default useCityStore
  ```
  > 这个store有个change函数,会接受传递过来的2个形参,代表城市的名字和id,并把这个形参的值存储到状态中保存起来,==日后必有大用==
- 所以承接上面,在city.vue中,对每个城市设置点击事件,引入cityStore,每次点击后,给这个store的change函数传递当前点击城市cityName和cityId
  ```
    tem:
        // 我们传进去的形参data,是来自item.list的数据,就是看看上面的双v-for循环小重点,这个data正是list中每个城市的详细数据(其中就有cityName和cityId这两个关键信息)
        <van-cell :title="data.name" v-for="data in item.list" :key="data.cityId" @click="handleChange(data)" />

    js:
        // store相关知识:
        // 引入city组件
        import useCityStore from '../store/cityStore';
        // 使用city组件
        const store = useCityStore()

        // 把获取的形参解构了
        const handleChange = ({name,cityId})=>{
            // console.log(name,cityId)
            // 调用store,向内部的change函数传入name和cityId数据
            store.change(name,cityId)
            // 返回城市筛选页面
            router.go(-1)
        }
  ```
  > 通过事件传参,我们的cityStore.js获取了当前点击城市的名字和id,接下来城市名字用来更改cinema.vue页面左上角的城市名,id用于CinemaStore.js请求网络数据是传递城市的参数
  > 看代码: 点击完后先向cityStore.js传递形参,在回退到cinema页面`router.go(-1)`
- ==CinemaStore.js(内部的网络请求我已经改为axios向卖座后端请求的格式了)==
  ```
    // 新知识: pinia: 在一个store中引入另一个store的数据
    import useCityStore from './cityStore'
    // 直接调用,直接创建,直接使用,十分简单
    const cityStore = useCityStore()

    // 请求cinema.vue页面的电影院后端数据 
    const getCinemaList = async()=>{
        // 107 来报: 正式使用卖座可以请求数据
        let res = await axios({
            // 网络请求是携带对应的cityId数据, ES6`` + ${}
            url: `https://m.maizuo.com/gateway?cityId=${cityStore.cityId}&ticketFlag=1&k=8814`,
            headers:{ // 大写X
                "X-client-info": '{"a":"3000","ch":"1002","v":"5.2.1","e":"1700392515260648680292353","bc":"110100"}',
                "X-host": 'mall.film-ticket.cinema.list'
            }
        })
        cinemaList.value = res.data.data.cinemas
    }
  ```
  - ==新知识: 在pinia中从一个store中引入另一个store的数据==
  - ==直接调用,直接创建,直接使用,十分简单(**看代码**)==
  - ==cityId的用处==: 我们从CinemaStore.js中获取了来自cityStore.js的cityId数据,==**这个cityId会作为请求链接的参数发送网络请求,认真看axios的url代码**,ES6模板字符串\`\`和\${}的组合,**动态地把每一次的cityId放入url,从而实现动态地请求不同城市的电影院后端数据**==
- cinema.vue(最后完善电影页面)
  ```
    tem:
        <template #left>
           <div @click="handleCity">{{cityStore.cityName}}<van-icon name="arrow-down" color="black"/></div>
        </template>

    js:
        // 引入cityStore
        import useCityStore from '../store/cityStore';
        // 使用cityStore内部数据
        const cityStore = useCityStore()
  ```
  > 完善了左上角的城市名字,动态化了
- 最后一个问题,之前我们为了实现数据缓存(即从别的页面切到电影页面不会重复进行网络请求,而是把数据缓存到本地,这样减少了服务器的压力)
- ==问题:== 看看处理缓存问题的源码
  ```
    js:
        onMounted(() => {
            if (store.cinemaList.length === 0) {
                // 请求数据,带着影院数据 cityId请求对应城市的数据
                store.getCinemaList() // 直接调用CinemaStore.js的action方法
            } else {
                console.log("缓存")
            }
        })
  ```
- 源码意思是,只有store.cinemaList数据为空时,才会执行CinemaStore.js中的getCinemaList函数(==这是我们请求电影院数据的函数,也是动态改变电影院数据的关键==),所以如果不做任何更改,那么在初始化时,我们自动请求数据,比如北京的电影数据后,如果不清除缓存,就无法执行store.getCinemaList()请求新的电影数据,但是如果删除缓存判断,又会造成服务器压力大
- ==解决:== 只有从city页面回到cinema页面会清除缓存(cinemaList数组清空),从其他页面,比如 电影(Film.vue),我的(Center.vue) 页面跳转到cinema页面不会清空缓存,==那么我们需要在跳去city页面后清空cinema页面的缓存,如下==
- cinema.vue
  ```
    const handleCity = ()=>{
        router.push('/city') // 跳到city.vue页面
        // 清空缓存,一会从city页面回来时,又可以请求新的数据了
        store.clearCinemaList() // store指的是CinemaStore.js
    }
  ```
- CinemaStore.js(==clearCinemaList()函数==)
  ```
    // 清缓存函数
    const clearCinemaList = ()=>{
        cinemaList.value = []
    }
  ```
  > 清空cinemaList数组后,再回到cinema页面,在执行if()缓存逻辑判断时,就可以请求新的数据了

- **==至此所有的内容完毕,下面是总结!!!==**
- 1.cinema的Navbar组件样式和动态化显示(来自cityStore.js的相关数据)
- 2.city.vue的创建(选择城市的页面),使用了indexBar组件,请求所有城市的数据后,对城市数据进行了分类整合,有纯js方法和lodash库两个方法,随后使用indexBar组件结合我们筛选分类后的数据进行页面渲染(tem有个双v-for循环)
- 3.在city页面选择城市时记录城市的数据(name和id),这又创建了cityStore,处理记录城市的相关数据,供别的组件和store使用
- 4.更新axios请求数据时,新知识,pinia的store之间的引用,CinemaStore.js引入了cityStore.js的相关数据,用于动态请求新的电影数据,发送新的城市数据请求,一会回退到cinema页面时,能动态化显示新城市的电影院数据
- 5.处理了cinema页面跳转的缓存问题,添加了由cinema页面跳到city页面时清空缓存的操作

## elementPlus组件库(PC端)
- 安装elementPlus组件: `npm install element-plus --save` (==多看文档学习ele的更多用法==)
- 简单的使用ele组件,首先全局注册,引入所有组件(main.js)
- 效果是: 这样子在所有的组件中都可以直接使用ele组件
- ==main.js==
  ```
    // 6-elementPlus
    import { createApp } from 'vue'
    import './style.css'

    // 全局引入ele,所有组件随意使用ele组件,直接用
    import ElementPlus from 'element-plus'
    import 'element-plus/dist/index.css'
    import App from './6-elementPlus/App.vue'
    import router from './6-elementPlus/router'
    import { createPinia } from 'pinia'

    const pinia = createPinia()

    var app = createApp(App)
    app.use(router) // 固定的,注册路由插件
    app.use(pinia) // 注册pinia
    app.use(ElementPlus) // 全局注册ele
    app.mount('#app')
  ```
- 我们修改了6-elementPlus的结构,除了留下views的Notfound路由组件,其余全删除,并添加Home,NewList,AddList三个新的路由组件,删除vant,store等文件夹和内容,删除components的Tabbar组件,删除router内部index.js对于前路由组件的注册,并注册新的三个路由组件,把Home页面设置为默认页面
- ==Home.vue==
  ```
    <template>
        <div>
            home
            <!-- 全局注册ele,所以直接使用ele组件即可 -->
            <el-button>Default</el-button>
            <el-button type="primary">Primary</el-button>
            <el-button type="success">Success</el-button>
            <el-button type="info">Info</el-button>
            <el-button type="warning">Warning</el-button>
            <el-button type="danger">Danger</el-button>
        </div>
    </template>
  ```
### elementPlus基础组件
- 做一个新闻后台管理系统,首先在container布局容器里挑选一个喜欢的样式,然后进行适当删减,重新构建内部数据,同时看不懂的组件可以查询文档说明,如下
  ```
    <template>
        <!-- 根组件,我们设置占全屏高度 100vh -->
        <el-container class="layout-container-demo" style="height: 100vh">
            <!-- 测边栏 -->
            <el-aside width="200px">
                <!-- 侧边滚动 -->
                <el-scrollbar>
                    <!-- 遇到猜不到的标签,去官网ctrl+f搜索menu组件的说明 -->
                    <!-- Menu Attributes的router说明: 启用该模式会在激活导航时以index作为path进行路由跳转  -->
                    <!-- default-active: 页面加载时默认激活菜单的 index -->
                    <el-menu :router="true" :default-active="route.fullPath">
                        <!-- index string 唯一标识,建议弄成路由地址,方便跳转(一鱼两吃,即唯一标识,也提供路径) -->
                        <el-menu-item index="/home">
                            <el-icon>
                                <!-- 小图标,在ele中图标组件不会被引入,所以记得按需引入,在script内部 -->
                                <HomeFilled />
                            </el-icon>
                            <span>首页</span>
                        </el-menu-item>
                        <!-- 展开菜单 el-sub-menu -->
                        <el-sub-menu index="/news">
                            <template #title>
                                <el-icon>
                                    <message />
                                </el-icon>新闻管理
                            </template>
                            <!-- 展开内容 el-menu-item -->
                            <!-- 下拉菜单命名尽量体现出二级/父子的关系 -->
                            <el-menu-item index="/news/addnews">创建新闻</el-menu-item>
                            <el-menu-item index="/news/newlist">新闻列表</el-menu-item>
                        </el-sub-menu>

                    </el-menu>
                </el-scrollbar>
            </el-aside>

            <el-container>
                <!-- 顶栏 -->
                <el-header>
                    <div>新闻管理系统</div>
                    <div>欢迎回来</div>
                </el-header>
                <!-- 主要内容区 -->
                <el-main>
                    <el-scrollbar>
                        <!-- 显示自己的路由 -->
                        <router-view></router-view>
                    </el-scrollbar>
                </el-main>
            </el-container>
        </el-container>

    </template>

    <script setup>
        import { Menu as IconMenu, Message, Setting, HomeFilled } from '@element-plus/icons-vue'
        import { useRoute } from 'vue-router'

        const route = useRoute() // 获取当前路由的信息,其中路径信息存在fullPath里面
        console.log(route) // 直接打印route.fullPath是没有的,因为js立即执行,所以还没匹配上就打印了,即'/'

    </script>

    <style>
        /* App全局影响,取消默认样式 */
        * {
            margin: 0;
            padding: 0;
        }
        .el-header{
            background-color: aqua;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 20px;
        }
    </style>

  ```
- ==下面的都可以根据文档查询学习,这里说明是为了更好的复习==
  - ==简单介绍布局:== 
    - el-container 根组件
    - el-aside 侧边栏(左侧)
    - el-container 主要内容区(右侧) 内含el-header(顶栏)和el-main(内容区)
  - ==简单组件介绍==
    - el-scrollbar 滚动条
    - el-menu 菜单
    - el-menu-item 普通菜单
    - el-sub-menu 下拉菜单,内部可以放普通菜单,结合`<template #title></template>`使用
    - el-icon 图标使用组件,内含图标组件,例如`<HomeFilled />`(==图标组件需要引入,import {HomeFilled} from '@element-plus/icons-vue'==)
- **==重点:==**
- 菜单部分:
  - el-menu内部的所有菜单都有index属性(String),在文档中说明这是唯一标识符,==建议弄成路由地址,方便跳转(一鱼两吃,即唯一标识,也提供路径)==
  - ==el-menu的属性router: 文档Menu Attributes的router说明: **启用该模式会在激活导航时以index作为path进行路由跳转**==
  - ==default-active: 页面加载时**默认激活菜单**的 index,即index是什么就调到哪里去==
  - ==index命名潜规则==: 涉及二级菜单的,父子关系的,尽量渐进式的命名,如代码上面的news下的/news/addnew和/news/newlist(**记得router的index注册表跟着改了**)
  - 如何获取当前点击位置的路由地址: 旧知识 useRoute
    ```
        js: setup
        import { useRoute } from 'vue-router'

        const route = useRoute() // 获取当前路由的信息,其中路径信息存在fullPath里面
        console.log(route) // 直接打印route.fullPath是没有的,因为js立即执行,所以还没匹配上(速度慢)就打印了,即'/'
        // 把route.fullPath动态绑定给default-active即可
    ```
    > 这样即使刷新也不会影响到侧边栏,它不会重置
  - 自己的内容显示在哪? 侧边栏是el-side,咱们自己的路由组件要显示子在el-container的el-main内部,==**记得给上路由插槽位置`<router-view></router-view>`**==
> 
- ==改style样式:== 直接改,人家为了让你方便改样式,直接把class名字和组件名字同步了
> 
- ==轮播图(在文档中叫走马灯)和24栏: Home.vue内部==
  ```
    <template>
        <el-carousel :interval="4000" type="card" height="200px">
            <el-carousel-item v-for="item in 6" :key="item">
                <h3 text="2xl" justify="center">{{ item }}</h3>
            </el-carousel-item>
        </el-carousel>

        <!-- 24栏 layout布局 -->
        <el-row>
            <!-- 注意:没有响应式布局,当宽度小于一定程度时内部内容会溢出 -->
            <!-- 一人8分,即3/1 -->
            <el-col :span="8">
                <div>个人介绍</div>
            </el-col>
            <el-col :span="8">
                <div>公司介绍</div>
            </el-col>
            <el-col :span="8">
                <div>公司产品</div>
            </el-col>
        </el-row>
    </template>

    <style scoped>
        .el-carousel__item h3 {
            color: #475669;
            opacity: 0.75;
            line-height: 200px;
            margin: 0;
            text-align: center;
        }

        .el-carousel__item:nth-child(2n) {
            background-color: #99a9bf;
        }

        .el-carousel__item:nth-child(2n + 1) {
            background-color: #d3dce6;
        }
    </style>
  ```
> ==轮播图:== 直接使用即可,内部由许多的样式,至于内容替换成你自己想要的即可
> ==24栏:== 就是把100vw分成24份,你可以随意搭配每个栏的长短,不再需要设置width: 33.3% 等烦人的css样式了,**最后注意,24栏没有响应式布局,当宽度小于一定程度时栏内内容会溢出**

### elementPlus表单组件
- 表单只留下了部分数据,均来自模板
  ```
    <!-- form表单组件 -->
    <template>
        <!-- :model记录form表单信息,form在下面是个对象 -->
        <el-form :model="form" label-width="auto" style="max-width: 600px">
            <el-form-item label="新闻标题">
            <el-input v-model="form.title" />
            </el-form-item>
            <el-form-item label="新闻分类">
            <el-select v-model="form.category" placeholder="请选择分类信息">
                <el-option label="经济" value="经济" />
                <el-option label="明星" value="明星" />
                <el-option label="科技" value="科技" />
            </el-select>
            </el-form-item>
            <el-form-item label="新闻内容">
            <el-input v-model="form.content" type="textarea" />
            </el-form-item>
            <el-form-item>
            <el-button type="primary" @click="onSubmit">创建</el-button>
            <el-button>取消</el-button>
            </el-form-item>
        </el-form>
    </template>

    <script setup>
        import { reactive } from 'vue'
        import useNewStore from '../store/newStroe'; // 引入useNewStore
        import {useRouter} from 'vue-router'

        const router = useRouter()
        // 响应式 和model绑定了
        const form = reactive({
        title: "",
        category: "",
        content: ""
        })
        // 提交pinia临时存储数据,就不给后端发信息了,太麻烦了,不过刷新数据就会丢失了
        // 这里就涉及一个地址传参和值传参的问题,在newStroe.js文件中看看
        const newStore = useNewStore()

        const onSubmit = () => {
        console.log('提交数据给后端', form)
        newStore.add(form) // 存储数据到newStore中
        router.push('/news/newlist') //跳到新闻列表页面
        }
    </script>
    ```
- 由几个简单的板块组成: 
    - el-form: 表单根组件,:model="form"的form记录所有表单信息,新闻标题title,新闻分类category,新闻内容content,已经创建reactive型状态
    - el-form-item: 普通表单框,v-model="form.title"(==记录title信息==)
    - el-form-item + el-select(v-model="form.category"==记录分类信息==) + el-option: 可选择的表单框
    - el-input: v-model="form.content" (==记录内容==)
    - el-button: 按钮组件,挑选了2个好看的按钮样式
- ==onSubmit函数: **提交pinia临时存储数据,就不给后端发信息了**==,太麻烦了,不过刷新数据就会丢失了
  - newStore.add(form): 调用newStore的add函数,传入数据
  - router.push('/news/newlist') 跳去新闻列表页面,==这是index命名潜规则==
- **这里就涉及一个地址传参和值传参的问题,在newStroe.js文件中看看**
- ==newStore.js==
  ```
    import { defineStore } from 'pinia'
    import {ref} from 'vue'

    const useNewStore = defineStore("news", () => {
        // ref包装 = state
        const list = ref([])
        // 函数 = Action 存信息
        const add = (value)=>{
            // list.value.push(value)
            // 在测试中,注意,每次传进来的是一个钥匙,指向form这同一个内存
            // 产生问题: 每次我们修改form添加进去,之前所有已经在list内部的数据都会变成这个新提交的数据
            // 原因: list内部都共用一把钥匙,内存数据变化,所有已经添加进入数组数据跟着变,都长一样的
            // 解决: 结构赋值,把穿过来的内容解构赋值给新对象(大家的钥匙各不相同了,对象是复杂数据,独一无二),加入list数组
            list.value.push({...value})
        }

        return{ 
            list, 
            add
        }
    })

    // 记得导出
    export default useNewStore
  ```
  > 总结: ==重点学习表单组件的简单用法==,**认识到值传参和地址传参的区别,在传递复杂数据时要有这个意识**
### elementPlus表格组件
- 均来自模板复制,略微改造
  ```
    <!-- Table 表格组件 -->
    <!-- 自定义列模板: 网站提供了自定义功能,插槽 -->
    <template>
        <el-table :data="newStore.list" style="width: 100%">
            <!-- prop的作用是把tableData的title信息都放在列表的标题(label)列,很重要 -->
            <!-- #default="scope" 插槽作用域问题,复习,使得插槽代码可以突破作用域获取父组件的内容  -->
            <el-table-column label="标题" width="180">
                <!-- 插槽 -->
                <template #default="scope">
                    <div style="display: flex; align-items: center">
                        <b style="margin-left: 10px; color: red;">{{ scope.row.title }}</b>
                    </div>
                </template>
            </el-table-column>

            <el-table-column prop="category" label="分类" width="180" />
            <el-table-column prop="content" label="内容" />

            <el-table-column label="操作" width="180">
                <!-- 插槽 -->
                <template #default="scope">
                    <el-button type="primary" round @click="handleEdit(scope.row)">编辑</el-button>
                    <el-button type="danger" round>删除</el-button>
                </template>
            </el-table-column>
        </el-table>
    </template>

    <script setup>
        import useNewStore from '../store/newStroe';
        const newStore = useNewStore()
        // 直接在表单中使用了,在:data属性中

        const handleEdit = (data) => {
            console.log(data)
        }


        // tableData就是以后我们做项目时从后端传过来的数据 axios
        // const tableData = [
        //     {
        //         date: '2016-05-03',
        //         name: 'Tom',
        //         address: 'No. 189, Grove St, Los Angeles',
        //     },
        //     {
        //         date: '2016-05-02',
        //         name: 'Tom',
        //         address: 'No. 189, Grove St, Los Angeles',
        //     },
        //     {
        //         date: '2016-05-04',
        //         name: 'Tom',
        //         address: 'No. 189, Grove St, Los Angeles',
        //     },
        //     {
        //         date: '2016-05-01',
        //         name: 'Tom',
        //         address: 'No. 189, Grove St, Los Angeles',
        //     },
        // ]
    </script>

  ```
- 组件简单介绍:
  - el-table: 根组件,:data="newStore.list"放数据的地方,是列表的数据来源
  - el-table-column: 表格列,==label是列名==,会把数据中对应类型的数据放在这一列,==内部放插槽template #default="scope",**自定义数据+突破插槽作用域(获取父组件的用户信息)**==,内部放标题数据
  - 最后加了2个el-button,和上面一样,插槽+作用域跨级获取父信息,象征性地添加了事件和执行打印信息的功能
> 总结: 获取来自newStore的信息,然后动态添加到列表中,实现表单向newStore添加数据,列表从其中获取数据,在项目里,代替store的角色就是数据库

## vitest测试(选修)
### vitest--模块测试
- 测试也是一个业务需求,也有专门的岗位,有些甲方也要求有测试的业务,测试相当于一个证明书,证明你的代码是没问题的,写测试可以检查你的程序是否能达到预期效果,比如得到想要的结果或是点击响应的页面产生相应的页面变化
- 全局下载: `npm install -D vitest`
- 在package.json中配置命令: (==类似于dev的配置,目的是简化启动vitest命令==),==启动指令为 `npm run test`.==
  ```
    {
        "scripts": {
            "test": "vitest"
        }
    }
  ```
- ==vitest的测试是**依据代码的,和浏览器运行,服务器运行(run dev)没有任何关系,而且是热更新,只要保存文件就会执行一次测试,测试在终端中进行**==
- vitest(==选择测试/不测试==)
  - vitest在src中寻找测试文件的格式 (a).test.(js) 前缀随意,中间test,后面是文件后缀js,ts,mjs,cjs,mts,cts,jsx,tsx都行
  - 运行时,终端已经提示那些文件属于测试序列,那些不测试了,例如node_modules,dist等文件,这是引入的组件,vitest不检查它们,它只会检查咱们自己写的组件等内容
- **模块测试: 针对单个函数方法或js程序的测试,属于小方面**
- ==js文件的测试:==
  - 被测试的js文件(官网案例): ==test1.js==
    ```
    // 测试用例 vue.js的例子
    // 测试模块
    export function increment(current, max = 10) {
        if (current < max) {
            return current + 1
        }
        
        return current
    }
    ```
  - ==测试文件的命名格式为 **(随意).test.js**==
  - ==1.test.js==
    ```
      import {increment} from './test1'
      import {describe,test,expect} from 'vitest'

      // 测试js:
      describe('测试test1模块的increment方法', () => {
          // 测试单项:
          test('increments the current number by 1', () => {
          // expect(执行内容).toBe(期望结果) 测试通过打对勾,不通过打X
          expect(increment(0, 10)).toBe(1)
          })
      
          test('does not increment the current number over the max', () => {
          expect(increment(10, 10)).toBe(10)
          })
      
          test('has a default max of 10', () => {
          expect(increment(10)).toBe(10)
          })
      })
    ```
  > 1.引入了三个方法describe,test,expect + js文件直接引入
  > 2.这个测试是数据测试,调用js文件的函数,输入值和想要的结果,看看是否通过
  > 3.解析下test(): 单项测试,每一个test都是个测试用例,成功的会打对勾,失败打叉,vitest会显示哪里出错了
  > 3.1第一个参数就是写你要测试什么,相当于printf("我的数据是",data)的感觉,是给自己和客户看的,让别人指导你这部分测试的是个啥
  > 3.2第二个参数是回调函数,内部expect(执行内容).toBe(期望结果),测试通过打对勾,不通过打X
  > 4.最外层的describe是测试组,每个测试组有多个test测试单项,参数也是随意命名字符串,然别人指导这个组是测试什么的
- ==测试pinia,正好他也是纯js文件==
  - ==测试对象是5-vant/store/TabbarStore和CinemaStore==
    ```
        import { defineStore } from 'pinia'
        import {ref} from 'vue'

        const useTabbarStore = defineStore("tabbar", () => {
            // ref包装 = state
            const isTabbarShow = ref(true)
            // 函数 = Action
            const change = (value)=>{
                isTabbarShow.value = value
            }

            return{ // 你必须在 setup store 中返回 state 的所有属性
                isTabbarShow, // 相关App.vue对于isTabbarShow的使用全都不用改
                change
            }
        })

        // 记得导出
        export default useTabbarStore

    ```
  - ==2pinia.test.js==
    ```
        import { describe, test, expect,beforeAll } from 'vitest'
        import useTabbarStore from '../5-vant/store/TabbarStore'
        // 方法1: 引入后报错,提示未激活pinia,原因是cinemaStore中又引用了别的store(cityStore),修改下CinemaStore.js
        // 让引入的cityStore不立即执行,放函数里,这样可以通过了
        // import useCinemaStore from '../5-vant/store/CinemaStore'
        import { setActivePinia, createPinia } from 'pinia'


        describe('测试store(pinia)的方法', () => {
            let store
            let cinemaStore
            // 由于测试的js和服务器没关系,所以你在main.js中引入和注册的pinia,在测试环境中是没有的,这个测试文件是直接执行这个文件的,它不认识pinia
            // 所以我们需要对pinia激活
            // 这个函数的功能是在测试之前执行一些东西
            beforeAll(async () => {
                // 激活pinia
                setActivePinia(createPinia()) // = app.use() 注册
                // 方法2: 激活pinia后再引入,只不过这是异步,等待CinemaStore的导入
                // 注意: import {} from ''可以直接获取导出的方法,但是下面的导入,需要多访问一层default 
                const useCinemaStore = await import('../5-vant/store/CinemaStore')
                console.log(useCinemaStore) // 打印看看内部解构,属性default内部含有对象
                store = useTabbarStore()
                cinemaStore = useCinemaStore.default()
            })
            // 测试单项:
            test('tabbarStore', () => {
                // 使用store
                expect(store.isTabbarShow).toBe(true)
                store.change(false)
                expect(store.isTabbarShow).toBe(false)
            })
            test('cinemaStore', async () => {
                // 使用store
                expect(cinemaStore.cinemaList.length).toBe(0)
                await cinemaStore.getCinemaList() // 记住这个函数执行是异步
                expect(cinemaStore.cinemaList.length).gt(0) // gt: 大于 get: 大于等于; lt: 小于 lte: 小于等于
            })
        })
    ```
- ==**重点**==:
  - 引入TabbarStore会报错,说不认识pinia,让我们激活
  - 原因: 测试只会直接执行js文件,和服务器等都没关系,更没有vue的入口main.js的事,这也就意味着,==测试文件不认识pinia,它们有pinia的创建和注册==
  - vitest提供了激活pinia的方法`setActivePinia()`(==相当于app.use() 注册==),内部注册pinia,在引入`createPinia()`,放个pinia对象进入激活,这样就可以使用pinia的store
  - 所有测试之前的操作,就比如激活pinia,可以写在==beforeAll函数内部==,他是测试之前执行的
- ==**重点2**==
  - 测试cinemaStore,从引入直接就报错,虽然激活了pinia,但是问题其实处在cinemaStore自身,首先测试引入后,会到其内部查看代码
- cinemaStore.js
  ```
    import { defineStore } from 'pinia'
    import axios from 'axios'
    import { ref, computed } from 'vue'
    // 新知识: pinia: 在一个store中引入另一个store的数据
    import useCityStore from './cityStore'
    // 直接调用,直接创建,直接使用,十分简单 方法2: 不动这里,直接在测试文件中操作
    const cityStore = useCityStore()

    const useCinemaStore = defineStore("cinema", () => {
        ....
    })
  ```
  > ==认真看,发现代码中有`useCityStore()`,这是从cityStore引进的pinia,所以vitest看不懂了,此时测试文件还没执行到pinia注册呢,还在import引入代码,这是有2个方法,一是,把这个`const cityStore = useCityStore()`放入store的getCinema函数内部,这样就没事了,函数不会自动执行,调用时才执行,那时候test内的pinia早注册完了,第二个方法就是把cinemaStore的引入放在注册pinia后面,就和上面的代码一样,不过这个导入是异步的,而且获取的对象和import略不同,需要多一层default==
  > 测试: 1.和前面差不多expect内部测试store内的状态和方法,expect之间可以调用函数执行,然后再expect测试函数执行后的数据
  > 2.==测试cinemaStore的时候,getCinemaList()是异步,所以要加async和await==
### viteset--组件测试(写的不咋地)
- 需要下载2个库: `npm i -D @testing-library/vue jsdom` (-D 全局安装)
  - @testing-library/vue: 是一个专注于测试组件而不依赖于实现细节的 Vue 测试库。它的指导原则是：测试越是类似于软件的使用方式，它们就能提供越多的信心。
  - jsdom: jsdom 是许多 Web 标准的纯 JavaScript 实现，特别是 WHATWG DOM 和 HTML 标准，用于 Node.js。通常，该项目的目标是模拟足够多的 Web 浏览器子集，以便用于测试和抓取现实世界的 Web 应用。
- 写了2个组件App.vue和Child.vue
- ==**组件测试和单元测试的区别**==: 测试的不再是单独的针对代码中的函数方法等进行值的测试,而是测试页面tem中的count值的变化和模拟用户点击后count是不是按照代码+1,==属于面向页面的内容测试和页面操作测试,和代码值等代码层面的东西没关系了,重点关注tem的内容和触发事件==
- App
  ```
    <template>
        <div>
            {{ count }}
            <button @click="handleAdd">add</button>
        </div>
    </template>

    <script setup>
        import { ref } from 'vue';

        const count = ref(0)
        const handleAdd = () => {
            count.value++
        }
    </script>
  ```
- Child(==接受父传子的title属性==)
  ```
    <template>
        <div>
            {{props.title}}
        </div>
    </template>

    <script setup>
        import {defineProps} from 'vue'
        const props = defineProps(["title"])
    </script>
  ```
- ==3vue.test.js==
  ```
    // 组件测试: 测试的不再是单独的count值的测试,而是测试页面tem中的count和模拟用户点击后count是不是按照代码+1
    // 单元测试: 比较针对组件中的某个属性,方法等,测试它们的变化和值
    import Counter from './App.vue'
    import Child from './Child.vue'
    import { describe, test } from 'vitest'
    // 新方法渲染render,需要在vite.config.js文件中配置test的环境,即jsdom
    // fireEvent触发事件的方法
    import {render,fireEvent} from '@testing-library/vue'

    describe('测试组件', () => {
        // 测试单项:
        test('测试App组件', async() => {
            // console.log(render(Counter).getByText) // 打印对象,我们需要其中getByText的方法
            // getByText: 功能：创建一个定位器，能够找到包含特定文本的元素。如果元素的TextNode的nodeValue或输入元素（类型为button或reset）的value包含指定文本，则可以找到该元素。通过文本匹配总是会规范化空白，即使是精确匹配也会如此。例如，它会将多个空格转换为一个，将换行转换为空格，并忽略开头和结尾的空白。
            let {getByText} = render(Counter)
            getByText("0") // 隐式测试 测试内容中是不是0
            // 注意是"所有的内容",如果你写多了东西,加了别的英文字母或换行,那么就认为不对,这不是"包含"关系

            const button = getByText("add") // 在页面中找带有add的节点
            await fireEvent.click(button) // 模拟用户点击,异步
            getByText("1") // count ++ --> 1
        }),
        test('测试Child组件', async() => {
            let {getByText} = render(Child,{ // 模拟父传子
                props:{
                    title:"kerwin"
                }
            })
            getByText("kerwin") // 渲染完,子组件的内容是否为kerwin
        })
    })
  ```
 - 测试面向页面的内容和触发事件在代码层面就有`render`和`fireEvent`两个方法,需要引入,其中render还需要在vite.config.js文件中配置test的环境,针对jsdom(已经配好不用管了)
 - ==测试组件==
   - 把组件引入,然后渲染组件页面,render(组件),vitest会按照vue文件的tem打印出对应的document页面,然后才能开始面向页面的测试
   - ==测试页面数据匹配==,比如getByText(),不过这是绝对的数据,多余的数据和空格换行和字符都会造成测试失败
   - 最后官网关于这部分的内容翻译成中文我都看不懂,额...
   - 测试事件的触发`fireEvent`,获取button的节点(getByText,不懂),然后触发这个节点,触发事件是异步的,父传子是异步的
- ==总结: 这是选修,kerwin也是大致讲了下,理解不深,文档生涩难懂==
## TypeScript(粗浅)
### Typescript基础(类型判断)
- 针对使用npm的用户: `npm install -g typescript`
- ts最后会被编译为js再显示在浏览器中,==**ts会在代码层实时显示你的代码错误,无需运行服务器或者打开浏览器的检查工具**==
- ==我们在src/ts中新建了4个ts文件夹,用于测试,如果想要在浏览器中观察这些数据,请在index.html中更改链接地址为XX.ts文件即可==
- ==01-base.ts==
  ```
    // console.log(111)
    // 类型系统:
    var myname:string = "kerwin" // 显式定义类型: 定义好string类型
    var myname1 = "xiaoming" // 隐式定义类型: ts会根据初始化的内容推断myname1是string类型
    // ts会在代码端直接报错,即使你没有运行
    // myname = 100 // string != number
    myname.substring(0,1) // 你打错了方法拼写,或者在错误类型上使用了不属于该类型的方法,都会及时报错
    var myage = 100.125 // 简写定义number类型数据
    myage.toFixed() // 截取小数点,针对number
    var myshow:boolean = true // 布尔类型的定义

    var myany:any = "123" // 和js的var一样了,啥类型都可以
    myany = []
    myany = {}


    export default {}
  ```
- ==解析:==
  - 数据的类型系统
    - 显式定义类型: `var XX:变量类型 = XX`,如同C语言的类型规范,常见的 number string boolean
    - 隐式定义类型: ts会根据初始化的内容推断myname1是string类型
    - 特殊的类型: any,啥类型都可以,==但是ts将不会再检查此变量是否合乎语法,出错了只能从浏览器里发现==
  - ts会根据你的数据类型进行实时检查: 最常见的错误比如给变量赋值错误类型数据或是使用不恰当的方法(例如number数据使用了string的方法)
- 02-数组.ts
    ```
        var mylist = [1,2,3] // 隐式定义数组类型: 默认number型的数组
        mylist.push(4)
        var mylist1:string[] = ["1","2","3"] // 显式定义数组类型
        mylist1.push('4')

        // 如果数组既有数字又有字符串,可以多个类型,再用|分割即可
        var myvalue:(string|number)[] = ['1',2,'3',4]
        // 同理普通变量,既可以是数字类型又可以是字符串
        var mylist2:string|number = "kerwin" 
        mylist2 = 100
        
        var mylist4:any[] = ["kerwin",100,[],{}] // 什么都可以放的数组,ts不再检查
        // mylist4[0].toFixed() // ts不会检查这个错误,显然这是一个给字符类型数据使用number方法的错误,但是ts认为数组中的每一项都是任意的,所以它不再检查每一项的类型了,所以就会忽略这个错误

        // 风格2: 和上面的类型定义是一回事
        var mylist5:Array<string> = ['1','2','3']
        var mylist6:Array<string|number> = ['1',2,'3',4]
        var mylist7:Array<any> = ["kerwin",100,{'name':'xiaoming'},[1,2,'3']]

        export default {}
    ```
    - ==解析:== 
      - 数组和变量一样,支持数据类型的定义,比如纯数字类型数组,或是纯字符串类型数组等,操作方法一样, var Array:类型[]
      - 支持多个数据类型同时装入一个数组使用`|`分割,同理普通变量也支持
      - 有时候我们对象想放入对象,数组,布尔,数字,字符串等各种东西,那么推荐`any`,==当然ts会停止检查此数组==
      - ==别样的风格:定义数组类型的新格式 `var XX:Array<类型> = [XX]`==
- ==03-对象.ts==
  ```
    var myobj = { // 会对对象内部的属性进行隐式推断
        name:'kerwin', // 认定name属性就应该是string类型
        age: 100
    }
    // myobj.name.toFixed() // 会检查报错,在字符串上使用数字类型方法

    // 接口 规定了对象的属性类型
    interface InterObj{
        name : string,
        age: number,
        location?: string // 可选
        [propName: string] : any // 冗余信息定义,不是我们需要关注的,只是负责接受,这些数据是后端传递的额外信息,我们也不会用,类似属性垃圾桶
    }

    var myobj1:InterObj = {
        name: "xiaoming", // 不只是类型要对应,属性名字也要对应,写成name1,系统无法在InterObj中找到name1的类型定义,会报错的
        age: 18,
        location : "beijing",
        // 后端冗余信息,对我们来说没有用,单纯接收,而且不会报'a,b,c,d在接口中未定义'这种错误
        a:1,
        b:2,
        c:[],
        d:{}
    }

    export default {}
  ```
  - ==解析:==
    - 对象也会隐式定义类型,取决于初始化的类型
    - 你也可以自己定义每个属性的类型,使用==接口(ts独有,js没有)==处理,如上代码,==注意事项:==,对于可选属性多加个?,对于冗余信息,统一使用`[propName: string] : any`接受
- ==04-函数.ts== 
  ```
    // 对函数的参数及返回值都限定为number类型
    function sum(a:number,b:number):number{
        return a + b
    }
    // sum('1','2') // ts直接报错,传参需num而非string
    // var sumRes:string = sum(1,2) // ts报错,返回num,不应string接收

    export default {}
  ```
  - 如上,函数可以对参数和返回值定义类型
### TS与选项式(不推荐的)
- ==typescript与vue的选项式结合远没有组合式好,所以不推荐==
- 在src的01-OptionTs的文件中
- APP.vue(**记住是组合式**)==分隔开讲解==
- ==ts中的状态==
  ```
    js:
        interface InterState {
            myname: string,
            mytext: string,
            myage: number,
            list: Array<string>
        }

        export default{
            return ({
                myname: "kerwin",
                myage: 100,
                mytext: "",
                list: [] // 如果不引入接口,给list规定类型,系统会隐式定义list为never类型(在TypeScript中,never是一组空值),就无法push数据进入list了
            }) as InterState // as 类型断言: 我们断言这个状态就是InterState内部规定的类型
        }
  ```
  > 就是使用接口去限制状态的属性类型,使用了新语法`as`
  > 这样ts会监视这些变量状态的使用,会及时报错给你提示
- 一些特殊的类型(==这里举了div和input的例子==)
- ref-$refs(获取dom对象)
  ```
    tem:
        <div ref="mydiv">测试</div>
        <input type="text" ref="myIpt">
        <button @click="handleClick">click</button>
    js:
    methods:{
        handleClick() {
            // 拿dom对象 ref - $refs
            // 将dom对象断言(as)为任意类型,才可以继续访问其内部的信息,比如 innerHTML等
            // console.log((this.$refs.mydiv as any).innerHTML) // 断言任意类型,随意拿取值
            // 专业一点的化,这个dom(div)有自己的类型
            console.log((this.$refs.mydiv as HTMLDivElement).innerHTML)
            // 同理获取input的value,input有自己的类型,如下
            console.log((this.$refs.myIpt as HTMLInputElement).value)
        }
    }
  ```
  > 这里获取了div和input的对象,如果想要继续深层访问内部的属性,比如div的innerHTML或input的value,我们需要规定div和input的类型,在ts中有它们的类型,分别是HTMLDivElement和HTMLInputElement,至于其他的你可以自己随用随搜
- 计算属性也可以设置自己的返回类型,但是一般计算属性是会隐式定义的,他自己会查,写了多此一举,如下
  ```
    // 计算属性
    computed:{
        // 即使不写:string,ts也会根据return的值隐式推断
        computedName():string{
            return this.myname.substring(0,1).toUpperCase() + this.myname.substring(1)
        }
    }
  ```
- ==**父与子的通讯部分**==(==最复杂的地方,这也是为何不推荐ts结合选项式的原因==)
- 父App.vue
  ```
        <Child style="background-color: yellow;" title="首页" :item="{ // 父传子传递复杂类型数据(对象)
        name: 'kerwin', // 规则: 单引号
        age: 100,
        list: [1,2,3]
        // @event监听子传父的函数
        }" @event="handleEvent"></Child>
  ```
  > 这里就不写子组件的components的注册了
  > 父组件向子组件Child传递了属性title和item,其中title就是个字符串值,而item是复杂类型数据对象(所以加了:)
  > 父组件监视子组件的事件是@event
- 子Child.vue
  - 接受父组件信息title和item(==其中对于对象的接受尤其麻烦==)
  ```
    js:
    // 新知识: 引入新类型PropType
    import type { PropType } from 'vue';
    // 定义好引入对象的接口
    interface IProps{
        name:string,
        age:number,
        list:Array<number>
    }
    
    export default{
    // 接受父信息
        props:{
            title: String, //未接合ts的写法,会被隐式转为ts
            item: Object as PropType<IProps> // as断言为PropType,再附加对象接口,至此才能正常使用这个对象(选项式很麻烦) 
        }
    }
  ```
  > 需要引入新类型PropType,然后再用接口对传递的对象进行类型限制,把接口放入PropType中,最后as这个配置好的PropType,==十分麻烦!!!!!==
- 子传父:
- Child.vue
  ```
    tem:
    <!-- 子传父 -->
    <button @click="handleClick()">go father</button>

    js:
    methods:{
        handleClick(){
            // 子传父
            this.$emit("event","来自子组件的问候")
        }
    },
    // 限制event传递的参数必须是string类型
    emits:{
        event(payload: string){
            return payload
        }
    }
  ```
    > 唯一注意的是,子组件传参的类型限制需要自己设置好,如代码emits设置event的参数payload(随意起)为string类型
- App.vue(==监视子组件的事件 @event="handleEvent"==)
  ```
    // 子传父监听函数
    // 接受值必须是string,这样这个函数内部就会对data数据进行监控,一旦发现你在使用非string的操作会提醒你
    // 但是接受方规定类型不会影响到发送方,也就是说,子组件传形参可以传递非string数据,这需要在子组件发送前进行额外操作检查
    handleEvent(data:string){
        console.log('child-->father: ',data)
    }
  ```
  > 对子传递的参数进行类型限制
### TS与组合式
- 组合式的写法要比选项式简单: **==内部多了关于泛型的知识(没学),所以暂且先用着==**
- ==1.reactive和ref组合式与TS==
  - ==reactive==
    ```
      const state = reactive({
      myname: "kerwin" // 隐式推导string类型
      })
    -------------------
    interface IState{
        myname:string
    }

    // 显式推导
    const state:IState = reactive({
        myname: "kerwin" 
    })
    ```
  - ==ref==
    ```
    const myname = ref("kerwin") // 隐式推导string类型
    
    ---------------
    // 显式推导
    // 写法1: 
    import type { Ref } from 'vue'; // 定义了新的类型Ref(Ref本身是一个接口)
    const myname:Ref<string> = ref("kerwin")
    // 写法2: 这里涉及新知识泛型(没学)
    const myname = ref<string>("kerwin") 
    ```
    > reactive的写法比较简单,显式的写法就是引入接口即可
    > ref的写法涉及泛型,但是内部也能看懂,设置数据类型
- ==2.ref获取dom对象的组合式TS写法==
  ```
    tem:
        <div ref="mydiv">我是div</div>
    js:
        // 定义好类型(泛型)
        const mydiv = ref<HTMLDivElement>()
        // 在dom挂载后测试
        onMounted(()=>{
            console.log(mydiv.value?.innerHTML) // js的知识: 自动补全?是防范mydiv.value为空,如果为空就不执行?后面的代码了
        })
  ```
  > 依靠泛型把数据类型HTMLDivElement规定好
  > ==?是js的知识,?前面的为空,则不执行后面的数据,这是一种TS的保护措施,防止从undefined中取数据==
- ==3.计算属性,首字母大写==
  ```
    // myname的定义及tem代码略
    js: 
    // 4.计算属性 ------------
    const myname = ref("kerwin")
    // 隐式推导
    const computedName = computed(()=>myname.value.substring(0,1).toUpperCase() + myname.value.substring(1))

    -----------------------------------

    // 泛型写法 但是就是下面这个样式,显式推导
    const computedName = computed<string>(()=>myname.value.substring(0,1).toUpperCase() + myname.value.substring(1))
  ```
  > 泛型写法把计算属性的返回值确定为了string类型
- ==4.函数方法,没变==
  ```
    // 函数方法 把参数定义好类型,这样ts就会实时检查index的使用
    const handleAdd = (index:number)=>{
        console.log(index)
    }
  ```
  > 直接对形参规定数据类型
- ==5.父子通讯==
  - App.vue(父)
    ```
    tem:
        <!-- 父子通讯 -->
        <Child title="首页" :obj="{name:'kerwin',age:100}" @event="handleEvent"></Child>
    js:
        //子传父的事件@event
        const handleEvent = (value:string)=>{
            console.log(value)
        }
    ```
  - Child.vue(子)
    ```
    interface Iprops{
        name:string,
        age: number
    }

    // 组合式 泛型写法
    // 也可以加?,代表可选,注意对应的也要在tem的props.obj后加?,防止其undefined的同时还要取其name属性(结合上面的代码)
    const props = defineProps<{
        title:string, // 纯ts
        obj?:Iprops // obj由Iprops接口规范
    }>()

    // 组合式中的emit
    // const emit = defineEmits(["event"])
    // 对传递过去的参数进行类型规定,和前面的一样,泛型写法
    const emit = defineEmits<{
        // e(固定): 事件名字 , 随意名字:类型
        (e:'event',myvalue:string):void
    }>()

    const handleClick = ()=>{
        emit("event","你好 父组件")
    }
    ```
    > 子组件对父组件复杂类型(比如对象)的限制规定写在接口里,然后泛型+defineProps()结合去写,注意看把规定都写在<>里面
    > 子传父,除了setup的emit写法外,使用泛型写法对传过去的参数进行类型显示,注意泛型内部的写法 (e(固定): 事件名字 , 随意名字:类型):void
### TS与路由
- 创建03-RouterTs文件,原文件来自myapp/src/02-VueRouter的原班人马
- 更改ts步骤:
  - 提前下载好原来myapp的模块(==去参考package.json文档==),axios sass router pinia(下节用),把js文件改为ts文件,把vue文件的script的lang改ts类型
  - script需要更改ts的vue: 
    - Center,Detail和Login直接改,内部也不需要大型修改,最多是对函数的参数进行显式推导定义
    - ==难点的films文件夹内的Nowplaying.vue==
- Nowplaying.vue:
  ```
    <template>
        <div>
            正在热映
            <ul>
                <ul>
                    <li v-for="item in datalist" :key="item.filmId" @click="handleClick(item.filmId)">
                        {{ item.name }}
                    </li>
                </ul>
            </ul>
        </div>
    </template>

    <script setup lang="ts">
        // 082 编程式导航: 给正在热映添加上热映电影的列表,先用选项式
        import axios from 'axios'
        import { onMounted, ref } from 'vue';
        import { useRouter } from 'vue-router';
        interface Iitem{
            filmId:number,
            name:string
        }
        // 全局的this
        const router = useRouter()
        // 定义datalist数据(ref型)
        // 需要定义好datalist的类型,其内部是一个个的对象,属于复杂类型数据,此代码的意思是数组内部的每一项为Iitem接口类型,初始化为[],后期异步会有新数据
        // 如果不显式定义好,ts会隐式定义其为never型(此行代码执行时异步还没填充数据给datalist,此时为空),然后tem对datalist的操作均会判错
        const datalist = ref<Iitem[]>([])  
        // 点击事件
        const handleClick = (id:number) => {
            // 代替this
            router.push('/detail/' + id)
        }
        // 生命周期函数mounted改为组合式写法, async + await
        onMounted(async () => {
            let res = await axios({
                url:"https://m.maizuo.com/gateway?cityId=110100&pageNum=1&pageSize=10&type=1&k=468810",
                headers:{
                    'X-client-info':'{"a":"3000","ch":"1002","v":"5.2.1","e":"1700392515260648680292353","bc":"110100"}',
                    'X-host':'mall.film-ticket.film.list'
                }
            })
            // ref + value
            datalist.value = res.data.data.films
        })
    </script>
  ```
  - ==注意点==: ==datalist的定义初始值为ref([]),此时ts会隐式推导此变量为never类型==,然后tem中对于datalist的v-for循环操作会报错,==主要是异步获取的数据顺序在初始化之后,所以ts不知道未来datalist会使什么样子==,我们知道他是一个对象数组,所以==使用显式推导提前定义好类型==
  - ==显式推导==: 使用了接口定义,如上代码和注释解释,ts确切知道数组中每一项的类型解构后即不会报错了
### TS与pinia
- pinia文件同理借鉴原myapp 4-pinia文件的原班人马
- pinia几乎没有修改,它和ts结合的十分好
- store中的TabbarStore.ts
    ```
        import { defineStore } from 'pinia'
        import {ref} from 'vue'

        const useTabbarStore = defineStore("tabbar", () => {
            // ref包装 = state
            // 显式推导(额外加<>)
            const isTabbarShow = ref<boolean>(true)
            // 函数 = Action
            const change = (value:boolean)=>{
                isTabbarShow.value = value
            }

            return{ // 你必须在 setup store 中返回 state 的所有属性
                isTabbarShow, // 相关App.vue对于isTabbarShow的使用全都不用改
                change
            }
        })

        // 记得导出
        export default useTabbarStore
    ```
    > 对isTabbarShow做了个显式推导(额外加<>)
    > 对函数change的参数value做了个显式推导boolean
- main.ts文件中引入并注册pinia(==这是基础,别忘了==)
    ```
    import { createApp } from 'vue'
    // import './style.css'
    import App from './04-PiniaTs/App.vue' 
    import router from './04-PiniaTs/router' 
    // pinia引入
    import { createPinia } from 'pinia'
            
    createApp(App)
    .use(router)
    .use(createPinia()) // pinia注册 
    .mount('#app')
    ```
- 其余的就是在App和Detail引入了store中的TabbarStore,实现了进入电影详情页面的底边栏显示与隐藏的基础操作,没有任何变化

## Vue高频面试题-Vue内功心法
- 1.**单向数据流和双向数据绑定**
  - 单向-父子通讯: 父组件传给子组件信息,父组件修改信息后会同步进入子组件,但是子组件修改信息不会自动传回给父组件,需要emit,defineEmits方法去辅助,这就是单项数据流,这是为了代码更好的维护,防止子组件失误更改父组件信息影响到其他的子组件
  - 双向数据流: v-model,适用于表单form的数据绑定
- 2.**Object defineProperty有什么缺点(Vue2的底层,Vue3升级proxy)** 
  - 无法监听ES6的set map
  - 无法监听class数据
  - 属性的添加与删除(对象)无法监听
  - 数组元素的增加与删除也无法监听
- 3.**对MVC MVP MVVM的理解**
  - ...没听懂,不过MVVM是最好的模式
- 4.**Vue2和3关于生命周期的变化(老问题)**
  - 如图:
        [![pA6hVh9.jpg](https://s21.ax1x.com/2024/11/10/pA6hVh9.jpg)](https://imgse.com/i/pA6hVh9)
- 5.**结合2,Vue响应式的原理? Proxy(Vue3)和Object.defineProperty(Vue2)的区别**
  - 如图:
    [![pA6hn6x.jpg](https://s21.ax1x.com/2024/11/10/pA6hn6x.jpg)](https://imgse.com/i/pA6hn6x)
- 6.**Composition API的新开发体验**
  - 在组合式中组织代码可以提高可维护性和可读性,类似于hook写法,简洁
  - 解决生命周期函数时,选项式写法会把同一个功能拆分到不同函数中,比如定时器在mounted创建,在destory中删除,许多的不相关逻辑代码都如此拆分到一个个的生命周期函数中会显得业务逻辑混乱,不好维护,而组合式hooks每一个引进的模块都可以有自己的一套生命周期函数,在模块中可以功能和代码一体化,内部不会有其他的功能代码掺杂,选项式是大锅饭,每个生命周期函数都集合了所有功能的不同阶段操作,而组合式是小碗饭,只会在自己模块中的生命周期函数执行自己相关功能的代码,最后一起引入App.vue即可
- 7.**对比jQuery,vue有什么不同**
  - jQuery注重图层,直接操作dom进行页面渲染(很多都是别人封装好的dom操作),vue专注于数据层,不经常操作dom,通过数据双向绑定响应式更改dom,vue还是用了组件化思想,提高了复用性
- 8.**vue中如何定义全局css**
  - style默认全局,加scoped默认局部
- 9.**\$root \$parent \$refs的区别**
  - \$root和\$parent都能访问父组件的属性和方法,区别在于存在多级子组件时,通过parent只能访问最近一层的父组件,而root可以直接访问到根父组件(一步到位快约中间所有的组件,直接到根组件); 
  - 通过在子组件标签上定义ref属性,父组件可以通过\$refs访问子组件实例(可以操控子组件内部的属性和方法(赋值,调用等),而不需要传统的父传子,耦合度高,不推荐)
- 10.**Vue中如何自定义指令**
  - 一种封装好的获取dom节点的方法,区别于js的documnet.getElementBy....,自定义指令也有常用的钩子函数,比如bind和update
  - 如图:
    [![pA6hepR.jpg](https://s21.ax1x.com/2024/11/10/pA6hepR.jpg)](https://imgse.com/i/pA6hepR)
- 11.**Vue过滤器(略)Vue3不支持**
  - Vue2用filter的一些语法过滤,而Vue3使用计算属性和函数方法解决,其中计算属性无法传参
  - 过滤器作用是对数据进行2次加工,比如把地址中的乱码去掉(乱码是防止地址被盗用而添加的安全措施)等
- 12.**Vue单页面的优缺点**
  - ==优点:==
    - 1.单页面内容的更改不需要跳转到新的页面,也就不用加载整个页面,内核就是单页面的div隐藏与显示,看似内容变了,其实页面没变化
    - 2.没有页面切换,不会出现'白屏'现象(网络延迟等),而且可以在网页切换的组件中添加加载组件,对于有延迟的切换显得不那么空,起码不是白屏,更可以做一个404页面(组件),相对比浏览器的原生未响应404页面,这个页面你可以自己定制化的制作
    - 3.对服务器压力小,服务器只需提供数据,不需要处理展示逻辑和页面合成
    - 4.良好的前后端分离,同一套后端代码应用于web,手机,平板等多个客户端(对后端的友好)
  - ==缺点:==
    - 1.首次加载耗时长(可以懒加载减轻加载组件的负担)
    - 2.SEO问题,不利于百度,360引擎的收录,爬虫爬不到
    - 3.容易css命名冲突
    - 4.前进,后退,地址栏,书签等,都需要程序管理,页面复杂度高,==**所以使用Vue一定要善于站在巨人的肩膀上,善于使用别人封装好的组件(移动端的vant和PC端的elementPlus)**==
- 13.**Vue-router使用params与query的区别**
  - 第一次学到这个是跳转电影详情页面时,我们需要知道这是哪个电影的详情页面,所以需要把电影的filmId传递负责渲染电影详情页面的Detail组件,所以有了这2个传递方式
  - 这2个传参形成的url不同,接受的方式也不同,但本质区别不大
    [![pA6hm11.jpg](https://s21.ax1x.com/2024/11/10/pA6hm11.jpg)](https://imgse.com/i/pA6hm11)
- 14.**keep-alive的作用**
  - 顾名思义'保持活着',每次切换组件路由会销毁组件,但是keep-alive可以保留组件状态,避免下次切回来重复渲染,但是内部的mounted和created等钩子函数只会在第一次进入组件时调用,后面不会调用了,如果需要再次调用它们需要active和deactive,这两个钩子函数时keep-alive独有的
- 15.**vue如何实现单页面应用**
  - hash(#): 通过监听浏览器 onhashchange()事件变化去查找对应的路由器规则
  - history(/): 利用H5新增API pushState()和replaceState()和一个事件onpopstate监听url的变化
- 16.**4种的vue指令和它的用法**
  - v-if: 判断隐藏,从创建角度进行,如果隐藏压根不创建这个节点
  - v-show: 判断隐藏,无论隐不隐藏,都会创建这个节点,类似css的block和hidden
  - v-for: 循环,常用于遍历数组,记得+key,提高复用(与diff算法有关)
  - v-bind: 绑定css属性
  - v-model: 双向数据绑定 form表单
- 17.**如何一个路径渲染多个组件?**
  - 通过对router-view命名name,然后引入路由时一一对应,如图:
    [![pA6IY9J.jpg](https://s21.ax1x.com/2024/11/10/pA6IY9J.jpg)](https://imgse.com/i/pA6IY9J)
- 18.**多个组件共享一个路由?**
  - 将多个路由的component字段值设置为同一个组件即可
    ```
        const routes = [
            {path:'/',component: Home}, // 默认页面为home
            {path:'/home',component: Home},
        ]
    ```
- 19.**如何检测动态路由的变化**
  - 典型案例: 电影界面'猜你喜欢'点击时不会触发mounted函数,从而导致无法发送新的数据请求axios,导致页面渲染不更新,解决就是通过watch+\$route监听(**笔记: 路由/同组件跳转问题**)或通过导航守卫钩子函数beforeRouteUptate来监听他的变化(**笔记: 路由/组件内的守卫(局部拦截)**)
- 20.**vue-router中的router-link上的v-slot属性怎么用?**
  - 具体内容: **笔记: 路由/声明式导航部分**
  - 简单解释: Vue3定制化标签比Vue2麻烦点,可以通过v-slot给标签添加样式,也可以通过router-link标签去代替a标签,它如同template标签一样,自己是不显示在页面中,在上面挂载css属性,自带a标签的跳转功能,==我们在笔记中使用li标签包住router-link标签实现了定制化的li标签+路由跳转功能==
  - kerwin代码如下: (这个是想把css样式加到li上,而非a标签,==这里新颖的点是没有用三目,对class动态绑定,内部不同的class和isActive(与 &&)链接在一起,isExactActive是未点击为true,从而实现点击到时class是router-link-active,没有点击到时,class为router-link-exact-active==)
  - 代码如图:
    [![pA6IGh4.jpg](https://s21.ax1x.com/2024/11/10/pA6IGh4.jpg)](https://imgse.com/i/pA6IGh4)
- 21.**Vue如何去除url的#**
  - 将路由模式有hash改为history
  - ==这里有个新问题(服务器会认定你这些路由path在后端服务器中真的有并会去访问,所以需要提前告知后端服务器人员)==,后端(服务器)开发人员需要添加一个简单回退路由,url不匹配任何静态路由,就需要提供与你应用程序中的index.html相同页面,把权限提供给前端,由vue接管这些路路径由即可
  - 操作如下(vite已经自动规避了这个报错)
  ```
     var history = require('connect-history-api-fallback')
     app.use(history({
        index: './index.html'
     })) // 注意放在所有接口后面
  ```
- 22.**\$router和\$route的区别**
  - /$route是获取路由信息的,他是一个路由信息的对象,基本信息例如name,meta,path,query,params,fullpath,matched和redirectedForm等
  - /$router是VueRouter的实例,包含一些跳转方法,push,go,replace等
- 23.**Vue路由守卫**
  - 经典的路由跳转时检查用户是否有登录授权,如果没有统一跳转到登录页面,有许多钩子函数,例如beforeEach,对所有跳转到此路由的页面进行检查
  - 对路由的跳转进行监控,控制它的跳转或取消,有to,from,next三个参数,如下图:
    [![pA6I8NF.jpg](https://s21.ax1x.com/2024/11/10/pA6I8NF.jpg)](https://imgse.com/i/pA6I8NF)
- 24.**Vue路由的底层实现原理(源码中的相关知识,没学,很难)**
  - 如图:
    [![pA6I3AU.jpg](https://s21.ax1x.com/2024/11/10/pA6I3AU.jpg)](https://imgse.com/i/pA6I3AU)
- 25.**路由的懒加载**
  - 动态导入组件,只有使用到那个组件时才会导入组件,不会从一开始就全部导入
  - 静态导入: `import XX from 'XX'`
  - 动态导入(由webpack封装好了): `const XX = () => import('XX')`
- 26.**插槽,具名插槽和匿名插槽,则么用的**
  - 如下图(解释的很清楚):
    [![pA6XwDJ.jpg](https://s21.ax1x.com/2024/11/10/pA6XwDJ.jpg)](https://imgse.com/i/pA6XwDJ)
- 27.**Vue-loader(???)**
  - 解释和转换 .vue文件,提取中script style HTML template,再把它们交给对应的Loader去处理
- 28.**Vue和React中diff算法区别**
  - React还没学...
- 29.**请你说一下Vue中create和mount的区别**
  - create为组件的初始化阶段,主要完成数据观测,属性和方法的运算,watch/event事件的回调,此时挂载还没开始,未生成真实的DOM,也就无法操作dom,而mounte已经完成了虚拟dom到真实dom的转换挂载,此时html已经渲染出来了,所以可以直接操作dom节点
  - 异步类型的操作比如ajax放在哪个函数中都无所谓,因为异步等待数据的事件很长,代码执行会很快执行完mount阶段,所以等数据回来时,早就挂载好dom了
- 30.**axios是什么?怎么使用?如何使用它实现登录功能的流程?**
  - 涉及新知识axios的拦截器: ???
  - 12:55
- 31.**computed和watch的区别(有时会穿插案例进行面试提问)**
  - ==computed:==
  - computed计算属性会把计算结果进行缓存,如果下次还是这个结果,会直接调取缓存,不像函数调用那样每次都会重新计算(不过计算属性无法传参),同时如果依赖的数据发生了变化,computed会同步重新计算一次并再次缓存
  - 但是计算属性无法处理异步的数据,即由异步导致的数据变化时,是无法监听的,具体案例就是 电影界面的'猜你喜欢'跳转,由异步发送的ajax,url会变化,但是计算属性无法监控这一变化,只能处理同步数据
  - 计算属性可以引入多个属性进行计算,例如: 引入属性a和b相加,返回出去,也可以对单个数据计算,例如: 引入c "result = " + c返回出去
  > 
  - ==watch:==
  - 不支持缓存,一旦发现变化立即执行回调函数,可以在这个回调函数中放入我们上面提到的发送ajax去请求新的数据
  - 2个参数,一个是最新的值,一个是老的值
  - immediate立即监听和deep深度监听属性(针对多层嵌套对象进行监听)  ==注意:数组无需这么做==
- 32.**Vue $forceUpdate强制更新**
  - 很少用,强迫当前实例本身和插槽内子组件重新渲染(注意:不是所有的子组件,只是在插槽内的,而且后代也不算入(子的子...))
- 33.**v-for的key(20:50)**
  - key是Vue中唯一标记的id,通过它我们diff算法可以更精确快捷
  - diff算法在新老虚拟dom做对比时,可以最大化的复用数据,发现id和数据都相同直接复用;id相同数据不同,那就更新;发现在新dom中这个id没了,就直接删除发现出现了新的id和数据,直接添加,并且会根据参考相邻已有的id进行插入位置的确定
- 34.**为什么key不能为index(索引)?(23:54)**
  - 新老对比: 对比key相同的值,由于删除了一个数据,所以新数据如果还是按照index去定义key值,那么从删除位置往后的所有数据的key都会-1,那么key相同的进行对比就会发生'错位',这样会导致vue对大量的数据进行更新(相同index下,老数据会更新为前一个索引的值),以此类推,很麻烦,如果是唯一id的化,那么就不会发生'错位',直接删除
  - 数组删除,特指从中间删除时,会增加更新dom的时间成本,唯一的id可以使vue精准地找到位置进行定点删除
- 35.**diff复杂度原理及具体过程画图**
  - ==kerwin录制了js的数据结构和算法课,还是不错的==
  - diff算法是一种通过同层树节点进行比较的高效算法,避免了对树进行逐层搜索,所以时间复杂度只有O(n)
  - Vue Diff: 
    - 组件对比(component Diff): 
      - 如果组件的名字不同,就认为不是同一个组件,直接创建一个新组件替换老组件
      - 如果组件名字相同,就会认为组件可以复用,进入下一阶段Element Diff
    - 元素对比(Element Diff): 
      - 文本标签对比: 
        - 如果标签一样(都是div),那么只更新文本
        - 如果标签不一样,直接创建新标签和替换老标签
      - 列表(数组)对比: 上面讲到的diff数组,分为'更新,添加,删除'操作
  - 具体的源代码原理太复杂,不写了
- 36.**Vue组件中的Data为什么是函数,根组件确实对象?** 
  - data是一个函数的话,每复用一次组件都会返回一个新的data,类似给每个组件实例创造一个私有数据空间,让各个组件维护各自的数据,而写成对象会导致所有组件公用一份data(复杂数据,地址都一样),所以会造成一个变全部变
- 37.**Vue组件通讯**
  - props和emits(基础父子通讯)
  - \$attrs和\$listeners
  - provide和inject(跨级通信)
  - v-model传递
  - \$parent和\$children(暴力修改,不推荐)
  - vuex/pinia,状态共享工具(跳出三界之外统筹规划)
- 38.**什么时候用Vuex?**
  - 只有大项目用,小项目一个store即可
- 39.**Vuex可以直接修改state吗?**
  - 可以,但是无法被监管,无法实现时间漫游/回退,很不安全
- 40.**Vuex的mutation为何不能做异步?**
  - 就这么设计的,如果mutation支持异步,就不知道状态何时更新,不好监控,而通过action处理好异步的数据直接给mutation再处理就更好监控了
- 41.**如何修改Vuex的状态,Vuex中有哪些方法**
  - 推荐: 按照流程套路 this.\$store.commit("mutation中的方法")
  - 不推荐: this.\$store.state.属性
- 42.**Vuex的缺点**
  - 流程麻烦,Vuex是繁琐冗余的,并且state的值会伴随着浏览器的刷新而初始化,无法缓存,只适合大型的单页面应用
  - 当然vuex持久化运行的库 vuex-persistedstate
- 43.**什么是Vue.nextTick()?**
  - nextTick是用于下次dom更新循环结束之后的执行延迟回调,即可以满足回调函数可以享受到dom更新后的数据
  - 我们修改一个状态后,立即在js中获取这个修改状态的dom,你会发现dom内的状态还没有修改,这是vue生命周期规则的特性,dom对象不会立即更新,我们可以写在updated生命周期函数里,但是任何一个状态的修改都会影响updated的执行,重复多次执行这个dom的获取并不是好方法,所以nextTick的作用是会立即获取更新后的dom对象,然后执行回调函数,把你要对此dom的操作放在回调函数内部即可(==nextTick是一次性的==)
  - 之前我们学习封装轮播图时,new Swiper的时机就是在渲染完dom之后的,我们给轮播数据datalist赋值(v-for)数据并不会立马创建dom对象,而在updated中重复new Swiper会出BUG,所以当时就是用的nextTick,在赋值数据后,立马获取更新后的dom对象,然后立即执行new操作,而且nextTick只是一次性的,所以不必担心多次new
- 44.**nextTick的原理,是宏任务还是微任务?**
  - ...
- 45.**虚拟dom为何会提高性能?**
  - 虚拟dom是一个js对象,使用这个js对象来模拟真实的dom(kerwin的课中还专门讲过这个对象的格式,不重要,就是把对象信息用一些格式存储起来了),而且当数据变化时,只会局部刷新变化位置的数据
  - 虚拟dom相当于在js和真实dom中加了一个缓存,利用dom diff算法避免以一些没有必要的dom操作(真实的dom操作是复杂的,例如盖房子,虚拟dom相当于在图纸上删删减减,看看哪一面墙不需要,而真实dom是真的抡大锤拆墙,显然比图纸修改麻烦多了),虚拟dom弄好后一步到位到真dom,提高了性能
  - 步骤如下:
    - 用js对象解构标识DOM树解构,然后根据树构建真正的一个dom树
    - 当状态变更时,重新构造一个对象树,新旧树进行对比,记录两颗树的差异
    - 把2记录的差异应用到步骤1所构建的真正的dom树上,视图就更新
- 46.**==你做过哪些Vue的性能优化?==**
  - 1.首屏加载优化---懒加载(单页面应用没必要一开始加载所有的组件,用到哪个加载那个)
  - 路由的懒加载:
    ```
        {
            path: '/',
            name: 'home',
            component: ()=>import('XXX')
        }
    ```
  - 2.开启服务器Gzip .....(没学过)
  - 有关webpack的插件 ....
  - 3.启动CDN加速,采用cdn方式引入一些第三方资源,用于缓解我们服务器的压力,将其分担给其他的服务器
  - 4.代码层面的优化:
    - computed和watch区分使用场景(==31系统地讲解了==)
    - v-if和v-show的使用,v-if使用的好,可以提高性能,因为条件为假时它可以直接不创建dom,例如: 对用户权限有要求的dom就可以v-if,因为大部分用户没有权限,所以压根不用渲染这个dom,节省浏览器的压力
    - v-for必须添加不重复的key
    - webpack对图片的压缩
    - 避免内存泄漏,少用闭包
    - 减少ES6转ES5的代码,很多浏览器都升级了(不再需要兼容低版本浏览器),我们应该转到更高级的ES8,ES9等
- 47.**vue常用的修饰符**
  - ==v-model修饰符==:
    - 1 .lazy: 光标离开时才会同步,v-model是一有变化就同步(太勤快了)
    - 2 .trim: 输入框过滤首尾空格,比如用户设置密码,账号,用户名等失误输入空格
    - 3 .number: 输入内容的数字部分自动转化为数字类型
      - 如果有非数字的部分内容,会被截取,如果没有一个是数字,那么就无能无力了,全原样转化为字符串
      - 不添加的话,即使输入数字也会默认把数字类型转化为字符串类型
  - ==事件修饰符==:
    - 4 .stop: 阻止事件向上冒泡
    - 5 .prevent 阻止默认行为,比如表单的提交,a标签的跳转
    - 6 .self 必须本事件触发才执行事件处理函数,别的事件冒泡上来的行为不会触发,拒绝接受冒泡
    - 7 .once: 事件只会执行一次
    - 8 .capture: 事件在捕获阶段触发,事件触发阶段'捕获->目标->冒泡',事件触发是目标往外冒泡
    - 9 .sync: 对prop双向绑定
    - 10 .keyCode: 监听按键指令,具体看vue的键码对应表
- 48.**Vue中的tempalte的编译过程**
  - ....难,很底层,又设涉及源代码了
- 49.**Vue3.0的了解**
  - 六大亮点:
    - 1.性能比vue2快1.2-2倍
    - 2.体积比vue2小
    - 3.支持组合式API
    - 4.更好的支持TS
    - 5.更先进的组件
  - 性能更快的原因:
    - 1.diff算法快
    - 2.静态提升
    - 3.事件监听缓存
  - 体积小了: vite大功劳
- 50.**Vue3.0组合式(VCA)API**
  - 如图,hooks方法构建,组合式API十分的简洁,整体性更强,不像选项是API东一块西一块的'割裂感'
    [![pA6XNgU.jpg](https://s21.ax1x.com/2024/11/10/pA6XNgU.jpg)](https://imgse.com/i/pA6XNgU)
    [![pABQDBt.jpg](https://s21.ax1x.com/2024/10/30/pABQDBt.jpg)](https://imgse.com/i/pABQDBt)
- 51.**对ref和reactive的简单理解**
  - ref和ractive都是vue3的监听方法,reactive只能监听复杂类型(arr,数组),ref复杂简单都可以(它是reactive的二次封装),但是我们一般用于监听简单数据类型,因为只能监听一个变量
- 52.**Vuex与redux的区别**
  - redux没学....
- 53.**==简单说下 微信小程序和Vue的区别==**
  - 1.生命周期:
    - 小程序的生命周期是页面方面,更简单
    - .... 待定,kerwin有微信小程序的课(21年的了很旧了,还是先看Plus的吧)